var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toCommonJS = (from) => {
  const moduleCache = __toCommonJS.moduleCache ??= new WeakMap;
  var cached = moduleCache.get(from);
  if (cached)
    return cached;
  var to = __defProp({}, "__esModule", { value: true });
  var desc = { enumerable: false };
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key))
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
  }
  moduleCache.set(from, to);
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// src/error.js
var require_error = __commonJS((exports, module) => {
  var invalidParameterError = function(name, expected, actual) {
    return new TypeError(`Expected <${expected}> for [${name}] but received ${actual} of type <${typeof actual}>`);
  };
  var invalidPathError = function(name, path) {
    return new TypeError(`${name} path ${path} does not exist.`);
  };
  module.exports = {
    invalidPathError,
    invalidParameterError
  };
});

// src/option.js
var require_option = __commonJS((exports, module) => {
  var error = require_error();
  var Option = function(options) {
    this.data = {
      showProgressBar: false,
      throwIfDestinationDoesNotExist: true,
      traceResolution: 600
    };
    this.update(options);
  };
  Option.prototype = {
    all: function() {
      return this.data;
    },
    get: function(option) {
      var options = Object.keys(this.data);
      if (!options.includes(option)) {
        throw error.invalidParameterError("setting", `one of ${options.toString()}`, option);
      }
      return this.data[option];
    },
    update: function(options) {
      for (var key in options) {
        if (Object.prototype.hasOwnProperty.call(this.data, key)) {
          this.data[key] = options[key];
        }
      }
    }
  };
  module.exports = Option;
});

// node_modules/jimp/dist/browser/index.js
var exports_browser = {};
__export(exports_browser, {
  rgbaToInt: () => {
    {
      return rgbaToInt;
    }
  },
  measureTextHeight: () => {
    {
      return measureTextHeight;
    }
  },
  measureText: () => {
    {
      return measureText;
    }
  },
  loadFont: () => {
    {
      return loadFont;
    }
  },
  limit255: () => {
    {
      return limit255;
    }
  },
  intToRGBA: () => {
    {
      return intToRGBA$1;
    }
  },
  distance: () => {
    {
      return distance;
    }
  },
  diff: () => {
    {
      return diff;
    }
  },
  defaultPlugins: () => {
    {
      return defaultPlugins;
    }
  },
  defaultFormats: () => {
    {
      return defaultFormats;
    }
  },
  cssColorToHex: () => {
    {
      return cssColorToHex;
    }
  },
  compareHashes: () => {
    {
      return compareHashes;
    }
  },
  colorDiff: () => {
    {
      return colorDiff;
    }
  },
  VerticalAlign: () => {
    {
      return VerticalAlign;
    }
  },
  ResizeStrategy: () => {
    {
      return ResizeStrategy;
    }
  },
  PNGFilterType: () => {
    {
      return PNGFilterType;
    }
  },
  PNGColorType: () => {
    {
      return PNGColorType;
    }
  },
  JimpMime: () => {
    {
      return JimpMime;
    }
  },
  Jimp: () => {
    {
      return Jimp;
    }
  },
  HorizontalAlign: () => {
    {
      return HorizontalAlign;
    }
  },
  BmpCompression: () => {
    {
      return BmpCompression;
    }
  },
  BlendMode: () => {
    {
      return BlendMode;
    }
  }
});
function* scanIterator(e, t, i, r, n) {
  t = Math.round(t), i = Math.round(i), r = Math.round(r), n = Math.round(n);
  for (let a = i;a < i + n; a++)
    for (let i2 = t;i2 < t + r; i2++) {
      const t2 = e.bitmap.width * a + i2 << 2;
      yield { x: i2, y: a, idx: t2, image: e };
    }
}
function* hilbertCurve$1(e, t, i) {
  const r = Math.max(e, t), n = { width: e, height: t, level: Math.floor(Math.log(r) / Math.log(2) + 1), callback: i, tracker: new ProgressTracker$1(e * t, 99), index: 0, x: 0, y: 0 };
  yield* walkHilbert$1(n, 1), visit$1(n, 0);
}
function* walkHilbert$1(e, t) {
  if (!(e.level < 1)) {
    switch (e.tracker.shouldNotify(e.index) && (yield { progress: e.tracker.progress }), e.level--, t) {
      case 2:
        yield* walkHilbert$1(e, 1), visit$1(e, 3), yield* walkHilbert$1(e, 2), visit$1(e, 4), yield* walkHilbert$1(e, 2), visit$1(e, 2), yield* walkHilbert$1(e, 4);
        break;
      case 3:
        yield* walkHilbert$1(e, 4), visit$1(e, 2), yield* walkHilbert$1(e, 3), visit$1(e, 1), yield* walkHilbert$1(e, 3), visit$1(e, 3), yield* walkHilbert$1(e, 1);
        break;
      case 1:
        yield* walkHilbert$1(e, 2), visit$1(e, 4), yield* walkHilbert$1(e, 1), visit$1(e, 3), yield* walkHilbert$1(e, 1), visit$1(e, 1), yield* walkHilbert$1(e, 3);
        break;
      case 4:
        yield* walkHilbert$1(e, 3), visit$1(e, 1), yield* walkHilbert$1(e, 4), visit$1(e, 2), yield* walkHilbert$1(e, 4), visit$1(e, 4), yield* walkHilbert$1(e, 2);
    }
    e.level++;
  }
}
async function buildPalette(e, { colorDistanceFormula: t, paletteQuantization: i, colors: r, onProgress: n } = {}) {
  return new Promise((a, o) => {
    const s = paletteQuantizationToPaletteQuantizer$1(colorDistanceFormulaToColorDistance$1(t), i, r);
    let l;
    e.forEach((e2) => s.sample(e2));
    const u = s.quantize(), h = () => {
      try {
        const e2 = u.next();
        e2.done ? a(l) : (e2.value.palette && (l = e2.value.palette), n && n(e2.value.progress), setImmediateImpl(h));
      } catch (e2) {
        o(e2);
      }
    };
    setImmediateImpl(h);
  });
}
async function applyPalette(e, t, { colorDistanceFormula: i, imageQuantization: r, onProgress: n } = {}) {
  return new Promise((a, o) => {
    let s;
    const l = imageQuantizationToImageQuantizer$1(colorDistanceFormulaToColorDistance$1(i), r).quantize(e, t), u = () => {
      try {
        const e2 = l.next();
        e2.done ? a(s) : (e2.value.pointContainer && (s = e2.value.pointContainer), n && n(e2.value.progress), setImmediateImpl(u));
      } catch (e2) {
        o(e2);
      }
    };
    setImmediateImpl(u);
  });
}
async function fromStream(e) {
  const t = await strtok3.fromStream(e);
  try {
    return await fromTokenizer(t);
  } finally {
    await t.close();
  }
}
async function fromBuffer(e) {
  if (!(e instanceof Uint8Array || e instanceof ArrayBuffer || Buffer2.isBuffer(e)))
    throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof e}\``);
  const t = e instanceof Buffer2 ? e : Buffer2.from(e);
  if (!(t && t.length > 1))
    return;
  return fromTokenizer(strtok3.fromBuffer(t));
}
async function fromTokenizer(e) {
  try {
    return _fromTokenizer(e);
  } catch (e2) {
    if (!(e2 instanceof strtok3.EndOfStreamError))
      throw e2;
  }
}
async function _fromTokenizer(e) {
  let t = Buffer2.alloc(minimumBytes);
  const i = (e2, i2) => _check(t, e2, i2), r = (e2, t2) => i(stringToBytes(e2), t2);
  if (e.fileInfo.size || (e.fileInfo.size = Number.MAX_SAFE_INTEGER), await e.peekBuffer(t, { length: 12, mayBeLess: true }), i([66, 77]))
    return { ext: "bmp", mime: "image/bmp" };
  if (i([11, 119]))
    return { ext: "ac3", mime: "audio/vnd.dolby.dd-raw" };
  if (i([120, 1]))
    return { ext: "dmg", mime: "application/x-apple-diskimage" };
  if (i([77, 90]))
    return { ext: "exe", mime: "application/x-msdownload" };
  if (i([37, 33]))
    return await e.peekBuffer(t, { length: 24, mayBeLess: true }), r("PS-Adobe-", { offset: 2 }) && r(" EPSF-", { offset: 14 }) ? { ext: "eps", mime: "application/eps" } : { ext: "ps", mime: "application/postscript" };
  if (i([31, 160]) || i([31, 157]))
    return { ext: "Z", mime: "application/x-compress" };
  if (i([255, 216, 255]))
    return { ext: "jpg", mime: "image/jpeg" };
  if (i([73, 73, 188]))
    return { ext: "jxr", mime: "image/vnd.ms-photo" };
  if (i([31, 139, 8]))
    return { ext: "gz", mime: "application/gzip" };
  if (i([66, 90, 104]))
    return { ext: "bz2", mime: "application/x-bzip2" };
  if (r("ID3")) {
    await e.ignore(6);
    const n = await e.readToken(uint32SyncSafeToken);
    return e.position + n > e.fileInfo.size ? { ext: "mp3", mime: "audio/mpeg" } : (await e.ignore(n), fromTokenizer(e));
  }
  if (r("MP+"))
    return { ext: "mpc", mime: "audio/x-musepack" };
  if ((t[0] === 67 || t[0] === 70) && i([87, 83], { offset: 1 }))
    return { ext: "swf", mime: "application/x-shockwave-flash" };
  if (i([71, 73, 70]))
    return { ext: "gif", mime: "image/gif" };
  if (r("FLIF"))
    return { ext: "flif", mime: "image/flif" };
  if (r("8BPS"))
    return { ext: "psd", mime: "image/vnd.adobe.photoshop" };
  if (r("WEBP", { offset: 8 }))
    return { ext: "webp", mime: "image/webp" };
  if (r("MPCK"))
    return { ext: "mpc", mime: "audio/x-musepack" };
  if (r("FORM"))
    return { ext: "aif", mime: "audio/aiff" };
  if (r("icns", { offset: 0 }))
    return { ext: "icns", mime: "image/icns" };
  if (i([80, 75, 3, 4])) {
    try {
      for (;e.position + 30 < e.fileInfo.size; ) {
        await e.readBuffer(t, { length: 30 });
        const a = { compressedSize: t.readUInt32LE(18), uncompressedSize: t.readUInt32LE(22), filenameLength: t.readUInt16LE(26), extraFieldLength: t.readUInt16LE(28) };
        if (a.filename = await e.readToken(new Token.StringType(a.filenameLength, "utf-8")), await e.ignore(a.extraFieldLength), a.filename === "META-INF/mozilla.rsa")
          return { ext: "xpi", mime: "application/x-xpinstall" };
        if (a.filename.endsWith(".rels") || a.filename.endsWith(".xml")) {
          switch (a.filename.split("/")[0]) {
            case "_rels":
            default:
              break;
            case "word":
              return { ext: "docx", mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" };
            case "ppt":
              return { ext: "pptx", mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation" };
            case "xl":
              return { ext: "xlsx", mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" };
          }
        }
        if (a.filename.startsWith("xl/"))
          return { ext: "xlsx", mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" };
        if (a.filename.startsWith("3D/") && a.filename.endsWith(".model"))
          return { ext: "3mf", mime: "model/3mf" };
        if (a.filename === "mimetype" && a.compressedSize === a.uncompressedSize) {
          switch (await e.readToken(new Token.StringType(a.compressedSize, "utf-8"))) {
            case "application/epub+zip":
              return { ext: "epub", mime: "application/epub+zip" };
            case "application/vnd.oasis.opendocument.text":
              return { ext: "odt", mime: "application/vnd.oasis.opendocument.text" };
            case "application/vnd.oasis.opendocument.spreadsheet":
              return { ext: "ods", mime: "application/vnd.oasis.opendocument.spreadsheet" };
            case "application/vnd.oasis.opendocument.presentation":
              return { ext: "odp", mime: "application/vnd.oasis.opendocument.presentation" };
          }
        }
        if (a.compressedSize === 0) {
          let o = -1;
          for (;o < 0 && e.position < e.fileInfo.size; )
            await e.peekBuffer(t, { mayBeLess: true }), o = t.indexOf("504B0304", 0, "hex"), await e.ignore(o >= 0 ? o : t.length);
        } else
          await e.ignore(a.compressedSize);
      }
    } catch (s) {
      if (!(s instanceof strtok3.EndOfStreamError))
        throw s;
    }
    return { ext: "zip", mime: "application/zip" };
  }
  if (r("OggS")) {
    await e.ignore(28);
    const l = Buffer2.alloc(8);
    return await e.readBuffer(l), _check(l, [79, 112, 117, 115, 72, 101, 97, 100]) ? { ext: "opus", mime: "audio/opus" } : _check(l, [128, 116, 104, 101, 111, 114, 97]) ? { ext: "ogv", mime: "video/ogg" } : _check(l, [1, 118, 105, 100, 101, 111, 0]) ? { ext: "ogm", mime: "video/ogg" } : _check(l, [127, 70, 76, 65, 67]) ? { ext: "oga", mime: "audio/ogg" } : _check(l, [83, 112, 101, 101, 120, 32, 32]) ? { ext: "spx", mime: "audio/ogg" } : _check(l, [1, 118, 111, 114, 98, 105, 115]) ? { ext: "ogg", mime: "audio/ogg" } : { ext: "ogx", mime: "application/ogg" };
  }
  if (i([80, 75]) && (t[2] === 3 || t[2] === 5 || t[2] === 7) && (t[3] === 4 || t[3] === 6 || t[3] === 8))
    return { ext: "zip", mime: "application/zip" };
  if (r("ftyp", { offset: 4 }) && 96 & t[8]) {
    const u = t.toString("binary", 8, 12).replace("\0", " ").trim();
    switch (u) {
      case "avif":
        return { ext: "avif", mime: "image/avif" };
      case "mif1":
        return { ext: "heic", mime: "image/heif" };
      case "msf1":
        return { ext: "heic", mime: "image/heif-sequence" };
      case "heic":
      case "heix":
        return { ext: "heic", mime: "image/heic" };
      case "hevc":
      case "hevx":
        return { ext: "heic", mime: "image/heic-sequence" };
      case "qt":
        return { ext: "mov", mime: "video/quicktime" };
      case "M4V":
      case "M4VH":
      case "M4VP":
        return { ext: "m4v", mime: "video/x-m4v" };
      case "M4P":
        return { ext: "m4p", mime: "video/mp4" };
      case "M4B":
        return { ext: "m4b", mime: "audio/mp4" };
      case "M4A":
        return { ext: "m4a", mime: "audio/x-m4a" };
      case "F4V":
        return { ext: "f4v", mime: "video/mp4" };
      case "F4P":
        return { ext: "f4p", mime: "video/mp4" };
      case "F4A":
        return { ext: "f4a", mime: "audio/mp4" };
      case "F4B":
        return { ext: "f4b", mime: "audio/mp4" };
      case "crx":
        return { ext: "cr3", mime: "image/x-canon-cr3" };
      default:
        return u.startsWith("3g") ? u.startsWith("3g2") ? { ext: "3g2", mime: "video/3gpp2" } : { ext: "3gp", mime: "video/3gpp" } : { ext: "mp4", mime: "video/mp4" };
    }
  }
  if (r("MThd"))
    return { ext: "mid", mime: "audio/midi" };
  if (r("wOFF") && (i([0, 1, 0, 0], { offset: 4 }) || r("OTTO", { offset: 4 })))
    return { ext: "woff", mime: "font/woff" };
  if (r("wOF2") && (i([0, 1, 0, 0], { offset: 4 }) || r("OTTO", { offset: 4 })))
    return { ext: "woff2", mime: "font/woff2" };
  if (i([212, 195, 178, 161]) || i([161, 178, 195, 212]))
    return { ext: "pcap", mime: "application/vnd.tcpdump.pcap" };
  if (r("DSD "))
    return { ext: "dsf", mime: "audio/x-dsf" };
  if (r("LZIP"))
    return { ext: "lz", mime: "application/x-lzip" };
  if (r("fLaC"))
    return { ext: "flac", mime: "audio/x-flac" };
  if (i([66, 80, 71, 251]))
    return { ext: "bpg", mime: "image/bpg" };
  if (r("wvpk"))
    return { ext: "wv", mime: "audio/wavpack" };
  if (r("%PDF")) {
    await e.ignore(1350);
    const h = 10485760, c = Buffer2.alloc(Math.min(h, e.fileInfo.size));
    return await e.readBuffer(c, { mayBeLess: true }), c.includes(Buffer2.from("AIPrivateData")) ? { ext: "ai", mime: "application/postscript" } : { ext: "pdf", mime: "application/pdf" };
  }
  if (i([0, 97, 115, 109]))
    return { ext: "wasm", mime: "application/wasm" };
  if (i([73, 73, 42, 0]))
    return r("CR", { offset: 8 }) ? { ext: "cr2", mime: "image/x-canon-cr2" } : i([28, 0, 254, 0], { offset: 8 }) || i([31, 0, 11, 0], { offset: 8 }) ? { ext: "nef", mime: "image/x-nikon-nef" } : i([8, 0, 0, 0], { offset: 4 }) && (i([45, 0, 254, 0], { offset: 8 }) || i([39, 0, 254, 0], { offset: 8 })) ? { ext: "dng", mime: "image/x-adobe-dng" } : (t = Buffer2.alloc(24), await e.peekBuffer(t), (i([16, 251, 134, 1], { offset: 4 }) || i([8, 0, 0, 0], { offset: 4 })) && i([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 }) ? { ext: "arw", mime: "image/x-sony-arw" } : { ext: "tif", mime: "image/tiff" });
  if (i([77, 77, 0, 42]))
    return { ext: "tif", mime: "image/tiff" };
  if (r("MAC "))
    return { ext: "ape", mime: "audio/ape" };
  if (i([26, 69, 223, 163])) {
    async function f() {
      const t2 = await e.peekNumber(Token.UINT8);
      let i2 = 128, r2 = 0;
      for (;!(t2 & i2) && i2 !== 0; )
        ++r2, i2 >>= 1;
      const n = Buffer2.alloc(r2 + 1);
      return await e.readBuffer(n), n;
    }
    async function d() {
      const e2 = await f(), t2 = await f();
      t2[0] ^= 128 >> t2.length - 1;
      const i2 = Math.min(6, t2.length);
      return { id: e2.readUIntBE(0, e2.length), len: t2.readUIntBE(t2.length - i2, i2) };
    }
    async function p(t2, i2) {
      for (;i2 > 0; ) {
        const t3 = await d();
        if (t3.id === 17026)
          return e.readToken(new Token.StringType(t3.len, "utf-8"));
        await e.ignore(t3.len), --i2;
      }
    }
    const m = await d();
    switch (await p(0, m.len)) {
      case "webm":
        return { ext: "webm", mime: "video/webm" };
      case "matroska":
        return { ext: "mkv", mime: "video/x-matroska" };
      default:
        return;
    }
  }
  if (i([82, 73, 70, 70])) {
    if (i([65, 86, 73], { offset: 8 }))
      return { ext: "avi", mime: "video/vnd.avi" };
    if (i([87, 65, 86, 69], { offset: 8 }))
      return { ext: "wav", mime: "audio/vnd.wave" };
    if (i([81, 76, 67, 77], { offset: 8 }))
      return { ext: "qcp", mime: "audio/qcelp" };
  }
  if (r("SQLi"))
    return { ext: "sqlite", mime: "application/x-sqlite3" };
  if (i([78, 69, 83, 26]))
    return { ext: "nes", mime: "application/x-nintendo-nes-rom" };
  if (r("Cr24"))
    return { ext: "crx", mime: "application/x-google-chrome-extension" };
  if (r("MSCF") || r("ISc("))
    return { ext: "cab", mime: "application/vnd.ms-cab-compressed" };
  if (i([237, 171, 238, 219]))
    return { ext: "rpm", mime: "application/x-rpm" };
  if (i([197, 208, 211, 198]))
    return { ext: "eps", mime: "application/eps" };
  if (i([40, 181, 47, 253]))
    return { ext: "zst", mime: "application/zstd" };
  if (i([79, 84, 84, 79, 0]))
    return { ext: "otf", mime: "font/otf" };
  if (r("#!AMR"))
    return { ext: "amr", mime: "audio/amr" };
  if (r("{\\rtf"))
    return { ext: "rtf", mime: "application/rtf" };
  if (i([70, 76, 86, 1]))
    return { ext: "flv", mime: "video/x-flv" };
  if (r("IMPM"))
    return { ext: "it", mime: "audio/x-it" };
  if (r("-lh0-", { offset: 2 }) || r("-lh1-", { offset: 2 }) || r("-lh2-", { offset: 2 }) || r("-lh3-", { offset: 2 }) || r("-lh4-", { offset: 2 }) || r("-lh5-", { offset: 2 }) || r("-lh6-", { offset: 2 }) || r("-lh7-", { offset: 2 }) || r("-lzs-", { offset: 2 }) || r("-lz4-", { offset: 2 }) || r("-lz5-", { offset: 2 }) || r("-lhd-", { offset: 2 }))
    return { ext: "lzh", mime: "application/x-lzh-compressed" };
  if (i([0, 0, 1, 186])) {
    if (i([33], { offset: 4, mask: [241] }))
      return { ext: "mpg", mime: "video/MP1S" };
    if (i([68], { offset: 4, mask: [196] }))
      return { ext: "mpg", mime: "video/MP2P" };
  }
  if (r("ITSF"))
    return { ext: "chm", mime: "application/vnd.ms-htmlhelp" };
  if (i([253, 55, 122, 88, 90, 0]))
    return { ext: "xz", mime: "application/x-xz" };
  if (r("<?xml "))
    return { ext: "xml", mime: "application/xml" };
  if (i([55, 122, 188, 175, 39, 28]))
    return { ext: "7z", mime: "application/x-7z-compressed" };
  if (i([82, 97, 114, 33, 26, 7]) && (t[6] === 0 || t[6] === 1))
    return { ext: "rar", mime: "application/x-rar-compressed" };
  if (r("solid "))
    return { ext: "stl", mime: "model/stl" };
  if (r("BLENDER"))
    return { ext: "blend", mime: "application/x-blender" };
  if (r("!<arch>")) {
    await e.ignore(8);
    return await e.readToken(new Token.StringType(13, "ascii")) === "debian-binary" ? { ext: "deb", mime: "application/x-deb" } : { ext: "ar", mime: "application/x-unix-archive" };
  }
  if (i([137, 80, 78, 71, 13, 10, 26, 10])) {
    async function _() {
      return { length: await e.readToken(Token.INT32_BE), type: await e.readToken(new Token.StringType(4, "binary")) };
    }
    await e.ignore(8);
    do {
      const g = await _();
      if (g.length < 0)
        return;
      switch (g.type) {
        case "IDAT":
          return { ext: "png", mime: "image/png" };
        case "acTL":
          return { ext: "apng", mime: "image/apng" };
        default:
          await e.ignore(g.length + 4);
      }
    } while (e.position + 8 < e.fileInfo.size);
    return { ext: "png", mime: "image/png" };
  }
  if (i([65, 82, 82, 79, 87, 49, 0, 0]))
    return { ext: "arrow", mime: "application/x-apache-arrow" };
  if (i([103, 108, 84, 70, 2, 0, 0, 0]))
    return { ext: "glb", mime: "model/gltf-binary" };
  if (i([102, 114, 101, 101], { offset: 4 }) || i([109, 100, 97, 116], { offset: 4 }) || i([109, 111, 111, 118], { offset: 4 }) || i([119, 105, 100, 101], { offset: 4 }))
    return { ext: "mov", mime: "video/quicktime" };
  if (i([73, 73, 82, 79, 8, 0, 0, 0, 24]))
    return { ext: "orf", mime: "image/x-olympus-orf" };
  if (r("gimp xcf "))
    return { ext: "xcf", mime: "image/x-xcf" };
  if (i([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216]))
    return { ext: "rw2", mime: "image/x-panasonic-rw2" };
  if (i([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
    async function b() {
      const t2 = Buffer2.alloc(16);
      return await e.readBuffer(t2), { id: t2, size: Number(await e.readToken(Token.UINT64_LE)) };
    }
    for (await e.ignore(30);e.position + 24 < e.fileInfo.size; ) {
      const y = await b();
      let w = y.size - 24;
      if (_check(y.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
        const v = Buffer2.alloc(16);
        if (w -= await e.readBuffer(v), _check(v, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
          return { ext: "asf", mime: "audio/x-ms-asf" };
        if (_check(v, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
          return { ext: "asf", mime: "video/x-ms-asf" };
        break;
      }
      await e.ignore(w);
    }
    return { ext: "asf", mime: "application/vnd.ms-asf" };
  }
  if (i([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]))
    return { ext: "ktx", mime: "image/ktx" };
  if ((i([126, 16, 4]) || i([126, 24, 4])) && i([48, 77, 73, 69], { offset: 4 }))
    return { ext: "mie", mime: "application/x-mie" };
  if (i([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 }))
    return { ext: "shp", mime: "application/x-esri-shape" };
  if (i([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
    await e.ignore(20);
    switch (await e.readToken(new Token.StringType(4, "ascii"))) {
      case "jp2 ":
        return { ext: "jp2", mime: "image/jp2" };
      case "jpx ":
        return { ext: "jpx", mime: "image/jpx" };
      case "jpm ":
        return { ext: "jpm", mime: "image/jpm" };
      case "mjp2":
        return { ext: "mj2", mime: "image/mj2" };
      default:
        return;
    }
  }
  if (i([255, 10]) || i([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10]))
    return { ext: "jxl", mime: "image/jxl" };
  if (i([0, 0, 1, 186]) || i([0, 0, 1, 179]))
    return { ext: "mpg", mime: "video/mpeg" };
  if (i([0, 1, 0, 0, 0]))
    return { ext: "ttf", mime: "font/ttf" };
  if (i([0, 0, 1, 0]))
    return { ext: "ico", mime: "image/x-icon" };
  if (i([0, 0, 2, 0]))
    return { ext: "cur", mime: "image/x-icon" };
  if (i([208, 207, 17, 224, 161, 177, 26, 225]))
    return { ext: "cfb", mime: "application/x-cfb" };
  if (await e.peekBuffer(t, { length: Math.min(256, e.fileInfo.size), mayBeLess: true }), r("BEGIN:")) {
    if (r("VCARD", { offset: 6 }))
      return { ext: "vcf", mime: "text/vcard" };
    if (r("VCALENDAR", { offset: 6 }))
      return { ext: "ics", mime: "text/calendar" };
  }
  if (r("FUJIFILMCCD-RAW"))
    return { ext: "raf", mime: "image/x-fujifilm-raf" };
  if (r("Extended Module:"))
    return { ext: "xm", mime: "audio/x-xm" };
  if (r("Creative Voice File"))
    return { ext: "voc", mime: "audio/x-voc" };
  if (i([4, 0, 0, 0]) && t.length >= 16) {
    const x = t.readUInt32LE(12);
    if (x > 12 && t.length >= x + 16)
      try {
        const E = t.slice(16, x + 16).toString();
        if (JSON.parse(E).files)
          return { ext: "asar", mime: "application/x-asar" };
      } catch (k) {
      }
  }
  if (i([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
    return { ext: "mxf", mime: "application/mxf" };
  if (r("SCRM", { offset: 44 }))
    return { ext: "s3m", mime: "audio/x-s3m" };
  if (i([71], { offset: 4 }) && (i([71], { offset: 192 }) || i([71], { offset: 196 })))
    return { ext: "mts", mime: "video/mp2t" };
  if (i([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 }))
    return { ext: "mobi", mime: "application/x-mobipocket-ebook" };
  if (i([68, 73, 67, 77], { offset: 128 }))
    return { ext: "dcm", mime: "application/dicom" };
  if (i([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70]))
    return { ext: "lnk", mime: "application/x.ms.shortcut" };
  if (i([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0]))
    return { ext: "alias", mime: "application/x.apple.alias" };
  if (i([76, 80], { offset: 34 }) && (i([0, 0, 1], { offset: 8 }) || i([1, 0, 2], { offset: 8 }) || i([2, 0, 2], { offset: 8 })))
    return { ext: "eot", mime: "application/vnd.ms-fontobject" };
  if (i([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29]))
    return { ext: "indd", mime: "application/x-indesign" };
  if (await e.peekBuffer(t, { length: Math.min(512, e.fileInfo.size), mayBeLess: true }), tarHeaderChecksumMatches(t))
    return { ext: "tar", mime: "application/x-tar" };
  if (i([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0]))
    return { ext: "skp", mime: "application/vnd.sketchup.skp" };
  if (r("-----BEGIN PGP MESSAGE-----"))
    return { ext: "pgp", mime: "application/pgp-encrypted" };
  if (t.length >= 2 && i([255, 224], { offset: 0, mask: [255, 224] })) {
    if (i([16], { offset: 1, mask: [22] }))
      return i([8], { offset: 1, mask: [8] }), { ext: "aac", mime: "audio/aac" };
    if (i([2], { offset: 1, mask: [6] }))
      return { ext: "mp3", mime: "audio/mpeg" };
    if (i([4], { offset: 1, mask: [6] }))
      return { ext: "mp2", mime: "audio/mpeg" };
    if (i([6], { offset: 1, mask: [6] }))
      return { ext: "mp1", mime: "audio/mpeg" };
  }
}
function to(e, t) {
  return e.then(function(e2) {
    return [null, e2];
  }).catch(function(e2) {
    return [e2, undefined];
  });
}
function Mime$1() {
  this._types = Object.create(null), this._extensions = Object.create(null);
  for (let e = 0;e < arguments.length; e++)
    this.define(arguments[e]);
  this.define = this.define.bind(this), this.getType = this.getType.bind(this), this.getExtension = this.getExtension.bind(this);
}
function srcOver(e, t, i = 1) {
  e.a *= i;
  const r = t.a + e.a - t.a * e.a;
  return { r: (e.r * e.a + t.r * t.a * (1 - e.a)) / r, g: (e.g * e.a + t.g * t.a * (1 - e.a)) / r, b: (e.b * e.a + t.b * t.a * (1 - e.a)) / r, a: r };
}
function dstOver(e, t, i = 1) {
  e.a *= i;
  const r = t.a + e.a - t.a * e.a;
  return { r: (t.r * t.a + e.r * e.a * (1 - t.a)) / r, g: (t.g * t.a + e.g * e.a * (1 - t.a)) / r, b: (t.b * t.a + e.b * e.a * (1 - t.a)) / r, a: r };
}
function multiply(e, t, i = 1) {
  e.a *= i;
  const r = t.a + e.a - t.a * e.a, n = e.r * e.a, a = e.g * e.a, o = e.b * e.a, s = t.r * t.a, l = t.g * t.a, u = t.b * t.a;
  return { r: (n * s + n * (1 - t.a) + s * (1 - e.a)) / r, g: (a * l + a * (1 - t.a) + l * (1 - e.a)) / r, b: (o * u + o * (1 - t.a) + u * (1 - e.a)) / r, a: r };
}
function add(e, t, i = 1) {
  e.a *= i;
  const r = t.a + e.a - t.a * e.a, n = e.r * e.a, a = e.g * e.a, o = e.b * e.a;
  return { r: (n + t.r * t.a) / r, g: (a + t.g * t.a) / r, b: (o + t.b * t.a) / r, a: r };
}
function screen(e, t, i = 1) {
  e.a *= i;
  const r = t.a + e.a - t.a * e.a, n = e.r * e.a, a = e.g * e.a, o = e.b * e.a, s = t.r * t.a, l = t.g * t.a, u = t.b * t.a;
  return { r: (n * t.a + s * e.a - n * s + n * (1 - t.a) + s * (1 - e.a)) / r, g: (a * t.a + l * e.a - a * l + a * (1 - t.a) + l * (1 - e.a)) / r, b: (o * t.a + u * e.a - o * u + o * (1 - t.a) + u * (1 - e.a)) / r, a: r };
}
function overlay(e, t, i = 1) {
  e.a *= i;
  const r = t.a + e.a - t.a * e.a, n = e.r * e.a, a = e.g * e.a, o = e.b * e.a, s = t.r * t.a, l = t.g * t.a, u = t.b * t.a;
  return { r: (2 * s <= t.a ? 2 * n * s + n * (1 - t.a) + s * (1 - e.a) : n * (1 + t.a) + s * (1 + e.a) - 2 * s * n - t.a * e.a) / r, g: (2 * l <= t.a ? 2 * a * l + a * (1 - t.a) + l * (1 - e.a) : a * (1 + t.a) + l * (1 + e.a) - 2 * l * a - t.a * e.a) / r, b: (2 * u <= t.a ? 2 * o * u + o * (1 - t.a) + u * (1 - e.a) : o * (1 + t.a) + u * (1 + e.a) - 2 * u * o - t.a * e.a) / r, a: r };
}
function darken(e, t, i = 1) {
  e.a *= i;
  const r = t.a + e.a - t.a * e.a, n = e.r * e.a, a = e.g * e.a, o = e.b * e.a, s = t.r * t.a, l = t.g * t.a, u = t.b * t.a;
  return { r: (Math.min(n * t.a, s * e.a) + n * (1 - t.a) + s * (1 - e.a)) / r, g: (Math.min(a * t.a, l * e.a) + a * (1 - t.a) + l * (1 - e.a)) / r, b: (Math.min(o * t.a, u * e.a) + o * (1 - t.a) + u * (1 - e.a)) / r, a: r };
}
function lighten(e, t, i = 1) {
  e.a *= i;
  const r = t.a + e.a - t.a * e.a, n = e.r * e.a, a = e.g * e.a, o = e.b * e.a, s = t.r * t.a, l = t.g * t.a, u = t.b * t.a;
  return { r: (Math.max(n * t.a, s * e.a) + n * (1 - t.a) + s * (1 - e.a)) / r, g: (Math.max(a * t.a, l * e.a) + a * (1 - t.a) + l * (1 - e.a)) / r, b: (Math.max(o * t.a, u * e.a) + o * (1 - t.a) + u * (1 - e.a)) / r, a: r };
}
function hardLight(e, t, i = 1) {
  e.a *= i;
  const r = t.a + e.a - t.a * e.a, n = e.r * e.a, a = e.g * e.a, o = e.b * e.a, s = t.r * t.a, l = t.g * t.a, u = t.b * t.a;
  return { r: (2 * n <= e.a ? 2 * n * s + n * (1 - t.a) + s * (1 - e.a) : n * (1 + t.a) + s * (1 + e.a) - 2 * s * n - t.a * e.a) / r, g: (2 * a <= e.a ? 2 * a * l + a * (1 - t.a) + l * (1 - e.a) : a * (1 + t.a) + l * (1 + e.a) - 2 * l * a - t.a * e.a) / r, b: (2 * o <= e.a ? 2 * o * u + o * (1 - t.a) + u * (1 - e.a) : o * (1 + t.a) + u * (1 + e.a) - 2 * u * o - t.a * e.a) / r, a: r };
}
function difference(e, t, i = 1) {
  e.a *= i;
  const r = t.a + e.a - t.a * e.a, n = e.r * e.a, a = e.g * e.a, o = e.b * e.a, s = t.r * t.a, l = t.g * t.a, u = t.b * t.a;
  return { r: (n + s - 2 * Math.min(n * t.a, s * e.a)) / r, g: (a + l - 2 * Math.min(a * t.a, l * e.a)) / r, b: (o + u - 2 * Math.min(o * t.a, u * e.a)) / r, a: r };
}
function exclusion(e, t, i = 1) {
  e.a *= i;
  const r = t.a + e.a - t.a * e.a, n = e.r * e.a, a = e.g * e.a, o = e.b * e.a, s = t.r * t.a, l = t.g * t.a, u = t.b * t.a;
  return { r: (n * t.a + s * e.a - 2 * n * s + n * (1 - t.a) + s * (1 - e.a)) / r, g: (a * t.a + l * e.a - 2 * a * l + a * (1 - t.a) + l * (1 - e.a)) / r, b: (o * t.a + u * e.a - 2 * o * u + o * (1 - t.a) + u * (1 - e.a)) / r, a: r };
}
function composite(e, t, i = 0, r = 0, n = {}) {
  if (!(t instanceof e.constructor))
    throw new Error("The source must be a Jimp image");
  if (typeof i != "number" || typeof r != "number")
    throw new Error("x and y must be numbers");
  const { mode: a = BlendMode.SRC_OVER } = n;
  let { opacitySource: o = 1, opacityDest: s = 1 } = n;
  (typeof o != "number" || o < 0 || o > 1) && (o = 1), (typeof s != "number" || s < 0 || s > 1) && (s = 1);
  const l = compositeModes[a];
  return i = Math.round(i), r = Math.round(r), s !== 1 && e.scan((t2, i2, r2) => {
    const n2 = e.bitmap.data[r2 + 3] * s;
    e.bitmap.data[r2 + 3] = n2;
  }), t.scan((n2, a2, s2) => {
    const u = e.getPixelIndex(i + n2, r + a2, Edge.CROP);
    if (u === -1)
      return;
    const h = l({ r: t.bitmap.data[s2 + 0] / 255, g: t.bitmap.data[s2 + 1] / 255, b: t.bitmap.data[s2 + 2] / 255, a: t.bitmap.data[s2 + 3] / 255 }, { r: e.bitmap.data[u + 0] / 255, g: e.bitmap.data[u + 1] / 255, b: e.bitmap.data[u + 2] / 255, a: e.bitmap.data[u + 3] / 255 }, o);
    e.bitmap.data[u + 0] = limit255(255 * h.r), e.bitmap.data[u + 1] = limit255(255 * h.g), e.bitmap.data[u + 2] = limit255(255 * h.b), e.bitmap.data[u + 3] = limit255(255 * h.a);
  }), e;
}
function readExifValue(e, t) {
  switch (e) {
    case 1:
      return t.nextUInt8();
    case 3:
    case 8:
      return t.nextUInt16();
    case 4:
    case 9:
      return t.nextUInt32();
    case 5:
      return [t.nextUInt32(), t.nextUInt32()];
    case 6:
      return t.nextInt8();
    case 10:
      return [t.nextInt32(), t.nextInt32()];
    case 11:
      return t.nextFloat();
    case 12:
      return t.nextDouble();
    default:
      throw new Error("Invalid format while decoding: " + e);
  }
}
function getBytesPerComponent(e) {
  switch (e) {
    case 1:
    case 2:
    case 6:
    case 7:
      return 1;
    case 3:
    case 8:
      return 2;
    case 4:
    case 9:
    case 11:
      return 4;
    case 5:
    case 10:
    case 12:
      return 8;
    default:
      return 0;
  }
}
function readExifTag(e, t) {
  var i, r, n = t.nextUInt16(), a = t.nextUInt16(), o = getBytesPerComponent(a), s = t.nextUInt32(), l = o * s;
  if (l > 4 && (t = e.openWithOffset(t.nextUInt32())), a === 2) {
    var u = (i = t.nextString(s)).indexOf("\0");
    u !== -1 && (i = i.substr(0, u));
  } else if (a === 7)
    i = t.nextBuffer(s);
  else if (a !== 0)
    for (i = [], r = 0;r < s; ++r)
      i.push(readExifValue(a, t));
  return l < 4 && t.skip(4 - l), [n, i, a];
}
function readIFDSection(e, t, i) {
  var r, n, a = t.nextUInt16();
  for (n = 0;n < a; ++n)
    i((r = readExifTag(e, t))[0], r[1], r[2]);
}
function readHeader(e) {
  if (e.nextString(6) !== "Exif\0\0")
    throw new Error("Invalid EXIF header");
  var t = e.mark(), i = e.nextUInt16();
  if (i === 18761)
    e.setBigEndian(false);
  else {
    if (i !== 19789)
      throw new Error("Invalid TIFF header");
    e.setBigEndian(true);
  }
  if (e.nextUInt16() !== 42)
    throw new Error("Invalid TIFF data");
  return t;
}
function parseNumber(e) {
  return parseInt(e, 10);
}
function parseDateTimeParts(e, t) {
  e = e.map(parseNumber), t = t.map(parseNumber);
  var i = e[0], r = e[1] - 1, n = e[2], a = t[0], o = t[1], s = t[2];
  return Date.UTC(i, r, n, a, o, s, 0) / 1000;
}
function parseDateWithTimezoneFormat(e) {
  var t = e.substr(0, 10).split("-"), i = e.substr(11, 8).split(":"), r = e.substr(19, 6).split(":").map(parseNumber), n = r[0] * hours + r[1] * minutes, a = parseDateTimeParts(t, i);
  if (typeof (a -= n) == "number" && !isNaN(a))
    return a;
}
function parseDateWithSpecFormat(e) {
  var t = e.split(" "), i = parseDateTimeParts(t[0].split(":"), t[1].split(":"));
  if (typeof i == "number" && !isNaN(i))
    return i;
}
function parseExifDate(e) {
  var t = e.length === 19 && e.charAt(4) === ":";
  return e.length === 25 && e.charAt(10) === "T" ? parseDateWithTimezoneFormat(e) : t ? parseDateWithSpecFormat(e) : undefined;
}
function requireExifTags() {
  return hasRequiredExifTags ? exifTags : (hasRequiredExifTags = 1, exifTags = { exif: { 1: "InteropIndex", 2: "InteropVersion", 11: "ProcessingSoftware", 254: "SubfileType", 255: "OldSubfileType", 256: "ImageWidth", 257: "ImageHeight", 258: "BitsPerSample", 259: "Compression", 262: "PhotometricInterpretation", 263: "Thresholding", 264: "CellWidth", 265: "CellLength", 266: "FillOrder", 269: "DocumentName", 270: "ImageDescription", 271: "Make", 272: "Model", 273: "StripOffsets", 274: "Orientation", 277: "SamplesPerPixel", 278: "RowsPerStrip", 279: "StripByteCounts", 280: "MinSampleValue", 281: "MaxSampleValue", 282: "XResolution", 283: "YResolution", 284: "PlanarConfiguration", 285: "PageName", 286: "XPosition", 287: "YPosition", 288: "FreeOffsets", 289: "FreeByteCounts", 290: "GrayResponseUnit", 291: "GrayResponseCurve", 292: "T4Options", 293: "T6Options", 296: "ResolutionUnit", 297: "PageNumber", 300: "ColorResponseUnit", 301: "TransferFunction", 305: "Software", 306: "ModifyDate", 315: "Artist", 316: "HostComputer", 317: "Predictor", 318: "WhitePoint", 319: "PrimaryChromaticities", 320: "ColorMap", 321: "HalftoneHints", 322: "TileWidth", 323: "TileLength", 324: "TileOffsets", 325: "TileByteCounts", 326: "BadFaxLines", 327: "CleanFaxData", 328: "ConsecutiveBadFaxLines", 330: "SubIFD", 332: "InkSet", 333: "InkNames", 334: "NumberofInks", 336: "DotRange", 337: "TargetPrinter", 338: "ExtraSamples", 339: "SampleFormat", 340: "SMinSampleValue", 341: "SMaxSampleValue", 342: "TransferRange", 343: "ClipPath", 344: "XClipPathUnits", 345: "YClipPathUnits", 346: "Indexed", 347: "JPEGTables", 351: "OPIProxy", 400: "GlobalParametersIFD", 401: "ProfileType", 402: "FaxProfile", 403: "CodingMethods", 404: "VersionYear", 405: "ModeNumber", 433: "Decode", 434: "DefaultImageColor", 435: "T82Options", 437: "JPEGTables", 512: "JPEGProc", 513: "ThumbnailOffset", 514: "ThumbnailLength", 515: "JPEGRestartInterval", 517: "JPEGLosslessPredictors", 518: "JPEGPointTransforms", 519: "JPEGQTables", 520: "JPEGDCTables", 521: "JPEGACTables", 529: "YCbCrCoefficients", 530: "YCbCrSubSampling", 531: "YCbCrPositioning", 532: "ReferenceBlackWhite", 559: "StripRowCounts", 700: "ApplicationNotes", 999: "USPTOMiscellaneous", 4096: "RelatedImageFileFormat", 4097: "RelatedImageWidth", 4098: "RelatedImageHeight", 18246: "Rating", 18247: "XP_DIP_XML", 18248: "StitchInfo", 18249: "RatingPercent", 32781: "ImageID", 32931: "WangTag1", 32932: "WangAnnotation", 32933: "WangTag3", 32934: "WangTag4", 32995: "Matteing", 32996: "DataType", 32997: "ImageDepth", 32998: "TileDepth", 33405: "Model2", 33421: "CFARepeatPatternDim", 33422: "CFAPattern2", 33423: "BatteryLevel", 33424: "KodakIFD", 33432: "Copyright", 33434: "ExposureTime", 33437: "FNumber", 33445: "MDFileTag", 33446: "MDScalePixel", 33447: "MDColorTable", 33448: "MDLabName", 33449: "MDSampleInfo", 33450: "MDPrepDate", 33451: "MDPrepTime", 33452: "MDFileUnits", 33550: "PixelScale", 33589: "AdventScale", 33590: "AdventRevision", 33628: "UIC1Tag", 33629: "UIC2Tag", 33630: "UIC3Tag", 33631: "UIC4Tag", 33723: "IPTC-NAA", 33918: "IntergraphPacketData", 33919: "IntergraphFlagRegisters", 33920: "IntergraphMatrix", 33921: "INGRReserved", 33922: "ModelTiePoint", 34016: "Site", 34017: "ColorSequence", 34018: "IT8Header", 34019: "RasterPadding", 34020: "BitsPerRunLength", 34021: "BitsPerExtendedRunLength", 34022: "ColorTable", 34023: "ImageColorIndicator", 34024: "BackgroundColorIndicator", 34025: "ImageColorValue", 34026: "BackgroundColorValue", 34027: "PixelIntensityRange", 34028: "TransparencyIndicator", 34029: "ColorCharacterization", 34030: "HCUsage", 34031: "TrapIndicator", 34032: "CMYKEquivalent", 34118: "SEMInfo", 34152: "AFCP_IPTC", 34232: "PixelMagicJBIGOptions", 34264: "ModelTransform", 34306: "WB_GRGBLevels", 34310: "LeafData", 34377: "PhotoshopSettings", 34665: "ExifOffset", 34675: "ICC_Profile", 34687: "TIFF_FXExtensions", 34688: "MultiProfiles", 34689: "SharedData", 34690: "T88Options", 34732: "ImageLayer", 34735: "GeoTiffDirectory", 34736: "GeoTiffDoubleParams", 34737: "GeoTiffAsciiParams", 34850: "ExposureProgram", 34852: "SpectralSensitivity", 34853: "GPSInfo", 34855: "ISO", 34856: "Opto-ElectricConvFactor", 34857: "Interlace", 34858: "TimeZoneOffset", 34859: "SelfTimerMode", 34864: "SensitivityType", 34865: "StandardOutputSensitivity", 34866: "RecommendedExposureIndex", 34867: "ISOSpeed", 34868: "ISOSpeedLatitudeyyy", 34869: "ISOSpeedLatitudezzz", 34908: "FaxRecvParams", 34909: "FaxSubAddress", 34910: "FaxRecvTime", 34954: "LeafSubIFD", 36864: "ExifVersion", 36867: "DateTimeOriginal", 36868: "CreateDate", 37121: "ComponentsConfiguration", 37122: "CompressedBitsPerPixel", 37377: "ShutterSpeedValue", 37378: "ApertureValue", 37379: "BrightnessValue", 37380: "ExposureCompensation", 37381: "MaxApertureValue", 37382: "SubjectDistance", 37383: "MeteringMode", 37384: "LightSource", 37385: "Flash", 37386: "FocalLength", 37387: "FlashEnergy", 37388: "SpatialFrequencyResponse", 37389: "Noise", 37390: "FocalPlaneXResolution", 37391: "FocalPlaneYResolution", 37392: "FocalPlaneResolutionUnit", 37393: "ImageNumber", 37394: "SecurityClassification", 37395: "ImageHistory", 37396: "SubjectArea", 37397: "ExposureIndex", 37398: "TIFF-EPStandardID", 37399: "SensingMethod", 37434: "CIP3DataFile", 37435: "CIP3Sheet", 37436: "CIP3Side", 37439: "StoNits", 37500: "MakerNote", 37510: "UserComment", 37520: "SubSecTime", 37521: "SubSecTimeOriginal", 37522: "SubSecTimeDigitized", 37679: "MSDocumentText", 37680: "MSPropertySetStorage", 37681: "MSDocumentTextPosition", 37724: "ImageSourceData", 40091: "XPTitle", 40092: "XPComment", 40093: "XPAuthor", 40094: "XPKeywords", 40095: "XPSubject", 40960: "FlashpixVersion", 40961: "ColorSpace", 40962: "ExifImageWidth", 40963: "ExifImageHeight", 40964: "RelatedSoundFile", 40965: "InteropOffset", 41483: "FlashEnergy", 41484: "SpatialFrequencyResponse", 41485: "Noise", 41486: "FocalPlaneXResolution", 41487: "FocalPlaneYResolution", 41488: "FocalPlaneResolutionUnit", 41489: "ImageNumber", 41490: "SecurityClassification", 41491: "ImageHistory", 41492: "SubjectLocation", 41493: "ExposureIndex", 41494: "TIFF-EPStandardID", 41495: "SensingMethod", 41728: "FileSource", 41729: "SceneType", 41730: "CFAPattern", 41985: "CustomRendered", 41986: "ExposureMode", 41987: "WhiteBalance", 41988: "DigitalZoomRatio", 41989: "FocalLengthIn35mmFormat", 41990: "SceneCaptureType", 41991: "GainControl", 41992: "Contrast", 41993: "Saturation", 41994: "Sharpness", 41995: "DeviceSettingDescription", 41996: "SubjectDistanceRange", 42016: "ImageUniqueID", 42032: "OwnerName", 42033: "SerialNumber", 42034: "LensInfo", 42035: "LensMake", 42036: "LensModel", 42037: "LensSerialNumber", 42112: "GDALMetadata", 42113: "GDALNoData", 42240: "Gamma", 44992: "ExpandSoftware", 44993: "ExpandLens", 44994: "ExpandFilm", 44995: "ExpandFilterLens", 44996: "ExpandScanner", 44997: "ExpandFlashLamp", 48129: "PixelFormat", 48130: "Transformation", 48131: "Uncompressed", 48132: "ImageType", 48256: "ImageWidth", 48257: "ImageHeight", 48258: "WidthResolution", 48259: "HeightResolution", 48320: "ImageOffset", 48321: "ImageByteCount", 48322: "AlphaOffset", 48323: "AlphaByteCount", 48324: "ImageDataDiscard", 48325: "AlphaDataDiscard", 50215: "OceScanjobDesc", 50216: "OceApplicationSelector", 50217: "OceIDNumber", 50218: "OceImageLogic", 50255: "Annotations", 50341: "PrintIM", 50560: "USPTOOriginalContentType", 50706: "DNGVersion", 50707: "DNGBackwardVersion", 50708: "UniqueCameraModel", 50709: "LocalizedCameraModel", 50710: "CFAPlaneColor", 50711: "CFALayout", 50712: "LinearizationTable", 50713: "BlackLevelRepeatDim", 50714: "BlackLevel", 50715: "BlackLevelDeltaH", 50716: "BlackLevelDeltaV", 50717: "WhiteLevel", 50718: "DefaultScale", 50719: "DefaultCropOrigin", 50720: "DefaultCropSize", 50721: "ColorMatrix1", 50722: "ColorMatrix2", 50723: "CameraCalibration1", 50724: "CameraCalibration2", 50725: "ReductionMatrix1", 50726: "ReductionMatrix2", 50727: "AnalogBalance", 50728: "AsShotNeutral", 50729: "AsShotWhiteXY", 50730: "BaselineExposure", 50731: "BaselineNoise", 50732: "BaselineSharpness", 50733: "BayerGreenSplit", 50734: "LinearResponseLimit", 50735: "CameraSerialNumber", 50736: "DNGLensInfo", 50737: "ChromaBlurRadius", 50738: "AntiAliasStrength", 50739: "ShadowScale", 50740: "DNGPrivateData", 50741: "MakerNoteSafety", 50752: "RawImageSegmentation", 50778: "CalibrationIlluminant1", 50779: "CalibrationIlluminant2", 50780: "BestQualityScale", 50781: "RawDataUniqueID", 50784: "AliasLayerMetadata", 50827: "OriginalRawFileName", 50828: "OriginalRawFileData", 50829: "ActiveArea", 50830: "MaskedAreas", 50831: "AsShotICCProfile", 50832: "AsShotPreProfileMatrix", 50833: "CurrentICCProfile", 50834: "CurrentPreProfileMatrix", 50879: "ColorimetricReference", 50898: "PanasonicTitle", 50899: "PanasonicTitle2", 50931: "CameraCalibrationSig", 50932: "ProfileCalibrationSig", 50933: "ProfileIFD", 50934: "AsShotProfileName", 50935: "NoiseReductionApplied", 50936: "ProfileName", 50937: "ProfileHueSatMapDims", 50938: "ProfileHueSatMapData1", 50939: "ProfileHueSatMapData2", 50940: "ProfileToneCurve", 50941: "ProfileEmbedPolicy", 50942: "ProfileCopyright", 50964: "ForwardMatrix1", 50965: "ForwardMatrix2", 50966: "PreviewApplicationName", 50967: "PreviewApplicationVersion", 50968: "PreviewSettingsName", 50969: "PreviewSettingsDigest", 50970: "PreviewColorSpace", 50971: "PreviewDateTime", 50972: "RawImageDigest", 50973: "OriginalRawFileDigest", 50974: "SubTileBlockSize", 50975: "RowInterleaveFactor", 50981: "ProfileLookTableDims", 50982: "ProfileLookTableData", 51008: "OpcodeList1", 51009: "OpcodeList2", 51022: "OpcodeList3", 51041: "NoiseProfile", 51043: "TimeCodes", 51044: "FrameRate", 51058: "TStop", 51081: "ReelName", 51089: "OriginalDefaultFinalSize", 51090: "OriginalBestQualitySize", 51091: "OriginalDefaultCropSize", 51105: "CameraLabel", 51107: "ProfileHueSatMapEncoding", 51108: "ProfileLookTableEncoding", 51109: "BaselineExposureOffset", 51110: "DefaultBlackRender", 51111: "NewRawImageDigest", 51112: "RawToPreviewGain", 51125: "DefaultUserCrop", 59932: "Padding", 59933: "OffsetSchema", 65000: "OwnerName", 65001: "SerialNumber", 65002: "Lens", 65024: "KDC_IFD", 65100: "RawFile", 65101: "Converter", 65102: "WhiteBalance", 65105: "Exposure", 65106: "Shadows", 65107: "Brightness", 65108: "Contrast", 65109: "Saturation", 65110: "Sharpness", 65111: "Smoothness", 65112: "MoireFilter" }, gps: { 0: "GPSVersionID", 1: "GPSLatitudeRef", 2: "GPSLatitude", 3: "GPSLongitudeRef", 4: "GPSLongitude", 5: "GPSAltitudeRef", 6: "GPSAltitude", 7: "GPSTimeStamp", 8: "GPSSatellites", 9: "GPSStatus", 10: "GPSMeasureMode", 11: "GPSDOP", 12: "GPSSpeedRef", 13: "GPSSpeed", 14: "GPSTrackRef", 15: "GPSTrack", 16: "GPSImgDirectionRef", 17: "GPSImgDirection", 18: "GPSMapDatum", 19: "GPSDestLatitudeRef", 20: "GPSDestLatitude", 21: "GPSDestLongitudeRef", 22: "GPSDestLongitude", 23: "GPSDestBearingRef", 24: "GPSDestBearing", 25: "GPSDestDistanceRef", 26: "GPSDestDistance", 27: "GPSProcessingMethod", 28: "GPSAreaInformation", 29: "GPSDateStamp", 30: "GPSDifferential", 31: "GPSHPositioningError" } });
}
function ExifResult(e, t, i, r, n, a, o) {
  this.startMarker = e, this.tags = t, this.imageSize = i, this.thumbnailOffset = r, this.thumbnailLength = n, this.thumbnailType = a, this.app1Offset = o;
}
function Parser$1(e) {
  this.stream = e, this.flags = { readBinaryTags: false, resolveTagNames: true, simplifyValues: true, imageSize: true, hidePointers: true, returnTags: true };
}
function requireDomBufferstream() {
  if (hasRequiredDomBufferstream)
    return domBufferstream;
  function e(e2, t, i, r, n, a) {
    this.global = n, t = t || 0, i = i || e2.byteLength - t, this.arrayBuffer = e2.slice(t, t + i), this.view = new n.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength), this.setBigEndian(r), this.offset = 0, this.parentOffset = (a || 0) + t;
  }
  return hasRequiredDomBufferstream = 1, e.prototype = { setBigEndian: function(e2) {
    this.littleEndian = !e2;
  }, nextUInt8: function() {
    var e2 = this.view.getUint8(this.offset);
    return this.offset += 1, e2;
  }, nextInt8: function() {
    var e2 = this.view.getInt8(this.offset);
    return this.offset += 1, e2;
  }, nextUInt16: function() {
    var e2 = this.view.getUint16(this.offset, this.littleEndian);
    return this.offset += 2, e2;
  }, nextUInt32: function() {
    var e2 = this.view.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e2;
  }, nextInt16: function() {
    var e2 = this.view.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e2;
  }, nextInt32: function() {
    var e2 = this.view.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e2;
  }, nextFloat: function() {
    var e2 = this.view.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e2;
  }, nextDouble: function() {
    var e2 = this.view.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e2;
  }, nextBuffer: function(e2) {
    var t = this.arrayBuffer.slice(this.offset, this.offset + e2);
    return this.offset += e2, t;
  }, remainingLength: function() {
    return this.arrayBuffer.byteLength - this.offset;
  }, nextString: function(e2) {
    var t = this.arrayBuffer.slice(this.offset, this.offset + e2);
    return t = String.fromCharCode.apply(null, new this.global.Uint8Array(t)), this.offset += e2, t;
  }, mark: function() {
    var t = this;
    return { openWithOffset: function(i) {
      return i = (i || 0) + this.offset, new e(t.arrayBuffer, i, t.arrayBuffer.byteLength - i, !t.littleEndian, t.global, t.parentOffset);
    }, offset: this.offset, getParentOffset: function() {
      return t.parentOffset;
    } };
  }, offsetFrom: function(e2) {
    return this.parentOffset + this.offset - (e2.offset + e2.getParentOffset());
  }, skip: function(e2) {
    this.offset += e2;
  }, branch: function(t, i) {
    return i = typeof i == "number" ? i : this.arrayBuffer.byteLength - (this.offset + t), new e(this.arrayBuffer, this.offset + t, i, !this.littleEndian, this.global, this.parentOffset);
  } }, domBufferstream = e;
}
function requireBufferstream() {
  if (hasRequiredBufferstream)
    return bufferstream;
  function e(e2, t, i, r) {
    this.buffer = e2, this.offset = t || 0, i = typeof i == "number" ? i : e2.length, this.endPosition = this.offset + i, this.setBigEndian(r);
  }
  return hasRequiredBufferstream = 1, e.prototype = { setBigEndian: function(e2) {
    this.bigEndian = !!e2;
  }, nextUInt8: function() {
    var e2 = this.buffer.readUInt8(this.offset);
    return this.offset += 1, e2;
  }, nextInt8: function() {
    var e2 = this.buffer.readInt8(this.offset);
    return this.offset += 1, e2;
  }, nextUInt16: function() {
    var e2 = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
    return this.offset += 2, e2;
  }, nextUInt32: function() {
    var e2 = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, e2;
  }, nextInt16: function() {
    var e2 = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
    return this.offset += 2, e2;
  }, nextInt32: function() {
    var e2 = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
    return this.offset += 4, e2;
  }, nextFloat: function() {
    var e2 = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
    return this.offset += 4, e2;
  }, nextDouble: function() {
    var e2 = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
    return this.offset += 8, e2;
  }, nextBuffer: function(e2) {
    var t = this.buffer.slice(this.offset, this.offset + e2);
    return this.offset += e2, t;
  }, remainingLength: function() {
    return this.endPosition - this.offset;
  }, nextString: function(e2) {
    var t = this.buffer.toString("utf8", this.offset, this.offset + e2);
    return this.offset += e2, t;
  }, mark: function() {
    var t = this;
    return { openWithOffset: function(i) {
      return i = (i || 0) + this.offset, new e(t.buffer, i, t.endPosition - i, t.bigEndian);
    }, offset: this.offset };
  }, offsetFrom: function(e2) {
    return this.offset - e2.offset;
  }, skip: function(e2) {
    this.offset += e2;
  }, branch: function(t, i) {
    return i = typeof i == "number" ? i : this.endPosition - (this.offset + t), new e(this.buffer, this.offset + t, i, this.bigEndian);
  } }, bufferstream = e;
}
function getGlobal() {
  return (0, eval)("this");
}
function getExifOrientation(e) {
  const t = e._exif;
  return t && t.tags && t.tags.Orientation || 1;
}
function getExifOrientationTransformation(e) {
  const t = e.bitmap.width, i = e.bitmap.height;
  switch (getExifOrientation(e)) {
    case 1:
    default:
      return null;
    case 2:
      return function(e2, i2) {
        return [t - e2 - 1, i2];
      };
    case 3:
      return function(e2, r) {
        return [t - e2 - 1, i - r - 1];
      };
    case 4:
      return function(e2, t2) {
        return [e2, i - t2 - 1];
      };
    case 5:
      return function(e2, t2) {
        return [t2, e2];
      };
    case 6:
      return function(e2, t2) {
        return [t2, i - e2 - 1];
      };
    case 7:
      return function(e2, r) {
        return [t - r - 1, i - e2 - 1];
      };
    case 8:
      return function(e2, i2) {
        return [t - i2 - 1, e2];
      };
  }
}
function transformBitmap(e, t, i, r) {
  const n = e.bitmap.data, a = e.bitmap.width, o = Buffer2.alloc(n.length);
  for (let e2 = 0;e2 < t; e2++)
    for (let s = 0;s < i; s++) {
      const [i2, l] = r(e2, s), u = t * s + e2 << 2, h = a * l + i2 << 2, c = n.readUInt32BE(h);
      o.writeUInt32BE(c, u);
    }
  e.bitmap.data = o, e.bitmap.width = t, e.bitmap.height = i, e._exif.tags.Orientation = 1;
}
function exifRotate(e) {
  if (getExifOrientation(e) < 2)
    return;
  const t = getExifOrientationTransformation(e), i = getExifOrientation(e) > 4, r = i ? e.bitmap.height : e.bitmap.width, n = i ? e.bitmap.width : e.bitmap.height;
  t && transformBitmap(e, r, n, t);
}
async function attemptExifRotate(e, t) {
  try {
    e._exif = EXIFParser.create(t).parse(), exifRotate(e);
  } catch {
  }
}
function bufferFromArrayBuffer(e) {
  const t = Buffer2.alloc(e.byteLength), i = new Uint8Array(e);
  for (let e2 = 0;e2 < t.length; ++e2)
    t[e2] = i[e2];
  return t;
}
function createJimp({ plugins: e, formats: t } = {}) {
  const i = e || [], r = (t || []).map((e2) => e2()), n = class {
    constructor(e2 = emptyBitmap) {
      if (__publicField$2(this, "bitmap", emptyBitmap), __publicField$2(this, "background", 0), __publicField$2(this, "formats", []), __publicField$2(this, "mime"), this.formats = r, "data" in e2)
        this.bitmap = e2;
      else if (this.bitmap = { data: Buffer2.alloc(e2.width * e2.height * 4), width: e2.width, height: e2.height }, e2.color) {
        this.background = typeof e2.color == "string" ? cssColorToHex(e2.color) : e2.color;
        for (let e3 = 0;e3 < this.bitmap.data.length; e3 += 4)
          this.bitmap.data.writeUInt32BE(this.background, e3);
      }
      for (const e3 of i)
        for (const t2 in e3)
          this[t2] = (...i2) => {
            const r2 = e3[t2]?.(this, ...i2);
            return typeof r2 == "object" && "bitmap" in r2 ? (this.bitmap = r2.bitmap, this) : r2;
          };
    }
    static async read(e2, t2) {
      if (Buffer2.isBuffer(e2) || e2 instanceof ArrayBuffer)
        return this.fromBuffer(e2);
      const [i2, r2] = await to(fetch(e2));
      if (i2)
        throw new Error(`Could not load Buffer from URL: ${e2}`);
      if (!r2.ok)
        throw new Error(`HTTP Status ${r2.status} for url ${e2}`);
      const [n2, a] = await to(r2.arrayBuffer());
      if (n2)
        throw new Error(`Could not load Buffer from ${e2}`);
      const o = bufferFromArrayBuffer(a);
      return this.fromBuffer(o, t2);
    }
    static fromBitmap(e2) {
      let t2;
      if (e2.data instanceof Buffer2 && (t2 = Buffer2.from(e2.data)), (e2.data instanceof Uint8Array || e2.data instanceof Uint8ClampedArray) && (t2 = Buffer2.from(e2.data.buffer)), Array.isArray(e2.data) && (t2 = Buffer2.concat(e2.data.map((e3) => Buffer2.from(e3.toString(16).padStart(8, "0"), "hex")))), !t2)
        throw new Error("data must be a Buffer");
      if (typeof e2.height != "number" || typeof e2.width != "number")
        throw new Error("bitmap must have width and height");
      return new n({ height: e2.height, width: e2.width, data: t2 });
    }
    static async fromBuffer(e2, t2) {
      const i2 = e2 instanceof ArrayBuffer ? bufferFromArrayBuffer(e2) : e2, a = await fileType$1.fromBuffer(i2);
      if (!a || !a.mime)
        throw new Error("Could not find MIME for Buffer");
      const o = r.find((e3) => e3.mime === a.mime);
      if (!o || !o.decode)
        throw new Error(`Mime type ${a.mime} does not support decoding`);
      const s = new n(await o.decode(i2, t2?.[o.mime]));
      return s.mime = a.mime, attemptExifRotate(s, i2), s;
    }
    inspect() {
      return "<Jimp " + (this.bitmap === emptyBitmap ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
    }
    toString() {
      return "[object Jimp]";
    }
    get width() {
      return this.bitmap.width;
    }
    get height() {
      return this.bitmap.height;
    }
    async getBuffer(e2, t2) {
      const i2 = this.formats.find((t3) => t3.mime === e2);
      if (!i2 || !i2.encode)
        throw new Error(`Unsupported MIME type: ${e2}`);
      let r2;
      return i2.hasAlpha ? r2 = this : (r2 = new n({ width: this.bitmap.width, height: this.bitmap.height, color: this.background }), composite(r2, this)), i2.encode(r2.bitmap, t2);
    }
    async getBase64(e2, t2) {
      return "data:" + e2 + ";base64," + (await this.getBuffer(e2, t2)).toString("base64");
    }
    async write(e2, t2) {
      const i2 = mime.getType(e2);
      await writeFile(e2, await this.getBuffer(i2, t2));
    }
    clone() {
      return new n({ ...this.bitmap, data: Buffer2.from(this.bitmap.data) });
    }
    getPixelIndex(e2, t2, i2) {
      let r2, n2;
      if (i2 || (i2 = Edge.EXTEND), typeof e2 != "number" || typeof t2 != "number")
        throw new Error("x and y must be numbers");
      r2 = e2 = Math.round(e2), n2 = t2 = Math.round(t2), i2 === Edge.EXTEND && (e2 < 0 && (r2 = 0), e2 >= this.bitmap.width && (r2 = this.bitmap.width - 1), t2 < 0 && (n2 = 0), t2 >= this.bitmap.height && (n2 = this.bitmap.height - 1)), i2 === Edge.WRAP && (e2 < 0 && (r2 = this.bitmap.width + e2), e2 >= this.bitmap.width && (r2 = e2 % this.bitmap.width), t2 < 0 && (n2 = this.bitmap.height + t2), t2 >= this.bitmap.height && (n2 = t2 % this.bitmap.height));
      let a = this.bitmap.width * n2 + r2 << 2;
      return (r2 < 0 || r2 >= this.bitmap.width) && (a = -1), (n2 < 0 || n2 >= this.bitmap.height) && (a = -1), a;
    }
    getPixelColor(e2, t2) {
      if (typeof e2 != "number" || typeof t2 != "number")
        throw new Error("x and y must be numbers");
      const i2 = this.getPixelIndex(e2, t2);
      return this.bitmap.data.readUInt32BE(i2);
    }
    setPixelColor(e2, t2, i2) {
      if (typeof e2 != "number" || typeof t2 != "number" || typeof i2 != "number")
        throw new Error("hex, x and y must be numbers");
      const r2 = this.getPixelIndex(t2, i2);
      return this.bitmap.data.writeUInt32BE(e2, r2), this;
    }
    hasAlpha() {
      const { width: e2, height: t2, data: i2 } = this.bitmap, r2 = e2 * t2 << 2;
      for (let e3 = 3;e3 < r2; e3 += 4)
        if (i2[e3] !== 255)
          return true;
      return false;
    }
    composite(e2, t2 = 0, i2 = 0, r2 = {}) {
      return composite(this, e2, t2, i2, r2);
    }
    scan(e2, t2, i2, r2, n2) {
      return scan(this, e2, t2, i2, r2, n2);
    }
    scanIterator(e2 = 0, t2 = 0, i2 = this.bitmap.width, r2 = this.bitmap.height) {
      if (typeof e2 != "number" || typeof t2 != "number")
        throw new Error("x and y must be numbers");
      if (typeof i2 != "number" || typeof r2 != "number")
        throw new Error("w and h must be numbers");
      return scanIterator(this, e2, t2, i2, r2);
    }
  };
  return n;
}
function Resize(e, t, i, r, n, a, o) {
  this.widthOriginal = Math.abs(Math.floor(e) || 0), this.heightOriginal = Math.abs(Math.floor(t) || 0), this.targetWidth = Math.abs(Math.floor(i) || 0), this.targetHeight = Math.abs(Math.floor(r) || 0), this.colorChannels = n ? 4 : 3, this.interpolationPass = Boolean(a), this.resizeCallback = typeof o == "function" ? o : function() {
  }, this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels, this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels, this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels, this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal, this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight, this.initialize();
}
function Converter$1(e, t) {
  if (!(e && t && e.length && t.length))
    throw new Error("Bad alphabet");
  this.srcAlphabet = e, this.dstAlphabet = t;
}
function anyBase(e, t) {
  var i = new Converter(e, t);
  return function(e2) {
    return i.convert(e2);
  };
}
function intToRGBA(e) {
  const t = 255 & e, i = 255 & (e >>>= 8), r = 255 & (e >>>= 8);
  return { r: 255 & (e >>>= 8), g: r, b: i, a: t };
}
function initCoefficients(e) {
  for (let t = 1;t < e; t++)
    c$1[t] = 1;
  c$1[0] = 1 / Math.sqrt(2);
}
function applyDCT(e, t) {
  const i = t, r = [];
  for (let t2 = 0;t2 < i; t2++) {
    const n = [];
    for (let a = 0;a < i; a++) {
      let o = 0;
      for (let r2 = 0;r2 < i; r2++)
        for (let n2 = 0;n2 < i; n2++)
          o += Math.cos((2 * r2 + 1) / (2 * i) * t2 * Math.PI) * Math.cos((2 * n2 + 1) / (2 * i) * a * Math.PI) * e[r2][n2];
      o *= c$1[t2] * c$1[a] / 4, n[a] = o, r[t2] = n;
    }
  }
  return r;
}
function distance(e, t) {
  const i = new ImagePHash, r = i.getHash(e), n = i.getHash(t);
  return i.distance(r, n);
}
function compareHashes(e, t) {
  return new ImagePHash().distance(e, t);
}
function measureText(e, t) {
  let i = 0;
  for (let r = 0;r < t.length; r++) {
    const n = t[r], a = e.chars[n];
    if (a) {
      const o = e.kernings[n], s = t[r + 1], l = o && s && o[s] && o[s] || 0;
      i += (a.xadvance || 0) + l;
    }
  }
  return i;
}
function splitLines(e, t, i) {
  const r = t.replace(/[\r\n]+/g, " \n").split(" "), n = [];
  let a = [], o = 0;
  return r.forEach((t2) => {
    if (measureText(e, t2 + (r.length > 1 ? " " : "")) > i) {
      const r2 = t2[Symbol.iterator]();
      let o2 = "";
      for (const t3 of r2) {
        const r3 = [...a, o2 + t3].join(" "), s2 = measureText(e, r3);
        s2 < i ? o2 += t3 : s2 > i ? (n.push([...a, o2]), a = [], o2 = t3) : (n.push([...a, o2 + t3]), a = [], o2 = "");
      }
      return;
    }
    const s = [...a, t2].join(" "), l = measureText(e, s);
    l <= i && !t2.includes("\n") ? (l > o && (o = l), a.push(t2)) : (n.push(a), a = [t2.replace("\n", "")]);
  }), n.push(a), { lines: n, longestLine: o };
}
function measureTextHeight(e, t, i) {
  const { lines: r } = splitLines(e, t, i);
  return r.length * e.common.lineHeight;
}
function xOffsetBasedOnAlignment(e, t, i, r) {
  return r === HorizontalAlign.LEFT ? 0 : r === HorizontalAlign.CENTER ? (i - measureText(e, t)) / 2 : i - measureText(e, t);
}
function drawCharacter(e, t, i, r, n) {
  if (n.width > 0 && n.height > 0) {
    const a = t.pages[n.page];
    a && (e = methods$h.blit(e, { src: a, x: i + n.xoffset, y: r + n.yoffset, srcX: n.x, srcY: n.y, srcW: n.width, srcH: n.height }));
  }
  return e;
}
function printText(e, t, i, r, n, a) {
  for (let o = 0;o < n.length; o++) {
    const s = n[o];
    let l;
    l = t.chars[s] ? s : /\s/.test(s) ? "" : "?";
    const u = t.chars[l] || { xadvance: undefined }, h = t.kernings[l];
    u && drawCharacter(e, t, i, r, u);
    const c = n[o + 1];
    i += (h && c && h[c] && h[c] || 0) + (u.xadvance || a);
  }
}
function createIdxTranslationFunction(e) {
  return function(t, i) {
    return i * e + t << 2;
  };
}
function matrixRotate(e, t) {
  if (Math.abs(t) % 90 != 0)
    throw new Error("Unsupported matrix rotation degree");
  const i = e.bitmap.width, r = e.bitmap.height;
  let n;
  switch (t) {
    case 90:
    case -270:
      n = 90;
      break;
    case 180:
    case -180:
      n = 180;
      break;
    case 270:
    case -90:
      n = -90;
      break;
    default:
      throw new Error("Unsupported matrix rotation degree");
  }
  const a = n === 180 ? i : r, o = n === 180 ? r : i, s = Buffer2.alloc(e.bitmap.data.length), l = createIdxTranslationFunction(i), u = createIdxTranslationFunction(a);
  for (let t2 = 0;t2 < i; t2++)
    for (let a2 = 0;a2 < r; a2++) {
      const o2 = l(t2, a2), h = e.bitmap.data.readUInt32BE(o2);
      let c;
      switch (n) {
        case 90:
          c = u(a2, i - t2 - 1);
          break;
        case -90:
          c = u(r - a2 - 1, t2);
          break;
        case 180:
          c = u(i - t2 - 1, r - a2 - 1);
          break;
        default:
          throw new Error("Unsupported matrix rotation angle");
      }
      s.writeUInt32BE(h, c);
    }
  e.bitmap.data = s, e.bitmap.width = a, e.bitmap.height = o;
}
function createTranslationFunction(e, t) {
  return function(i, r) {
    return { x: i + e, y: r + t };
  };
}
function advancedRotate(e, t, i) {
  const r = t * Math.PI / 180, n = Math.cos(r), a = Math.sin(r);
  let o = e.bitmap.width, s = e.bitmap.height;
  if (i === true || typeof i == "string") {
    o = Math.ceil(Math.abs(e.bitmap.width * n) + Math.abs(e.bitmap.height * a)) + 1, s = Math.ceil(Math.abs(e.bitmap.width * a) + Math.abs(e.bitmap.height * n)) + 1, o % 2 != 0 && o++, s % 2 != 0 && s++;
    const t2 = clone(e);
    e.scan((t3, i2, r3) => {
      e.bitmap.data.writeUInt32BE(e.background, r3);
    });
    const r2 = Math.max(o, s, e.bitmap.width, e.bitmap.height);
    e = composite(e = methods$d.resize(e, { h: r2, w: r2, mode: i === true ? undefined : i }), t2, e.bitmap.width / 2 - t2.bitmap.width / 2, e.bitmap.height / 2 - t2.bitmap.height / 2);
  }
  const l = e.bitmap.width, u = e.bitmap.height, h = Buffer2.alloc(e.bitmap.data.length), c = createTranslationFunction(-l / 2, -u / 2), f = createTranslationFunction(l / 2 + 0.5, u / 2 + 0.5);
  for (let t2 = 1;t2 <= u; t2++)
    for (let i2 = 1;i2 <= l; i2++) {
      const r2 = c(i2, t2), o2 = f(n * r2.x - a * r2.y, n * r2.y + a * r2.x), s2 = l * (t2 - 1) + i2 - 1 << 2;
      if (o2.x >= 0 && o2.x < l && o2.y >= 0 && o2.y < u) {
        const t3 = l * (0 | o2.y) + o2.x << 2, i3 = e.bitmap.data.readUInt32BE(t3);
        h.writeUInt32BE(i3, s2);
      } else
        h.writeUInt32BE(e.background, s2);
    }
  if (e.bitmap.data = h, i === true || typeof i == "string") {
    const t2 = Math.max(l / 2 - o / 2, 0), i2 = Math.max(u / 2 - s / 2, 0);
    e = methods$b.crop(e, { x: t2, y: i2, w: o, h: s });
  }
}
function correctGamma(e) {
  return e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92;
}
function rgb2xyz(e, t, i) {
  return { x: 0.4124 * (e = correctGamma(e / 255)) + 0.3576 * (t = correctGamma(t / 255)) + 0.1805 * (i = correctGamma(i / 255)), y: 0.2126 * e + 0.7152 * t + 0.0722 * i, z: 0.0193 * e + 0.1192 * t + 0.9505 * i };
}
function degrees2radians(e) {
  return e * (Math.PI / 180);
}
function max3(e, t, i) {
  let r = e;
  return r < t && (r = t), r < i && (r = i), r;
}
function min3(e, t, i) {
  let r = e;
  return r > t && (r = t), r > i && (r = i), r;
}
function intInRange(e, t, i) {
  return e > i && (e = i), e < t && (e = t), 0 | e;
}
function inRange0to255Rounded(e) {
  return (e = Math.round(e)) > 255 ? e = 255 : e < 0 && (e = 0), e;
}
function inRange0to255(e) {
  return e > 255 ? e = 255 : e < 0 && (e = 0), e;
}
function stableSort(e, t) {
  const i = typeof e[0];
  let r;
  if (i === "number" || i === "string") {
    const i2 = Object.create(null);
    for (let t2 = 0, r2 = e.length;t2 < r2; t2++) {
      const r3 = e[t2];
      i2[r3] || i2[r3] === 0 || (i2[r3] = t2);
    }
    r = e.sort((e2, r2) => t(e2, r2) || i2[e2] - i2[r2]);
  } else {
    const i2 = e.slice(0);
    r = e.sort((e2, r2) => t(e2, r2) || i2.indexOf(e2) - i2.indexOf(r2));
  }
  return r;
}
function rgb2hsl(e, t, i) {
  const r = min3(e, t, i), n = max3(e, t, i), a = n - r, o = (r + n) / 510;
  let s = 0;
  o > 0 && o < 1 && (s = a / (o < 0.5 ? n + r : 510 - n - r));
  let l = 0;
  return a > 0 && (l = n === e ? (t - i) / a : n === t ? 2 + (i - e) / a : 4 + (e - t) / a, l *= 60, l < 0 && (l += 360)), { h: l, s, l: o };
}
function pivot(e) {
  return e > 0.008856 ? e ** (1 / 3) : 7.787 * e + 16 / 116;
}
function xyz2lab(e, t, i) {
  if (e = pivot(e / refX), t = pivot(t / refY), i = pivot(i / refZ), 116 * t - 16 < 0)
    throw new Error("xxx");
  return { L: Math.max(0, 116 * t - 16), a: 500 * (e - t), b: 200 * (t - i) };
}
function rgb2lab(e, t, i) {
  const r = rgb2xyz(e, t, i);
  return xyz2lab(r.x, r.y, r.z);
}
function pivot2(e) {
  return e > 0.206893034 ? e ** 3 : (e - 16 / 116) / 7.787;
}
function lab2xyz(e, t, i) {
  const r = (e + 16) / 116, n = r - i / 200;
  return { x: refX2 * pivot2(t / 500 + r), y: refY2 * pivot2(r), z: refZ2 * pivot2(n) };
}
function correctGamma2(e) {
  return e > 0.0031308 ? 1.055 * e ** (1 / 2.4) - 0.055 : 12.92 * e;
}
function xyz2rgb(e, t, i) {
  const r = correctGamma2(3.2406 * e + -1.5372 * t + -0.4986 * i), n = correctGamma2(-0.9689 * e + 1.8758 * t + 0.0415 * i), a = correctGamma2(0.0557 * e + -0.204 * t + 1.057 * i);
  return { r: inRange0to255Rounded(255 * r), g: inRange0to255Rounded(255 * n), b: inRange0to255Rounded(255 * a) };
}
function lab2rgb(e, t, i) {
  const r = lab2xyz(e, t, i);
  return xyz2rgb(r.x, r.y, r.z);
}
function hueGroup(e, t) {
  const i = 360 / t;
  for (let r = 1, n = i - i / 2;r < t; r++, n += i)
    if (e >= n && e < n + i)
      return r;
  return 0;
}
function createArray1D(e) {
  const t = [];
  for (let i = 0;i < e; i++)
    t[i] = 0;
  return t;
}
function createArray4D(e, t, i, r) {
  const n = new Array(e);
  for (let a = 0;a < e; a++) {
    n[a] = new Array(t);
    for (let e2 = 0;e2 < t; e2++) {
      n[a][e2] = new Array(i);
      for (let t2 = 0;t2 < i; t2++) {
        n[a][e2][t2] = new Array(r);
        for (let i2 = 0;i2 < r; i2++)
          n[a][e2][t2][i2] = 0;
      }
    }
  }
  return n;
}
function createArray3D(e, t, i) {
  const r = new Array(e);
  for (let n = 0;n < e; n++) {
    r[n] = new Array(t);
    for (let e2 = 0;e2 < t; e2++) {
      r[n][e2] = new Array(i);
      for (let t2 = 0;t2 < i; t2++)
        r[n][e2][t2] = 0;
    }
  }
  return r;
}
function fillArray3D(e, t, i, r, n) {
  for (let a = 0;a < t; a++) {
    e[a] = [];
    for (let t2 = 0;t2 < i; t2++) {
      e[a][t2] = [];
      for (let i2 = 0;i2 < r; i2++)
        e[a][t2][i2] = n;
    }
  }
}
function fillArray1D(e, t, i) {
  for (let r = 0;r < t; r++)
    e[r] = i;
}
function* hilbertCurve(e, t, i) {
  const r = Math.max(e, t), n = { width: e, height: t, level: Math.floor(Math.log(r) / Math.log(2) + 1), callback: i, tracker: new ProgressTracker(e * t, 99), index: 0, x: 0, y: 0 };
  yield* walkHilbert(n, 1), visit(n, 0);
}
function* walkHilbert(e, t) {
  if (!(e.level < 1)) {
    switch (e.tracker.shouldNotify(e.index) && (yield { progress: e.tracker.progress }), e.level--, t) {
      case 2:
        yield* walkHilbert(e, 1), visit(e, 3), yield* walkHilbert(e, 2), visit(e, 4), yield* walkHilbert(e, 2), visit(e, 2), yield* walkHilbert(e, 4);
        break;
      case 3:
        yield* walkHilbert(e, 4), visit(e, 2), yield* walkHilbert(e, 3), visit(e, 1), yield* walkHilbert(e, 3), visit(e, 3), yield* walkHilbert(e, 1);
        break;
      case 1:
        yield* walkHilbert(e, 2), visit(e, 4), yield* walkHilbert(e, 1), visit(e, 3), yield* walkHilbert(e, 1), visit(e, 1), yield* walkHilbert(e, 3);
        break;
      case 4:
        yield* walkHilbert(e, 3), visit(e, 1), yield* walkHilbert(e, 4), visit(e, 2), yield* walkHilbert(e, 4), visit(e, 4), yield* walkHilbert(e, 2);
    }
    e.level++;
  }
}
function visit(e, t) {
  switch (e.x >= 0 && e.x < e.width && e.y >= 0 && e.y < e.height && (e.callback(e.x, e.y), e.index++), t) {
    case 2:
      e.x--;
      break;
    case 3:
      e.x++;
      break;
    case 1:
      e.y--;
      break;
    case 4:
      e.y++;
  }
}
function ssim(e, t) {
  if (e.getHeight() !== t.getHeight() || e.getWidth() !== t.getWidth())
    throw new Error("Images have different sizes!");
  const i = (255 * K1) ** 2, r = (255 * K2) ** 2;
  let n = 0, a = 0;
  return iterate(e, t, (e2, t2, o, s) => {
    let l = 0, u = 0, h = 0;
    for (let i2 = 0;i2 < e2.length; i2++)
      u += (e2[i2] - o) ** 2, h += (t2[i2] - s) ** 2, l += (e2[i2] - o) * (t2[i2] - s);
    const c = e2.length - 1;
    u /= c, h /= c, l /= c;
    a += (2 * o * s + i) * (2 * l + r) / ((o ** 2 + s ** 2 + i) * (u + h + r)), n++;
  }), a / n;
}
function iterate(e, t, i) {
  const r = e.getWidth(), n = e.getHeight();
  for (let a = 0;a < n; a += 8)
    for (let o = 0;o < r; o += 8) {
      const s = Math.min(8, r - o), l = Math.min(8, n - a), u = calculateLumaValuesForWindow(e, o, a, s, l), h = calculateLumaValuesForWindow(t, o, a, s, l);
      i(u, h, calculateAverageLuma(u), calculateAverageLuma(h));
    }
}
function calculateLumaValuesForWindow(e, t, i, r, n) {
  const a = e.getPointArray(), o = [];
  let s = 0;
  for (let l = i;l < i + n; l++) {
    const i2 = l * e.getWidth();
    for (let e2 = t;e2 < t + r; e2++) {
      const t2 = a[i2 + e2];
      o[s] = 0.2126 * t2.r + 0.7152 * t2.g + 0.0722 * t2.b, s++;
    }
  }
  return o;
}
function calculateAverageLuma(e) {
  let t = 0;
  for (const i of e)
    t += i;
  return t / e.length;
}
function buildPaletteSync(e, { colorDistanceFormula: t, paletteQuantization: i, colors: r } = {}) {
  const n = paletteQuantizationToPaletteQuantizer(colorDistanceFormulaToColorDistance(t), i, r);
  return e.forEach((e2) => n.sample(e2)), n.quantizeSync();
}
function applyPaletteSync(e, t, { colorDistanceFormula: i, imageQuantization: r } = {}) {
  return imageQuantizationToImageQuantizer(colorDistanceFormulaToColorDistance(i), r).quantizeSync(e, t);
}
function colorDistanceFormulaToColorDistance(e = "euclidean-bt709") {
  switch (e) {
    case "cie94-graphic-arts":
      return new CIE94GraphicArts;
    case "cie94-textiles":
      return new CIE94Textiles;
    case "ciede2000":
      return new CIEDE2000;
    case "color-metric":
      return new CMetric;
    case "euclidean":
      return new Euclidean;
    case "euclidean-bt709":
      return new EuclideanBT709;
    case "euclidean-bt709-noalpha":
      return new EuclideanBT709NoAlpha;
    case "manhattan":
      return new Manhattan;
    case "manhattan-bt709":
      return new ManhattanBT709;
    case "manhattan-nommyde":
      return new ManhattanNommyde;
    case "pngquant":
      return new PNGQuant;
    default:
      throw new Error(`Unknown colorDistanceFormula ${e}`);
  }
}
function imageQuantizationToImageQuantizer(e, t = "floyd-steinberg") {
  switch (t) {
    case "nearest":
      return new NearestColor(e);
    case "riemersma":
      return new ErrorDiffusionRiemersma(e);
    case "floyd-steinberg":
      return new ErrorDiffusionArray(e, 0);
    case "false-floyd-steinberg":
      return new ErrorDiffusionArray(e, 1);
    case "stucki":
      return new ErrorDiffusionArray(e, 2);
    case "atkinson":
      return new ErrorDiffusionArray(e, 3);
    case "jarvis":
      return new ErrorDiffusionArray(e, 4);
    case "burkes":
      return new ErrorDiffusionArray(e, 5);
    case "sierra":
      return new ErrorDiffusionArray(e, 6);
    case "two-sierra":
      return new ErrorDiffusionArray(e, 7);
    case "sierra-lite":
      return new ErrorDiffusionArray(e, 8);
    default:
      throw new Error(`Unknown imageQuantization ${t}`);
  }
}
function paletteQuantizationToPaletteQuantizer(e, t = "wuquant", i = 256) {
  switch (t) {
    case "neuquant":
      return new NeuQuant(e, i);
    case "rgbquant":
      return new RGBQuant(e, i);
    case "wuquant":
      return new WuQuant(e, i);
    case "neuquant-float":
      return new NeuQuantFloat(e, i);
    default:
      throw new Error(`Unknown paletteQuantization ${t}`);
  }
}
function splitLine(e, t) {
  if (!(e = e.replace(/\t+/g, " ").trim()))
    return null;
  var i = e.indexOf(" ");
  if (i === -1)
    throw new Error("no named row at line " + t);
  var r = e.substring(0, i);
  e = (e = (e = (e = e.substring(i + 1)).replace(/letter=[\'\"]\S+[\'\"]/gi, "")).split("=")).map(function(e2) {
    return e2.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
  });
  for (var n = [], a = 0;a < e.length; a++) {
    var o = e[a];
    a === 0 ? n.push({ key: o[0], data: "" }) : a === e.length - 1 ? n[n.length - 1].data = parseData(o[0]) : (n[n.length - 1].data = parseData(o[0]), n.push({ key: o[1], data: "" }));
  }
  var s = { key: r, data: {} };
  return n.forEach(function(e2) {
    s.data[e2.key] = e2.data;
  }), s;
}
function parseData(e) {
  return e && e.length !== 0 ? e.indexOf('"') === 0 || e.indexOf("'") === 0 ? e.substring(1, e.length - 1) : e.indexOf(",") !== -1 ? parseIntList$1(e) : parseInt(e, 10) : "";
}
function parseIntList$1(e) {
  return e.split(",").map(function(e2) {
    return parseInt(e2, 10);
  });
}
function parseIntList(e) {
  return e.split(",").map(function(e2) {
    return parseInt(e2, 10);
  });
}
function getAttribs(e) {
  return getAttribList(e).reduce(function(e2, t) {
    return e2[mapName(t.nodeName)] = t.nodeValue, e2;
  }, {});
}
function getAttribList(e) {
  for (var t = [], i = 0;i < e.attributes.length; i++)
    t.push(e.attributes[i]);
  return t;
}
function mapName(e) {
  return NAME_MAP[e.toLowerCase()] || e;
}
function readBlock(e, t, i) {
  if (i > t.length - 1)
    return 0;
  var r = t.readUInt8(i++), n = t.readInt32LE(i);
  switch (i += 4, r) {
    case 1:
      e.info = readInfo(t, i);
      break;
    case 2:
      e.common = readCommon(t, i);
      break;
    case 3:
      e.pages = readPages(t, i, n);
      break;
    case 4:
      e.chars = readChars(t, i, n);
      break;
    case 5:
      e.kernings = readKernings(t, i, n);
  }
  return 5 + n;
}
function readInfo(e, t) {
  var i = {};
  i.size = e.readInt16LE(t);
  var r = e.readUInt8(t + 2);
  return i.smooth = r >> 7 & 1, i.unicode = r >> 6 & 1, i.italic = r >> 5 & 1, i.bold = r >> 4 & 1, r >> 3 & 1 && (i.fixedHeight = 1), i.charset = e.readUInt8(t + 3) || "", i.stretchH = e.readUInt16LE(t + 4), i.aa = e.readUInt8(t + 6), i.padding = [e.readInt8(t + 7), e.readInt8(t + 8), e.readInt8(t + 9), e.readInt8(t + 10)], i.spacing = [e.readInt8(t + 11), e.readInt8(t + 12)], i.outline = e.readUInt8(t + 13), i.face = readStringNT(e, t + 14), i;
}
function readCommon(e, t) {
  var i = {};
  return i.lineHeight = e.readUInt16LE(t), i.base = e.readUInt16LE(t + 2), i.scaleW = e.readUInt16LE(t + 4), i.scaleH = e.readUInt16LE(t + 6), i.pages = e.readUInt16LE(t + 8), e.readUInt8(t + 10), i.packed = 0, i.alphaChnl = e.readUInt8(t + 11), i.redChnl = e.readUInt8(t + 12), i.greenChnl = e.readUInt8(t + 13), i.blueChnl = e.readUInt8(t + 14), i;
}
function readPages(e, t, i) {
  for (var r = [], n = readNameNT(e, t), a = n.length + 1, o = i / a, s = 0;s < o; s++)
    r[s] = e.slice(t, t + n.length).toString("utf8"), t += a;
  return r;
}
function readChars(e, t, i) {
  for (var r = [], n = i / 20, a = 0;a < n; a++) {
    var o = {}, s = 20 * a;
    o.id = e.readUInt32LE(t + 0 + s), o.x = e.readUInt16LE(t + 4 + s), o.y = e.readUInt16LE(t + 6 + s), o.width = e.readUInt16LE(t + 8 + s), o.height = e.readUInt16LE(t + 10 + s), o.xoffset = e.readInt16LE(t + 12 + s), o.yoffset = e.readInt16LE(t + 14 + s), o.xadvance = e.readInt16LE(t + 16 + s), o.page = e.readUInt8(t + 18 + s), o.chnl = e.readUInt8(t + 19 + s), r[a] = o;
  }
  return r;
}
function readKernings(e, t, i) {
  for (var r = [], n = i / 10, a = 0;a < n; a++) {
    var o = {}, s = 10 * a;
    o.first = e.readUInt32LE(t + 0 + s), o.second = e.readUInt32LE(t + 4 + s), o.amount = e.readInt16LE(t + 8 + s), r[a] = o;
  }
  return r;
}
function readNameNT(e, t) {
  for (var i = t;i < e.length && e[i] !== 0; i++)
    ;
  return e.slice(t, i);
}
function readStringNT(e, t) {
  return readNameNT(e, t).toString("utf8");
}
function normalizeArray(e, t) {
  for (var i = 0, r = e.length - 1;r >= 0; r--) {
    var n = e[r];
    n === "." ? e.splice(r, 1) : n === ".." ? (e.splice(r, 1), i++) : i && (e.splice(r, 1), i--);
  }
  if (t)
    for (;i--; i)
      e.unshift("..");
  return e;
}
function resolve2() {
  for (var e = "", t = false, i = arguments.length - 1;i >= -1 && !t; i--) {
    var r = i >= 0 ? arguments[i] : "/";
    if (typeof r != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    r && (e = r + "/" + e, t = r.charAt(0) === "/");
  }
  return e = normalizeArray(filter(e.split("/"), function(e2) {
    return !!e2;
  }), !t).join("/"), (t ? "/" : "") + e || ".";
}
function normalize(e) {
  var t = isAbsolute(e), i = substr(e, -1) === "/";
  return e = normalizeArray(filter(e.split("/"), function(e2) {
    return !!e2;
  }), !t).join("/"), e || t || (e = "."), e && i && (e += "/"), (t ? "/" : "") + e;
}
function isAbsolute(e) {
  return e.charAt(0) === "/";
}
function join() {
  return normalize(filter(Array.prototype.slice.call(arguments, 0), function(e, t) {
    if (typeof e != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return e;
  }).join("/"));
}
function relative(e, t) {
  function i(e2) {
    for (var t2 = 0;t2 < e2.length && e2[t2] === ""; t2++)
      ;
    for (var i2 = e2.length - 1;i2 >= 0 && e2[i2] === ""; i2--)
      ;
    return t2 > i2 ? [] : e2.slice(t2, i2 - t2 + 1);
  }
  e = resolve2(e).substr(1), t = resolve2(t).substr(1);
  for (var r = i(e.split("/")), n = i(t.split("/")), a = Math.min(r.length, n.length), o = a, s = 0;s < a; s++)
    if (r[s] !== n[s]) {
      o = s;
      break;
    }
  var l = [];
  for (s = o;s < r.length; s++)
    l.push("..");
  return (l = l.concat(n.slice(o))).join("/");
}
function dirname(e) {
  var t = splitPath(e), i = t[0], r = t[1];
  return i || r ? (r && (r = r.substr(0, r.length - 1)), i + r) : ".";
}
function basename(e, t) {
  var i = splitPath(e)[2];
  return t && i.substr(-1 * t.length) === t && (i = i.substr(0, i.length - t.length)), i;
}
function extname(e) {
  return splitPath(e)[3];
}
function filter(e, t) {
  if (e.filter)
    return e.filter(t);
  for (var i = [], r = 0;r < e.length; r++)
    t(e[r], r, e) && i.push(e[r]);
  return i;
}
function e(e2) {
  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
function b(e2) {
  let t = [], i = "";
  return e2.forEach((e3) => {
    e3.type === O.CONTENT ? i += e3.value : (i.length && (t.push(L(i)), i = ""), t.push(e3));
  }), i.length && t.push(L(i)), t;
}
function isBinary(e2) {
  if (typeof e2 == "string")
    return e2.substring(0, 3) === "BMF";
  const t = e2.slice(0, 4);
  return e2.length > 4 && t[0] === HEADER[0] && t[1] === HEADER[1] && t[2] === HEADER[2];
}
function parseFont(e2, t) {
  return isBinary(t) ? (typeof t == "string" && (t = Buffer2.from(t, "binary")), readBinary(t)) : (t = t.toString().trim(), /.json$/.test(e2) || t.charAt(0) === "{" ? JSON.parse(t) : /.xml$/.test(e2) || t.charAt(0) === "<" ? parseXML(t) : parseASCII(t));
}
function parseNumbersInObject(e2) {
  for (const t in e2) {
    try {
      e2[t] = parseInt(e2[t], 10);
    } catch {
    }
    typeof e2[t] == "object" && parseNumbersInObject(e2[t]);
  }
  return e2;
}
async function loadBitmapFontData(e2) {
  if (isWebWorker && typeof e2 == "string") {
    const t = await fetch(e2), i = await t.text(), r = convertXML(i).font.children.reduce((e3, t2) => ({ ...e3, ...t2 }), {}), n = [], a = [], o = [];
    for (let e3 = 0;e3 < r.pages.children.length; e3++) {
      const t2 = r.pages.children[e3].page;
      n[parseInt(t2.id, 10)] = parseNumbersInObject(t2.file);
    }
    for (let e3 = 0;e3 < r.chars.children.length; e3++)
      a.push(parseNumbersInObject(r.chars.children[e3].char));
    for (let e3 = 0;e3 < r.kernings.children.length; e3++)
      o.push(parseNumbersInObject(r.kernings.children[e3].kerning));
    return { info: r.info, common: r.common, pages: n, chars: a, kernings: o };
  }
  if (typeof e2 == "string") {
    const t = await fetch(e2);
    return parseFont(e2, await t.text());
  }
  return parseFont("", e2);
}
async function processBitmapFont(e2, t) {
  const i = {}, r = {};
  for (let e3 = 0;e3 < t.chars.length; e3++) {
    const r2 = t.chars[e3];
    i[String.fromCharCode(r2.id)] = r2;
  }
  for (let e3 = 0;e3 < t.kernings.length; e3++) {
    const i2 = String.fromCharCode(t.kernings[e3].first);
    r[i2] = r[i2] || {}, r[i2][String.fromCharCode(t.kernings[e3].second)] = t.kernings[e3].amount;
  }
  return { ...t, chars: i, kernings: r, pages: await Promise.all(t.pages.map(async (t2) => CharacterJimp.read(path.join(path.dirname(e2), t2)))) };
}
async function loadFont(e2) {
  let t = e2;
  if (typeof window == "undefined" && !isWebWorker) {
    const { existsSync: i, promises: r } = await Promise.resolve().then(function() {
      return _polyfillNode_fs$1;
    });
    i(e2) && (t = await r.readFile(e2));
  }
  return processBitmapFont(e2, await loadBitmapFontData(t));
}
function pixelmatch(e2, t, i, r, n, a) {
  if (!isPixelData(e2) || !isPixelData(t) || i && !isPixelData(i))
    throw new Error("Image data: Uint8Array, Uint8ClampedArray or Buffer expected.");
  if (e2.length !== t.length || i && i.length !== e2.length)
    throw new Error("Image sizes do not match.");
  if (e2.length !== r * n * 4)
    throw new Error("Image data size does not match width/height.");
  a = Object.assign({}, defaultOptions, a);
  const o = r * n, s = new Uint32Array(e2.buffer, e2.byteOffset, o), l = new Uint32Array(t.buffer, t.byteOffset, o);
  let u = true;
  for (let e3 = 0;e3 < o; e3++)
    if (s[e3] !== l[e3]) {
      u = false;
      break;
    }
  if (u) {
    if (i && !a.diffMask)
      for (let t2 = 0;t2 < o; t2++)
        drawGrayPixel(e2, 4 * t2, a.alpha, i);
    return 0;
  }
  const h = 35215 * a.threshold * a.threshold;
  let c = 0;
  for (let o2 = 0;o2 < n; o2++)
    for (let s2 = 0;s2 < r; s2++) {
      const l2 = 4 * (o2 * r + s2), u2 = colorDelta(e2, t, l2, l2);
      Math.abs(u2) > h ? a.includeAA || !antialiased(e2, s2, o2, r, n, t) && !antialiased(t, s2, o2, r, n, e2) ? (i && drawPixel(i, l2, ...u2 < 0 && a.diffColorAlt || a.diffColor), c++) : i && !a.diffMask && drawPixel(i, l2, ...a.aaColor) : i && (a.diffMask || drawGrayPixel(e2, l2, a.alpha, i));
    }
  return c;
}
function isPixelData(e2) {
  return ArrayBuffer.isView(e2) && e2.constructor.BYTES_PER_ELEMENT === 1;
}
function antialiased(e2, t, i, r, n, a) {
  const o = Math.max(t - 1, 0), s = Math.max(i - 1, 0), l = Math.min(t + 1, r - 1), u = Math.min(i + 1, n - 1), h = 4 * (i * r + t);
  let c, f, d, p, m = t === o || t === l || i === s || i === u ? 1 : 0, _ = 0, g = 0;
  for (let n2 = o;n2 <= l; n2++)
    for (let a2 = s;a2 <= u; a2++) {
      if (n2 === t && a2 === i)
        continue;
      const o2 = colorDelta(e2, e2, h, 4 * (a2 * r + n2), true);
      if (o2 === 0) {
        if (m++, m > 2)
          return false;
      } else
        o2 < _ ? (_ = o2, c = n2, f = a2) : o2 > g && (g = o2, d = n2, p = a2);
    }
  return _ !== 0 && g !== 0 && (hasManySiblings(e2, c, f, r, n) && hasManySiblings(a, c, f, r, n) || hasManySiblings(e2, d, p, r, n) && hasManySiblings(a, d, p, r, n));
}
function hasManySiblings(e2, t, i, r, n) {
  const a = Math.max(t - 1, 0), o = Math.max(i - 1, 0), s = Math.min(t + 1, r - 1), l = Math.min(i + 1, n - 1), u = 4 * (i * r + t);
  let h = t === a || t === s || i === o || i === l ? 1 : 0;
  for (let n2 = a;n2 <= s; n2++)
    for (let a2 = o;a2 <= l; a2++) {
      if (n2 === t && a2 === i)
        continue;
      const o2 = 4 * (a2 * r + n2);
      if (e2[u] === e2[o2] && e2[u + 1] === e2[o2 + 1] && e2[u + 2] === e2[o2 + 2] && e2[u + 3] === e2[o2 + 3] && h++, h > 2)
        return true;
    }
  return false;
}
function colorDelta(e2, t, i, r, n) {
  let a = e2[i + 0], o = e2[i + 1], s = e2[i + 2], l = e2[i + 3], u = t[r + 0], h = t[r + 1], c = t[r + 2], f = t[r + 3];
  if (l === f && a === u && o === h && s === c)
    return 0;
  l < 255 && (l /= 255, a = blend(a, l), o = blend(o, l), s = blend(s, l)), f < 255 && (f /= 255, u = blend(u, f), h = blend(h, f), c = blend(c, f));
  const d = rgb2y(a, o, s), p = rgb2y(u, h, c), m = d - p;
  if (n)
    return m;
  const _ = rgb2i(a, o, s) - rgb2i(u, h, c), g = rgb2q(a, o, s) - rgb2q(u, h, c), b2 = 0.5053 * m * m + 0.299 * _ * _ + 0.1957 * g * g;
  return d > p ? -b2 : b2;
}
function rgb2y(e2, t, i) {
  return 0.29889531 * e2 + 0.58662247 * t + 0.11448223 * i;
}
function rgb2i(e2, t, i) {
  return 0.59597799 * e2 - 0.2741761 * t - 0.32180189 * i;
}
function rgb2q(e2, t, i) {
  return 0.21147017 * e2 - 0.52261711 * t + 0.31114694 * i;
}
function blend(e2, t) {
  return 255 + (e2 - 255) * t;
}
function drawPixel(e2, t, i, r, n) {
  e2[t + 0] = i, e2[t + 1] = r, e2[t + 2] = n, e2[t + 3] = 255;
}
function drawGrayPixel(e2, t, i, r) {
  const n = blend(rgb2y(e2[t + 0], e2[t + 1], e2[t + 2]), i * e2[t + 3] / 255);
  drawPixel(r, t, n, n, n);
}
function diff(e2, t, i = 0.1) {
  let r = e2.bitmap, n = t.bitmap;
  if (r.width === n.width && r.height === n.height || (r.width * r.height > n.width * n.height ? r = methods$d.resize(clone(e2), { w: n.width, h: n.height }).bitmap : n = methods$d.resize(clone(t), { w: r.width, h: r.height }).bitmap), typeof i != "number" || i < 0 || i > 1)
    throw new Error("threshold must be a number between 0 and 1");
  const a = new e2.constructor({ width: r.width, height: r.height, color: 4294967295 });
  return { percent: pixelMatch(r.data, n.data, a.bitmap.data, a.bitmap.width, a.bitmap.height, { threshold: i }) / (a.bitmap.width * a.bitmap.height), image: a };
}

class BmpDecoder {
  flag;
  fileSize;
  reserved1;
  reserved2;
  offset;
  headerSize;
  width;
  height;
  planes;
  bitPP;
  compression;
  rawSize;
  hr;
  vr;
  colors;
  importantColors;
  palette;
  data;
  maskRed;
  maskGreen;
  maskBlue;
  maskAlpha;
  toRGBA;
  pos;
  bottomUp;
  buffer;
  locRed;
  locGreen;
  locBlue;
  locAlpha;
  shiftRed;
  shiftGreen;
  shiftBlue;
  shiftAlpha;
  constructor(e2, { toRGBA: t } = { toRGBA: false }) {
    if (this.buffer = e2, this.toRGBA = !!t, this.pos = 0, this.bottomUp = true, this.flag = this.buffer.toString("utf-8", 0, this.pos += 2), this.flag !== "BM")
      throw new Error("Invalid BMP File");
    this.locRed = this.toRGBA ? 0 : 3, this.locGreen = this.toRGBA ? 1 : 2, this.locBlue = this.toRGBA ? 2 : 1, this.locAlpha = this.toRGBA ? 3 : 0, this.parseHeader(), this.parseRGBA();
  }
  parseHeader() {
    if (this.fileSize = this.readUInt32LE(), this.reserved1 = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.reserved2 = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.offset = this.readUInt32LE(), this.headerSize = this.readUInt32LE(), !(this.headerSize in HeaderTypes$1))
      throw new Error(`Unsupported BMP header size ${this.headerSize}`);
    if (this.width = this.readUInt32LE(), this.height = this.readUInt32LE(), this.height = this.height > 2147483647 ? this.height - 4294967296 : this.height, this.planes = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.bitPP = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.compression = this.readUInt32LE(), this.rawSize = this.readUInt32LE(), this.hr = this.readUInt32LE(), this.vr = this.readUInt32LE(), this.colors = this.readUInt32LE(), this.importantColors = this.readUInt32LE(), this.bitPP === 32 ? (this.maskAlpha = 0, this.maskRed = 16711680, this.maskGreen = 65280, this.maskBlue = 255) : this.bitPP === 16 && (this.maskAlpha = 0, this.maskRed = 31744, this.maskGreen = 992, this.maskBlue = 31), (this.headerSize > HeaderTypes$1.BITMAP_INFO_HEADER || this.compression === BmpCompression.BI_BIT_FIELDS || this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) && (this.maskRed = this.readUInt32LE(), this.maskGreen = this.readUInt32LE(), this.maskBlue = this.readUInt32LE()), (this.headerSize > HeaderTypes$1.BITMAP_V2_INFO_HEADER || this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) && (this.maskAlpha = this.readUInt32LE()), this.headerSize > HeaderTypes$1.BITMAP_V3_INFO_HEADER && (this.pos += HeaderTypes$1.BITMAP_V4_HEADER - HeaderTypes$1.BITMAP_V3_INFO_HEADER), this.headerSize > HeaderTypes$1.BITMAP_V4_HEADER && (this.pos += HeaderTypes$1.BITMAP_V5_HEADER - HeaderTypes$1.BITMAP_V4_HEADER), this.bitPP <= 8 || this.colors > 0) {
      const e3 = this.colors === 0 ? 1 << this.bitPP : this.colors;
      this.palette = new Array(e3);
      for (let t = 0;t < e3; t++) {
        const e4 = this.buffer.readUInt8(this.pos++), i = this.buffer.readUInt8(this.pos++), r = this.buffer.readUInt8(this.pos++), n = this.buffer.readUInt8(this.pos++);
        this.palette[t] = { red: r, green: i, blue: e4, quad: n };
      }
    }
    this.height < 0 && (this.height *= -1, this.bottomUp = false);
    const e2 = maskColor(this.maskRed, this.maskGreen, this.maskBlue, this.maskAlpha);
    this.shiftRed = e2.shiftRed, this.shiftGreen = e2.shiftGreen, this.shiftBlue = e2.shiftBlue, this.shiftAlpha = e2.shiftAlpha;
  }
  parseRGBA() {
    switch (this.data = Buffer2.alloc(this.width * this.height * 4), this.bitPP) {
      case 1:
        this.bit1();
        break;
      case 4:
        this.bit4();
        break;
      case 8:
        this.bit8();
        break;
      case 16:
        this.bit16();
        break;
      case 24:
        this.bit24();
        break;
      default:
        this.bit32();
    }
  }
  bit1() {
    const e2 = Math.ceil(this.width / 8), t = e2 % 4, i = t !== 0 ? 4 - t : 0;
    this.scanImage(i, e2, (e3, t2) => {
      const i2 = this.buffer.readUInt8(this.pos++), r = t2 * this.width * 4 + 8 * e3 * 4;
      for (let t3 = 0;t3 < 8 && 8 * e3 + t3 < this.width; t3++) {
        const e4 = this.palette[i2 >> 7 - t3 & 1];
        this.data[r + t3 * this.locAlpha] = 0, this.data[r + 4 * t3 + this.locBlue] = e4.blue, this.data[r + 4 * t3 + this.locGreen] = e4.green, this.data[r + 4 * t3 + this.locRed] = e4.red;
      }
    });
  }
  bit4() {
    if (this.compression === BmpCompression.BI_RLE4) {
      this.data.fill(0);
      let e2 = false, t = this.bottomUp ? this.height - 1 : 0, i = 0;
      for (;i < this.data.length; ) {
        const r = this.buffer.readUInt8(this.pos++), n = this.buffer.readUInt8(this.pos++);
        if (r === 0) {
          if (n === 0) {
            t += this.bottomUp ? -1 : 1, i = t * this.width * 4, e2 = false;
            continue;
          }
          if (n === 1)
            break;
          if (n === 2) {
            const e3 = this.buffer.readUInt8(this.pos++), r2 = this.buffer.readUInt8(this.pos++);
            t += this.bottomUp ? -r2 : r2, i += r2 * this.width * 4 + 4 * e3;
          } else {
            let t2 = this.buffer.readUInt8(this.pos++);
            for (let r2 = 0;r2 < n; r2++)
              i = this.setPixelData(i, e2 ? 15 & t2 : (240 & t2) >> 4), 1 & r2 && r2 + 1 < n && (t2 = this.buffer.readUInt8(this.pos++)), e2 = !e2;
            (n + 1 >> 1 & 1) == 1 && this.pos++;
          }
        } else
          for (let t2 = 0;t2 < r; t2++)
            i = this.setPixelData(i, e2 ? 15 & n : (240 & n) >> 4), e2 = !e2;
      }
    } else {
      const e2 = Math.ceil(this.width / 2), t = e2 % 4, i = t !== 0 ? 4 - t : 0;
      this.scanImage(i, e2, (e3, t2) => {
        const i2 = this.buffer.readUInt8(this.pos++), r = t2 * this.width * 4 + 2 * e3 * 4, n = i2 >> 4;
        let a = this.palette[n];
        if (this.data[r] = 0, this.data[r + 1] = a.blue, this.data[r + 2] = a.green, this.data[r + 3] = a.red, 2 * e3 + 1 >= this.width)
          return false;
        const o = 15 & i2;
        a = this.palette[o], this.data[r + 4] = 0, this.data[r + 4 + 1] = a.blue, this.data[r + 4 + 2] = a.green, this.data[r + 4 + 3] = a.red;
      });
    }
  }
  bit8() {
    if (this.compression === BmpCompression.BI_RLE8) {
      this.data.fill(0);
      let e2 = this.bottomUp ? this.height - 1 : 0, t = 0;
      for (;t < this.data.length; ) {
        const i = this.buffer.readUInt8(this.pos++), r = this.buffer.readUInt8(this.pos++);
        if (i === 0) {
          if (r === 0) {
            e2 += this.bottomUp ? -1 : 1, t = e2 * this.width * 4;
            continue;
          }
          if (r === 1)
            break;
          if (r === 2) {
            const i2 = this.buffer.readUInt8(this.pos++), r2 = this.buffer.readUInt8(this.pos++);
            e2 += this.bottomUp ? -r2 : r2, t += r2 * this.width * 4 + 4 * i2;
          } else {
            for (let e3 = 0;e3 < r; e3++) {
              const e4 = this.buffer.readUInt8(this.pos++);
              t = this.setPixelData(t, e4);
            }
            true & r && this.pos++;
          }
        } else
          for (let e3 = 0;e3 < i; e3++)
            t = this.setPixelData(t, r);
      }
    } else {
      const e2 = this.width % 4, t = e2 !== 0 ? 4 - e2 : 0;
      this.scanImage(t, this.width, (e3, t2) => {
        const i = this.buffer.readUInt8(this.pos++), r = t2 * this.width * 4 + 4 * e3;
        if (i < this.palette.length) {
          const e4 = this.palette[i];
          this.data[r] = 0, this.data[r + 1] = e4.blue, this.data[r + 2] = e4.green, this.data[r + 3] = e4.red;
        } else
          this.data[r] = 0, this.data[r + 1] = 255, this.data[r + 2] = 255, this.data[r + 3] = 255;
      });
    }
  }
  bit16() {
    const e2 = this.width % 2 * 2;
    this.scanImage(e2, this.width, (e3, t) => {
      const i = t * this.width * 4 + 4 * e3, r = this.buffer.readUInt16LE(this.pos);
      this.pos += 2, this.data[i + this.locRed] = this.shiftRed(r), this.data[i + this.locGreen] = this.shiftGreen(r), this.data[i + this.locBlue] = this.shiftBlue(r), this.data[i + this.locAlpha] = this.shiftAlpha(r);
    });
  }
  bit24() {
    const e2 = this.width % 4;
    this.scanImage(e2, this.width, (e3, t) => {
      const i = t * this.width * 4 + 4 * e3, r = this.buffer.readUInt8(this.pos++), n = this.buffer.readUInt8(this.pos++), a = this.buffer.readUInt8(this.pos++);
      this.data[i + this.locRed] = a, this.data[i + this.locGreen] = n, this.data[i + this.locBlue] = r, this.data[i + this.locAlpha] = 0;
    });
  }
  bit32() {
    this.scanImage(0, this.width, (e2, t) => {
      const i = t * this.width * 4 + 4 * e2, r = this.readUInt32LE();
      this.data[i + this.locRed] = this.shiftRed(r), this.data[i + this.locGreen] = this.shiftGreen(r), this.data[i + this.locBlue] = this.shiftBlue(r), this.data[i + this.locAlpha] = this.shiftAlpha(r);
    });
  }
  scanImage(e2 = 0, t = this.width, i) {
    for (let r = this.height - 1;r >= 0; r--) {
      const n = this.bottomUp ? r : this.height - 1 - r;
      for (let e3 = 0;e3 < t; e3++) {
        if (i.call(this, e3, n) === false)
          return;
      }
      this.pos += e2;
    }
  }
  readUInt32LE() {
    const e2 = this.buffer.readUInt32LE(this.pos);
    return this.pos += 4, e2;
  }
  setPixelData(e2, t) {
    const { blue: i, green: r, red: n } = this.palette[t];
    return this.data[e2 + this.locAlpha] = 0, this.data[e2 + 1 + this.locBlue] = i, this.data[e2 + 2 + this.locGreen] = r, this.data[e2 + 3 + this.locRed] = n, e2 + 4;
  }
}

class BmpEncoder {
  fileSize;
  reserved1;
  reserved2;
  offset;
  width;
  flag;
  height;
  planes;
  bitPP;
  compress;
  hr;
  vr;
  colors;
  importantColors;
  rawSize;
  headerSize;
  data;
  palette;
  extraBytes;
  buffer;
  bytesInColor;
  pos;
  constructor(e2) {
    switch (this.buffer = e2.data, this.width = e2.width, this.height = e2.height, this.headerSize = HeaderTypes$1.BITMAP_INFO_HEADER, this.flag = "BM", this.bitPP = e2.bitPP || 24, this.offset = 54, this.reserved1 = e2.reserved1 || 0, this.reserved2 = e2.reserved2 || 0, this.planes = 1, this.compress = 0, this.hr = e2.hr || 0, this.vr = e2.vr || 0, this.importantColors = e2.importantColors || 0, this.colors = Math.min(2 ** (this.bitPP - 1 || 1), e2.colors || 1 / 0), this.palette = e2.palette || [], this.colors && this.bitPP < 16 ? this.offset += 4 * this.colors : this.colors = 0, this.bitPP) {
      case 32:
        this.bytesInColor = 4;
        break;
      case 16:
        this.bytesInColor = 2;
        break;
      case 8:
        this.bytesInColor = 1;
        break;
      case 4:
        this.bytesInColor = 0.5;
        break;
      case 1:
        this.bytesInColor = 1 / 8;
        break;
      default:
        this.bytesInColor = 3, this.bitPP = 24;
    }
    const t = this.width * this.bitPP / 32, i = Math.ceil(t);
    this.extraBytes = 4 * (i - t), this.rawSize = this.height * i * 4 + 2, this.fileSize = this.rawSize + this.offset, this.data = Buffer2.alloc(this.fileSize, 1), this.pos = 0, this.encode();
  }
  encode() {
    switch (this.pos = 0, this.writeHeader(), this.bitPP) {
      case 32:
        this.bit32();
        break;
      case 16:
        this.bit16();
        break;
      case 8:
        this.bit8();
        break;
      case 4:
        this.bit4();
        break;
      case 1:
        this.bit1();
        break;
      default:
        this.bit24();
    }
  }
  writeHeader() {
    this.data.write(this.flag, this.pos, 2), this.pos += 2, this.writeUInt32LE(this.fileSize), this.writeUInt32LE(this.reserved1 << 16 | this.reserved2), this.writeUInt32LE(this.offset), this.writeUInt32LE(this.headerSize), this.writeUInt32LE(this.width), this.writeUInt32LE(this.height), this.data.writeUInt16LE(this.planes, this.pos), this.pos += 2, this.data.writeUInt16LE(this.bitPP, this.pos), this.pos += 2, this.writeUInt32LE(this.compress), this.writeUInt32LE(this.rawSize), this.writeUInt32LE(this.hr), this.writeUInt32LE(this.vr), this.writeUInt32LE(this.colors), this.writeUInt32LE(this.importantColors);
  }
  bit1() {
    this.palette.length && this.colors === 2 ? this.initColors(1) : (this.writeUInt32LE(16777215), this.writeUInt32LE(0)), this.pos += 1;
    let e2 = [];
    this.writeImage((t, i, r) => {
      let n = i;
      n++;
      const a = this.buffer[n++], o = this.buffer[n++], s = 0.2126 * this.buffer[n++] + 0.7152 * o + 0.0722 * a;
      return e2.push(s > 127 ? 0 : 1), (r + 1) % 8 == 0 ? (this.data[t - 1] = createInteger(e2), e2 = []) : r === this.width - 1 && e2.length > 0 && (this.data[t - 1] = createInteger(e2) << 4, e2 = []), n;
    });
  }
  bit4() {
    const e2 = this.initColors(4);
    let t = [];
    this.writeImage((i, r, n) => {
      let a = r;
      const o = createColor({ quad: this.buffer[a++], blue: this.buffer[a++], green: this.buffer[a++], red: this.buffer[a++] }), s = e2.findIndex((e3) => e3 === o);
      return s !== -1 ? t.push(s) : t.push(0), (n + 1) % 2 == 0 && (this.data[i] = t[0] << 4 | t[1], t = []), a;
    });
  }
  bit8() {
    const e2 = this.initColors(8);
    this.writeImage((t, i) => {
      let r = i;
      const n = createColor({ quad: this.buffer[r++], blue: this.buffer[r++], green: this.buffer[r++], red: this.buffer[r++] }), a = e2.findIndex((e3) => e3 === n);
      return this.data[t] = a !== -1 ? a : 0, r;
    });
  }
  bit16() {
    this.writeImage((e2, t) => {
      let i = t + 1;
      const r = this.buffer[i++] / 8, n = this.buffer[i++] / 8, a = this.buffer[i++] / 8 << 10 | n << 5 | r;
      return this.data[e2] = 255 & a, this.data[e2 + 1] = (65280 & a) >> 8, i;
    });
  }
  bit24() {
    this.writeImage((e2, t) => {
      let i = t + 1;
      return this.data[e2] = this.buffer[i++], this.data[e2 + 1] = this.buffer[i++], this.data[e2 + 2] = this.buffer[i++], i;
    });
  }
  bit32() {
    this.writeImage((e2, t) => {
      let i = t;
      return this.data[e2 + 3] = this.buffer[i++], this.data[e2] = this.buffer[i++], this.data[e2 + 1] = this.buffer[i++], this.data[e2 + 2] = this.buffer[i++], i;
    });
  }
  writeImage(e2) {
    const t = this.extraBytes + this.width * this.bytesInColor;
    let i = 0;
    for (let r = 0;r < this.height; r++)
      for (let n = 0;n < this.width; n++) {
        const a = Math.floor(this.pos + (this.height - 1 - r) * t + n * this.bytesInColor);
        i = e2.call(this, a, i, n, r);
      }
  }
  initColors(e2) {
    const t = [];
    if (!this.palette.length)
      throw new Error(`To encode ${e2}-bit BMPs a pallette is needed. Please choose up to ${this.colors} colors. Colors must be 32-bit integers.`);
    for (let e3 = 0;e3 < this.colors; e3++) {
      const i = createColor(this.palette[e3]);
      this.writeUInt32LE(i), t.push(i);
    }
    return t;
  }
  writeUInt32LE(e2) {
    this.data.writeUInt32LE(e2, this.pos), this.pos += 4;
  }
}

class ZodError extends Error {
  constructor(e4) {
    super(), this.issues = [], this.addIssue = (e5) => {
      this.issues = [...this.issues, e5];
    }, this.addIssues = (e5 = []) => {
      this.issues = [...this.issues, ...e5];
    };
    const t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e4;
  }
  get errors() {
    return this.issues;
  }
  format(e4) {
    const t = e4 || function(e5) {
      return e5.message;
    }, i = { _errors: [] }, r = (e5) => {
      for (const n of e5.issues)
        if (n.code === "invalid_union")
          n.unionErrors.map(r);
        else if (n.code === "invalid_return_type")
          r(n.returnTypeError);
        else if (n.code === "invalid_arguments")
          r(n.argumentsError);
        else if (n.path.length === 0)
          i._errors.push(t(n));
        else {
          let e6 = i, r2 = 0;
          for (;r2 < n.path.length; ) {
            const i2 = n.path[r2];
            r2 === n.path.length - 1 ? (e6[i2] = e6[i2] || { _errors: [] }, e6[i2]._errors.push(t(n))) : e6[i2] = e6[i2] || { _errors: [] }, e6 = e6[i2], r2++;
          }
        }
    };
    return r(this), i;
  }
  static assert(e4) {
    if (!(e4 instanceof ZodError))
      throw new Error(`Not a ZodError: ${e4}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$1.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e4 = (e5) => e5.message) {
    const t = {}, i = [];
    for (const r of this.issues)
      r.path.length > 0 ? (t[r.path[0]] = t[r.path[0]] || [], t[r.path[0]].push(e4(r))) : i.push(e4(r));
    return { formErrors: i, fieldErrors: t };
  }
  get formErrors() {
    return this.flatten();
  }
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e4, t) {
    const i = [];
    for (const r of t) {
      if (r.status === "aborted")
        return INVALID;
      r.status === "dirty" && e4.dirty(), i.push(r.value);
    }
    return { status: e4.value, value: i };
  }
  static async mergeObjectAsync(e4, t) {
    const i = [];
    for (const e5 of t) {
      const t2 = await e5.key, r = await e5.value;
      i.push({ key: t2, value: r });
    }
    return ParseStatus.mergeObjectSync(e4, i);
  }
  static mergeObjectSync(e4, t) {
    const i = {};
    for (const r of t) {
      const { key: t2, value: n } = r;
      if (t2.status === "aborted")
        return INVALID;
      if (n.status === "aborted")
        return INVALID;
      t2.status === "dirty" && e4.dirty(), n.status === "dirty" && e4.dirty(), t2.value === "__proto__" || n.value === undefined && !r.alwaysSet || (i[t2.value] = n.value);
    }
    return { status: e4.value, value: i };
  }
}

class ParseInputLazyPath {
  constructor(e4, t, i, r) {
    this._cachedPath = [], this.parent = e4, this.data = t, this._path = i, this._key = r;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}

class ZodType {
  constructor(e4) {
    this.spa = this.safeParseAsync, this._def = e4, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e4) {
    return getParsedType(e4.data);
  }
  _getOrReturnCtx(e4, t) {
    return t || { common: e4.parent.common, data: e4.data, parsedType: getParsedType(e4.data), schemaErrorMap: this._def.errorMap, path: e4.path, parent: e4.parent };
  }
  _processInputParams(e4) {
    return { status: new ParseStatus, ctx: { common: e4.parent.common, data: e4.data, parsedType: getParsedType(e4.data), schemaErrorMap: this._def.errorMap, path: e4.path, parent: e4.parent } };
  }
  _parseSync(e4) {
    const t = this._parse(e4);
    if (isAsync(t))
      throw new Error("Synchronous parse encountered promise.");
    return t;
  }
  _parseAsync(e4) {
    const t = this._parse(e4);
    return Promise.resolve(t);
  }
  parse(e4, t) {
    const i = this.safeParse(e4, t);
    if (i.success)
      return i.data;
    throw i.error;
  }
  safeParse(e4, t) {
    var i;
    const r = { common: { issues: [], async: (i = t == null ? undefined : t.async) !== null && i !== undefined && i, contextualErrorMap: t == null ? undefined : t.errorMap }, path: (t == null ? undefined : t.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e4, parsedType: getParsedType(e4) }, n = this._parseSync({ data: e4, path: r.path, parent: r });
    return handleResult(r, n);
  }
  async parseAsync(e4, t) {
    const i = await this.safeParseAsync(e4, t);
    if (i.success)
      return i.data;
    throw i.error;
  }
  async safeParseAsync(e4, t) {
    const i = { common: { issues: [], contextualErrorMap: t == null ? undefined : t.errorMap, async: true }, path: (t == null ? undefined : t.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e4, parsedType: getParsedType(e4) }, r = this._parse({ data: e4, path: i.path, parent: i }), n = await (isAsync(r) ? r : Promise.resolve(r));
    return handleResult(i, n);
  }
  refine(e4, t) {
    const i = (e5) => typeof t == "string" || t === undefined ? { message: t } : typeof t == "function" ? t(e5) : t;
    return this._refinement((t2, r) => {
      const n = e4(t2), a = () => r.addIssue({ code: ZodIssueCode.custom, ...i(t2) });
      return typeof Promise != "undefined" && n instanceof Promise ? n.then((e5) => !!e5 || (a(), false)) : !!n || (a(), false);
    });
  }
  refinement(e4, t) {
    return this._refinement((i, r) => !!e4(i) || (r.addIssue(typeof t == "function" ? t(i, r) : t), false));
  }
  _refinement(e4) {
    return new ZodEffects({ schema: this, typeName: ZodFirstPartyTypeKind.ZodEffects, effect: { type: "refinement", refinement: e4 } });
  }
  superRefine(e4) {
    return this._refinement(e4);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(e4) {
    return ZodUnion.create([this, e4], this._def);
  }
  and(e4) {
    return ZodIntersection.create(this, e4, this._def);
  }
  transform(e4) {
    return new ZodEffects({ ...processCreateParams(this._def), schema: this, typeName: ZodFirstPartyTypeKind.ZodEffects, effect: { type: "transform", transform: e4 } });
  }
  default(e4) {
    const t = typeof e4 == "function" ? e4 : () => e4;
    return new ZodDefault({ ...processCreateParams(this._def), innerType: this, defaultValue: t, typeName: ZodFirstPartyTypeKind.ZodDefault });
  }
  brand() {
    return new ZodBranded({ typeName: ZodFirstPartyTypeKind.ZodBranded, type: this, ...processCreateParams(this._def) });
  }
  catch(e4) {
    const t = typeof e4 == "function" ? e4 : () => e4;
    return new ZodCatch({ ...processCreateParams(this._def), innerType: this, catchValue: t, typeName: ZodFirstPartyTypeKind.ZodCatch });
  }
  describe(e4) {
    return new (0, this.constructor)({ ...this._def, description: e4 });
  }
  pipe(e4) {
    return ZodPipeline.create(this, e4);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}

class ZodString extends ZodType {
  _parse(e4) {
    this._def.coerce && (e4.data = String(e4.data));
    if (this._getType(e4) !== ZodParsedType.string) {
      const t2 = this._getOrReturnCtx(e4);
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.string, received: t2.parsedType }), INVALID;
    }
    const t = new ParseStatus;
    let i;
    for (const r of this._def.checks)
      if (r.kind === "min")
        e4.data.length < r.value && (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { code: ZodIssueCode.too_small, minimum: r.value, type: "string", inclusive: true, exact: false, message: r.message }), t.dirty());
      else if (r.kind === "max")
        e4.data.length > r.value && (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { code: ZodIssueCode.too_big, maximum: r.value, type: "string", inclusive: true, exact: false, message: r.message }), t.dirty());
      else if (r.kind === "length") {
        const n = e4.data.length > r.value, a = e4.data.length < r.value;
        (n || a) && (i = this._getOrReturnCtx(e4, i), n ? addIssueToContext(i, { code: ZodIssueCode.too_big, maximum: r.value, type: "string", inclusive: true, exact: true, message: r.message }) : a && addIssueToContext(i, { code: ZodIssueCode.too_small, minimum: r.value, type: "string", inclusive: true, exact: true, message: r.message }), t.dirty());
      } else if (r.kind === "email")
        emailRegex.test(e4.data) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { validation: "email", code: ZodIssueCode.invalid_string, message: r.message }), t.dirty());
      else if (r.kind === "emoji")
        emojiRegex || (emojiRegex = new RegExp(_emojiRegex, "u")), emojiRegex.test(e4.data) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { validation: "emoji", code: ZodIssueCode.invalid_string, message: r.message }), t.dirty());
      else if (r.kind === "uuid")
        uuidRegex.test(e4.data) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { validation: "uuid", code: ZodIssueCode.invalid_string, message: r.message }), t.dirty());
      else if (r.kind === "nanoid")
        nanoidRegex.test(e4.data) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { validation: "nanoid", code: ZodIssueCode.invalid_string, message: r.message }), t.dirty());
      else if (r.kind === "cuid")
        cuidRegex.test(e4.data) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { validation: "cuid", code: ZodIssueCode.invalid_string, message: r.message }), t.dirty());
      else if (r.kind === "cuid2")
        cuid2Regex.test(e4.data) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { validation: "cuid2", code: ZodIssueCode.invalid_string, message: r.message }), t.dirty());
      else if (r.kind === "ulid")
        ulidRegex.test(e4.data) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { validation: "ulid", code: ZodIssueCode.invalid_string, message: r.message }), t.dirty());
      else if (r.kind === "url")
        try {
          new URL(e4.data);
        } catch (n) {
          i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { validation: "url", code: ZodIssueCode.invalid_string, message: r.message }), t.dirty();
        }
      else if (r.kind === "regex") {
        r.regex.lastIndex = 0;
        r.regex.test(e4.data) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { validation: "regex", code: ZodIssueCode.invalid_string, message: r.message }), t.dirty());
      } else if (r.kind === "trim")
        e4.data = e4.data.trim();
      else if (r.kind === "includes")
        e4.data.includes(r.value, r.position) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { code: ZodIssueCode.invalid_string, validation: { includes: r.value, position: r.position }, message: r.message }), t.dirty());
      else if (r.kind === "toLowerCase")
        e4.data = e4.data.toLowerCase();
      else if (r.kind === "toUpperCase")
        e4.data = e4.data.toUpperCase();
      else if (r.kind === "startsWith")
        e4.data.startsWith(r.value) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { code: ZodIssueCode.invalid_string, validation: { startsWith: r.value }, message: r.message }), t.dirty());
      else if (r.kind === "endsWith")
        e4.data.endsWith(r.value) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { code: ZodIssueCode.invalid_string, validation: { endsWith: r.value }, message: r.message }), t.dirty());
      else if (r.kind === "datetime") {
        datetimeRegex(r).test(e4.data) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { code: ZodIssueCode.invalid_string, validation: "datetime", message: r.message }), t.dirty());
      } else if (r.kind === "date") {
        dateRegex.test(e4.data) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { code: ZodIssueCode.invalid_string, validation: "date", message: r.message }), t.dirty());
      } else if (r.kind === "time") {
        timeRegex(r).test(e4.data) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { code: ZodIssueCode.invalid_string, validation: "time", message: r.message }), t.dirty());
      } else
        r.kind === "duration" ? durationRegex.test(e4.data) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { validation: "duration", code: ZodIssueCode.invalid_string, message: r.message }), t.dirty()) : r.kind === "ip" ? isValidIP(e4.data, r.version) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { validation: "ip", code: ZodIssueCode.invalid_string, message: r.message }), t.dirty()) : r.kind === "base64" ? base64Regex.test(e4.data) || (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { validation: "base64", code: ZodIssueCode.invalid_string, message: r.message }), t.dirty()) : util$1.assertNever(r);
    return { status: t.value, value: e4.data };
  }
  _regex(e4, t, i) {
    return this.refinement((t2) => e4.test(t2), { validation: t, code: ZodIssueCode.invalid_string, ...errorUtil.errToObj(i) });
  }
  _addCheck(e4) {
    return new ZodString({ ...this._def, checks: [...this._def.checks, e4] });
  }
  email(e4) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(e4) });
  }
  url(e4) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(e4) });
  }
  emoji(e4) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(e4) });
  }
  uuid(e4) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(e4) });
  }
  nanoid(e4) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(e4) });
  }
  cuid(e4) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(e4) });
  }
  cuid2(e4) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(e4) });
  }
  ulid(e4) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(e4) });
  }
  base64(e4) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(e4) });
  }
  ip(e4) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(e4) });
  }
  datetime(e4) {
    var t, i;
    return typeof e4 == "string" ? this._addCheck({ kind: "datetime", precision: null, offset: false, local: false, message: e4 }) : this._addCheck({ kind: "datetime", precision: (e4 == null ? undefined : e4.precision) === undefined ? null : e4 == null ? undefined : e4.precision, offset: (t = e4 == null ? undefined : e4.offset) !== null && t !== undefined && t, local: (i = e4 == null ? undefined : e4.local) !== null && i !== undefined && i, ...errorUtil.errToObj(e4 == null ? undefined : e4.message) });
  }
  date(e4) {
    return this._addCheck({ kind: "date", message: e4 });
  }
  time(e4) {
    return typeof e4 == "string" ? this._addCheck({ kind: "time", precision: null, message: e4 }) : this._addCheck({ kind: "time", precision: (e4 == null ? undefined : e4.precision) === undefined ? null : e4 == null ? undefined : e4.precision, ...errorUtil.errToObj(e4 == null ? undefined : e4.message) });
  }
  duration(e4) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(e4) });
  }
  regex(e4, t) {
    return this._addCheck({ kind: "regex", regex: e4, ...errorUtil.errToObj(t) });
  }
  includes(e4, t) {
    return this._addCheck({ kind: "includes", value: e4, position: t == null ? undefined : t.position, ...errorUtil.errToObj(t == null ? undefined : t.message) });
  }
  startsWith(e4, t) {
    return this._addCheck({ kind: "startsWith", value: e4, ...errorUtil.errToObj(t) });
  }
  endsWith(e4, t) {
    return this._addCheck({ kind: "endsWith", value: e4, ...errorUtil.errToObj(t) });
  }
  min(e4, t) {
    return this._addCheck({ kind: "min", value: e4, ...errorUtil.errToObj(t) });
  }
  max(e4, t) {
    return this._addCheck({ kind: "max", value: e4, ...errorUtil.errToObj(t) });
  }
  length(e4, t) {
    return this._addCheck({ kind: "length", value: e4, ...errorUtil.errToObj(t) });
  }
  nonempty(e4) {
    return this.min(1, errorUtil.errToObj(e4));
  }
  trim() {
    return new ZodString({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] });
  }
  toLowerCase() {
    return new ZodString({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] });
  }
  toUpperCase() {
    return new ZodString({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
  }
  get isDatetime() {
    return !!this._def.checks.find((e4) => e4.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e4) => e4.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e4) => e4.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e4) => e4.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e4) => e4.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e4) => e4.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e4) => e4.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e4) => e4.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e4) => e4.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e4) => e4.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e4) => e4.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e4) => e4.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e4) => e4.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((e4) => e4.kind === "base64");
  }
  get minLength() {
    let e4 = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e4 === null || t.value > e4) && (e4 = t.value);
    return e4;
  }
  get maxLength() {
    let e4 = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e4 === null || t.value < e4) && (e4 = t.value);
    return e4;
  }
}

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e4) {
    this._def.coerce && (e4.data = Number(e4.data));
    if (this._getType(e4) !== ZodParsedType.number) {
      const t2 = this._getOrReturnCtx(e4);
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.number, received: t2.parsedType }), INVALID;
    }
    let t;
    const i = new ParseStatus;
    for (const r of this._def.checks)
      if (r.kind === "int")
        util$1.isInteger(e4.data) || (t = this._getOrReturnCtx(e4, t), addIssueToContext(t, { code: ZodIssueCode.invalid_type, expected: "integer", received: "float", message: r.message }), i.dirty());
      else if (r.kind === "min") {
        (r.inclusive ? e4.data < r.value : e4.data <= r.value) && (t = this._getOrReturnCtx(e4, t), addIssueToContext(t, { code: ZodIssueCode.too_small, minimum: r.value, type: "number", inclusive: r.inclusive, exact: false, message: r.message }), i.dirty());
      } else if (r.kind === "max") {
        (r.inclusive ? e4.data > r.value : e4.data >= r.value) && (t = this._getOrReturnCtx(e4, t), addIssueToContext(t, { code: ZodIssueCode.too_big, maximum: r.value, type: "number", inclusive: r.inclusive, exact: false, message: r.message }), i.dirty());
      } else
        r.kind === "multipleOf" ? floatSafeRemainder(e4.data, r.value) !== 0 && (t = this._getOrReturnCtx(e4, t), addIssueToContext(t, { code: ZodIssueCode.not_multiple_of, multipleOf: r.value, message: r.message }), i.dirty()) : r.kind === "finite" ? Number.isFinite(e4.data) || (t = this._getOrReturnCtx(e4, t), addIssueToContext(t, { code: ZodIssueCode.not_finite, message: r.message }), i.dirty()) : util$1.assertNever(r);
    return { status: i.value, value: e4.data };
  }
  gte(e4, t) {
    return this.setLimit("min", e4, true, errorUtil.toString(t));
  }
  gt(e4, t) {
    return this.setLimit("min", e4, false, errorUtil.toString(t));
  }
  lte(e4, t) {
    return this.setLimit("max", e4, true, errorUtil.toString(t));
  }
  lt(e4, t) {
    return this.setLimit("max", e4, false, errorUtil.toString(t));
  }
  setLimit(e4, t, i, r) {
    return new ZodNumber({ ...this._def, checks: [...this._def.checks, { kind: e4, value: t, inclusive: i, message: errorUtil.toString(r) }] });
  }
  _addCheck(e4) {
    return new ZodNumber({ ...this._def, checks: [...this._def.checks, e4] });
  }
  int(e4) {
    return this._addCheck({ kind: "int", message: errorUtil.toString(e4) });
  }
  positive(e4) {
    return this._addCheck({ kind: "min", value: 0, inclusive: false, message: errorUtil.toString(e4) });
  }
  negative(e4) {
    return this._addCheck({ kind: "max", value: 0, inclusive: false, message: errorUtil.toString(e4) });
  }
  nonpositive(e4) {
    return this._addCheck({ kind: "max", value: 0, inclusive: true, message: errorUtil.toString(e4) });
  }
  nonnegative(e4) {
    return this._addCheck({ kind: "min", value: 0, inclusive: true, message: errorUtil.toString(e4) });
  }
  multipleOf(e4, t) {
    return this._addCheck({ kind: "multipleOf", value: e4, message: errorUtil.toString(t) });
  }
  finite(e4) {
    return this._addCheck({ kind: "finite", message: errorUtil.toString(e4) });
  }
  safe(e4) {
    return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: errorUtil.toString(e4) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: errorUtil.toString(e4) });
  }
  get minValue() {
    let e4 = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e4 === null || t.value > e4) && (e4 = t.value);
    return e4;
  }
  get maxValue() {
    let e4 = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e4 === null || t.value < e4) && (e4 = t.value);
    return e4;
  }
  get isInt() {
    return !!this._def.checks.find((e4) => e4.kind === "int" || e4.kind === "multipleOf" && util$1.isInteger(e4.value));
  }
  get isFinite() {
    let e4 = null, t = null;
    for (const i of this._def.checks) {
      if (i.kind === "finite" || i.kind === "int" || i.kind === "multipleOf")
        return true;
      i.kind === "min" ? (t === null || i.value > t) && (t = i.value) : i.kind === "max" && (e4 === null || i.value < e4) && (e4 = i.value);
    }
    return Number.isFinite(t) && Number.isFinite(e4);
  }
}

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e4) {
    this._def.coerce && (e4.data = BigInt(e4.data));
    if (this._getType(e4) !== ZodParsedType.bigint) {
      const t2 = this._getOrReturnCtx(e4);
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.bigint, received: t2.parsedType }), INVALID;
    }
    let t;
    const i = new ParseStatus;
    for (const r of this._def.checks)
      if (r.kind === "min") {
        (r.inclusive ? e4.data < r.value : e4.data <= r.value) && (t = this._getOrReturnCtx(e4, t), addIssueToContext(t, { code: ZodIssueCode.too_small, type: "bigint", minimum: r.value, inclusive: r.inclusive, message: r.message }), i.dirty());
      } else if (r.kind === "max") {
        (r.inclusive ? e4.data > r.value : e4.data >= r.value) && (t = this._getOrReturnCtx(e4, t), addIssueToContext(t, { code: ZodIssueCode.too_big, type: "bigint", maximum: r.value, inclusive: r.inclusive, message: r.message }), i.dirty());
      } else
        r.kind === "multipleOf" ? e4.data % r.value !== BigInt(0) && (t = this._getOrReturnCtx(e4, t), addIssueToContext(t, { code: ZodIssueCode.not_multiple_of, multipleOf: r.value, message: r.message }), i.dirty()) : util$1.assertNever(r);
    return { status: i.value, value: e4.data };
  }
  gte(e4, t) {
    return this.setLimit("min", e4, true, errorUtil.toString(t));
  }
  gt(e4, t) {
    return this.setLimit("min", e4, false, errorUtil.toString(t));
  }
  lte(e4, t) {
    return this.setLimit("max", e4, true, errorUtil.toString(t));
  }
  lt(e4, t) {
    return this.setLimit("max", e4, false, errorUtil.toString(t));
  }
  setLimit(e4, t, i, r) {
    return new ZodBigInt({ ...this._def, checks: [...this._def.checks, { kind: e4, value: t, inclusive: i, message: errorUtil.toString(r) }] });
  }
  _addCheck(e4) {
    return new ZodBigInt({ ...this._def, checks: [...this._def.checks, e4] });
  }
  positive(e4) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: errorUtil.toString(e4) });
  }
  negative(e4) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: errorUtil.toString(e4) });
  }
  nonpositive(e4) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: errorUtil.toString(e4) });
  }
  nonnegative(e4) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: errorUtil.toString(e4) });
  }
  multipleOf(e4, t) {
    return this._addCheck({ kind: "multipleOf", value: e4, message: errorUtil.toString(t) });
  }
  get minValue() {
    let e4 = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e4 === null || t.value > e4) && (e4 = t.value);
    return e4;
  }
  get maxValue() {
    let e4 = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e4 === null || t.value < e4) && (e4 = t.value);
    return e4;
  }
}

class ZodBoolean extends ZodType {
  _parse(e4) {
    this._def.coerce && (e4.data = Boolean(e4.data));
    if (this._getType(e4) !== ZodParsedType.boolean) {
      const t = this._getOrReturnCtx(e4);
      return addIssueToContext(t, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.boolean, received: t.parsedType }), INVALID;
    }
    return OK(e4.data);
  }
}

class ZodDate extends ZodType {
  _parse(e4) {
    this._def.coerce && (e4.data = new Date(e4.data));
    if (this._getType(e4) !== ZodParsedType.date) {
      const t2 = this._getOrReturnCtx(e4);
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.date, received: t2.parsedType }), INVALID;
    }
    if (isNaN(e4.data.getTime())) {
      return addIssueToContext(this._getOrReturnCtx(e4), { code: ZodIssueCode.invalid_date }), INVALID;
    }
    const t = new ParseStatus;
    let i;
    for (const r of this._def.checks)
      r.kind === "min" ? e4.data.getTime() < r.value && (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { code: ZodIssueCode.too_small, message: r.message, inclusive: true, exact: false, minimum: r.value, type: "date" }), t.dirty()) : r.kind === "max" ? e4.data.getTime() > r.value && (i = this._getOrReturnCtx(e4, i), addIssueToContext(i, { code: ZodIssueCode.too_big, message: r.message, inclusive: true, exact: false, maximum: r.value, type: "date" }), t.dirty()) : util$1.assertNever(r);
    return { status: t.value, value: new Date(e4.data.getTime()) };
  }
  _addCheck(e4) {
    return new ZodDate({ ...this._def, checks: [...this._def.checks, e4] });
  }
  min(e4, t) {
    return this._addCheck({ kind: "min", value: e4.getTime(), message: errorUtil.toString(t) });
  }
  max(e4, t) {
    return this._addCheck({ kind: "max", value: e4.getTime(), message: errorUtil.toString(t) });
  }
  get minDate() {
    let e4 = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e4 === null || t.value > e4) && (e4 = t.value);
    return e4 != null ? new Date(e4) : null;
  }
  get maxDate() {
    let e4 = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e4 === null || t.value < e4) && (e4 = t.value);
    return e4 != null ? new Date(e4) : null;
  }
}

class ZodSymbol extends ZodType {
  _parse(e4) {
    if (this._getType(e4) !== ZodParsedType.symbol) {
      const t = this._getOrReturnCtx(e4);
      return addIssueToContext(t, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.symbol, received: t.parsedType }), INVALID;
    }
    return OK(e4.data);
  }
}

class ZodUndefined extends ZodType {
  _parse(e4) {
    if (this._getType(e4) !== ZodParsedType.undefined) {
      const t = this._getOrReturnCtx(e4);
      return addIssueToContext(t, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.undefined, received: t.parsedType }), INVALID;
    }
    return OK(e4.data);
  }
}

class ZodNull extends ZodType {
  _parse(e4) {
    if (this._getType(e4) !== ZodParsedType.null) {
      const t = this._getOrReturnCtx(e4);
      return addIssueToContext(t, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.null, received: t.parsedType }), INVALID;
    }
    return OK(e4.data);
  }
}

class ZodAny extends ZodType {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(e4) {
    return OK(e4.data);
  }
}

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(e4) {
    return OK(e4.data);
  }
}

class ZodNever extends ZodType {
  _parse(e4) {
    const t = this._getOrReturnCtx(e4);
    return addIssueToContext(t, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.never, received: t.parsedType }), INVALID;
  }
}

class ZodVoid extends ZodType {
  _parse(e4) {
    if (this._getType(e4) !== ZodParsedType.undefined) {
      const t = this._getOrReturnCtx(e4);
      return addIssueToContext(t, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.void, received: t.parsedType }), INVALID;
    }
    return OK(e4.data);
  }
}

class ZodArray extends ZodType {
  _parse(e4) {
    const { ctx: t, status: i } = this._processInputParams(e4), r = this._def;
    if (t.parsedType !== ZodParsedType.array)
      return addIssueToContext(t, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.array, received: t.parsedType }), INVALID;
    if (r.exactLength !== null) {
      const e5 = t.data.length > r.exactLength.value, n2 = t.data.length < r.exactLength.value;
      (e5 || n2) && (addIssueToContext(t, { code: e5 ? ZodIssueCode.too_big : ZodIssueCode.too_small, minimum: n2 ? r.exactLength.value : undefined, maximum: e5 ? r.exactLength.value : undefined, type: "array", inclusive: true, exact: true, message: r.exactLength.message }), i.dirty());
    }
    if (r.minLength !== null && t.data.length < r.minLength.value && (addIssueToContext(t, { code: ZodIssueCode.too_small, minimum: r.minLength.value, type: "array", inclusive: true, exact: false, message: r.minLength.message }), i.dirty()), r.maxLength !== null && t.data.length > r.maxLength.value && (addIssueToContext(t, { code: ZodIssueCode.too_big, maximum: r.maxLength.value, type: "array", inclusive: true, exact: false, message: r.maxLength.message }), i.dirty()), t.common.async)
      return Promise.all([...t.data].map((e5, i2) => r.type._parseAsync(new ParseInputLazyPath(t, e5, t.path, i2)))).then((e5) => ParseStatus.mergeArray(i, e5));
    const n = [...t.data].map((e5, i2) => r.type._parseSync(new ParseInputLazyPath(t, e5, t.path, i2)));
    return ParseStatus.mergeArray(i, n);
  }
  get element() {
    return this._def.type;
  }
  min(e4, t) {
    return new ZodArray({ ...this._def, minLength: { value: e4, message: errorUtil.toString(t) } });
  }
  max(e4, t) {
    return new ZodArray({ ...this._def, maxLength: { value: e4, message: errorUtil.toString(t) } });
  }
  length(e4, t) {
    return new ZodArray({ ...this._def, exactLength: { value: e4, message: errorUtil.toString(t) } });
  }
  nonempty(e4) {
    return this.min(1, e4);
  }
}

class ZodObject extends ZodType {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e4 = this._def.shape(), t = util$1.objectKeys(e4);
    return this._cached = { shape: e4, keys: t };
  }
  _parse(e4) {
    if (this._getType(e4) !== ZodParsedType.object) {
      const t2 = this._getOrReturnCtx(e4);
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.object, received: t2.parsedType }), INVALID;
    }
    const { status: t, ctx: i } = this._processInputParams(e4), { shape: r, keys: n } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip"))
      for (const e5 in i.data)
        n.includes(e5) || a.push(e5);
    const o = [];
    for (const e5 of n) {
      const t2 = r[e5], n2 = i.data[e5];
      o.push({ key: { status: "valid", value: e5 }, value: t2._parse(new ParseInputLazyPath(i, n2, i.path, e5)), alwaysSet: e5 in i.data });
    }
    if (this._def.catchall instanceof ZodNever) {
      const e5 = this._def.unknownKeys;
      if (e5 === "passthrough")
        for (const e6 of a)
          o.push({ key: { status: "valid", value: e6 }, value: { status: "valid", value: i.data[e6] } });
      else if (e5 === "strict")
        a.length > 0 && (addIssueToContext(i, { code: ZodIssueCode.unrecognized_keys, keys: a }), t.dirty());
      else if (e5 !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const e5 = this._def.catchall;
      for (const t2 of a) {
        const r2 = i.data[t2];
        o.push({ key: { status: "valid", value: t2 }, value: e5._parse(new ParseInputLazyPath(i, r2, i.path, t2)), alwaysSet: t2 in i.data });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const e5 = [];
      for (const t2 of o) {
        const i2 = await t2.key, r2 = await t2.value;
        e5.push({ key: i2, value: r2, alwaysSet: t2.alwaysSet });
      }
      return e5;
    }).then((e5) => ParseStatus.mergeObjectSync(t, e5)) : ParseStatus.mergeObjectSync(t, o);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e4) {
    return errorUtil.errToObj, new ZodObject({ ...this._def, unknownKeys: "strict", ...e4 !== undefined ? { errorMap: (t, i) => {
      var r, n, a, o;
      const s = (a = (n = (r = this._def).errorMap) === null || n === undefined ? undefined : n.call(r, t, i).message) !== null && a !== undefined ? a : i.defaultError;
      return t.code === "unrecognized_keys" ? { message: (o = errorUtil.errToObj(e4).message) !== null && o !== undefined ? o : s } : { message: s };
    } } : {} });
  }
  strip() {
    return new ZodObject({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new ZodObject({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(e4) {
    return new ZodObject({ ...this._def, shape: () => ({ ...this._def.shape(), ...e4 }) });
  }
  merge(e4) {
    return new ZodObject({ unknownKeys: e4._def.unknownKeys, catchall: e4._def.catchall, shape: () => ({ ...this._def.shape(), ...e4._def.shape() }), typeName: ZodFirstPartyTypeKind.ZodObject });
  }
  setKey(e4, t) {
    return this.augment({ [e4]: t });
  }
  catchall(e4) {
    return new ZodObject({ ...this._def, catchall: e4 });
  }
  pick(e4) {
    const t = {};
    return util$1.objectKeys(e4).forEach((i) => {
      e4[i] && this.shape[i] && (t[i] = this.shape[i]);
    }), new ZodObject({ ...this._def, shape: () => t });
  }
  omit(e4) {
    const t = {};
    return util$1.objectKeys(this.shape).forEach((i) => {
      e4[i] || (t[i] = this.shape[i]);
    }), new ZodObject({ ...this._def, shape: () => t });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(e4) {
    const t = {};
    return util$1.objectKeys(this.shape).forEach((i) => {
      const r = this.shape[i];
      e4 && !e4[i] ? t[i] = r : t[i] = r.optional();
    }), new ZodObject({ ...this._def, shape: () => t });
  }
  required(e4) {
    const t = {};
    return util$1.objectKeys(this.shape).forEach((i) => {
      if (e4 && !e4[i])
        t[i] = this.shape[i];
      else {
        let e5 = this.shape[i];
        for (;e5 instanceof ZodOptional; )
          e5 = e5._def.innerType;
        t[i] = e5;
      }
    }), new ZodObject({ ...this._def, shape: () => t });
  }
  keyof() {
    return createZodEnum(util$1.objectKeys(this.shape));
  }
}

class ZodUnion extends ZodType {
  _parse(e4) {
    const { ctx: t } = this._processInputParams(e4), i = this._def.options;
    if (t.common.async)
      return Promise.all(i.map(async (e5) => {
        const i2 = { ...t, common: { ...t.common, issues: [] }, parent: null };
        return { result: await e5._parseAsync({ data: t.data, path: t.path, parent: i2 }), ctx: i2 };
      })).then(function(e5) {
        for (const t2 of e5)
          if (t2.result.status === "valid")
            return t2.result;
        for (const i3 of e5)
          if (i3.result.status === "dirty")
            return t.common.issues.push(...i3.ctx.common.issues), i3.result;
        const i2 = e5.map((e6) => new ZodError(e6.ctx.common.issues));
        return addIssueToContext(t, { code: ZodIssueCode.invalid_union, unionErrors: i2 }), INVALID;
      });
    {
      let e5;
      const r = [];
      for (const n2 of i) {
        const i2 = { ...t, common: { ...t.common, issues: [] }, parent: null }, a = n2._parseSync({ data: t.data, path: t.path, parent: i2 });
        if (a.status === "valid")
          return a;
        a.status !== "dirty" || e5 || (e5 = { result: a, ctx: i2 }), i2.common.issues.length && r.push(i2.common.issues);
      }
      if (e5)
        return t.common.issues.push(...e5.ctx.common.issues), e5.result;
      const n = r.map((e6) => new ZodError(e6));
      return addIssueToContext(t, { code: ZodIssueCode.invalid_union, unionErrors: n }), INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}

class ZodDiscriminatedUnion extends ZodType {
  _parse(e4) {
    const { ctx: t } = this._processInputParams(e4);
    if (t.parsedType !== ZodParsedType.object)
      return addIssueToContext(t, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.object, received: t.parsedType }), INVALID;
    const i = this.discriminator, r = t.data[i], n = this.optionsMap.get(r);
    return n ? t.common.async ? n._parseAsync({ data: t.data, path: t.path, parent: t }) : n._parseSync({ data: t.data, path: t.path, parent: t }) : (addIssueToContext(t, { code: ZodIssueCode.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [i] }), INVALID);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(e4, t, i) {
    const r = new Map;
    for (const i2 of t) {
      const t2 = getDiscriminator(i2.shape[e4]);
      if (!t2.length)
        throw new Error(`A discriminator value for key \`${e4}\` could not be extracted from all schema options`);
      for (const n of t2) {
        if (r.has(n))
          throw new Error(`Discriminator property ${String(e4)} has duplicate value ${String(n)}`);
        r.set(n, i2);
      }
    }
    return new ZodDiscriminatedUnion({ typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion, discriminator: e4, options: t, optionsMap: r, ...processCreateParams(i) });
  }
}

class ZodIntersection extends ZodType {
  _parse(e4) {
    const { status: t, ctx: i } = this._processInputParams(e4), r = (e5, r2) => {
      if (isAborted(e5) || isAborted(r2))
        return INVALID;
      const n = mergeValues(e5.value, r2.value);
      return n.valid ? ((isDirty(e5) || isDirty(r2)) && t.dirty(), { status: t.value, value: n.data }) : (addIssueToContext(i, { code: ZodIssueCode.invalid_intersection_types }), INVALID);
    };
    return i.common.async ? Promise.all([this._def.left._parseAsync({ data: i.data, path: i.path, parent: i }), this._def.right._parseAsync({ data: i.data, path: i.path, parent: i })]).then(([e5, t2]) => r(e5, t2)) : r(this._def.left._parseSync({ data: i.data, path: i.path, parent: i }), this._def.right._parseSync({ data: i.data, path: i.path, parent: i }));
  }
}

class ZodTuple extends ZodType {
  _parse(e4) {
    const { status: t, ctx: i } = this._processInputParams(e4);
    if (i.parsedType !== ZodParsedType.array)
      return addIssueToContext(i, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.array, received: i.parsedType }), INVALID;
    if (i.data.length < this._def.items.length)
      return addIssueToContext(i, { code: ZodIssueCode.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), INVALID;
    !this._def.rest && i.data.length > this._def.items.length && (addIssueToContext(i, { code: ZodIssueCode.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), t.dirty());
    const r = [...i.data].map((e5, t2) => {
      const r2 = this._def.items[t2] || this._def.rest;
      return r2 ? r2._parse(new ParseInputLazyPath(i, e5, i.path, t2)) : null;
    }).filter((e5) => !!e5);
    return i.common.async ? Promise.all(r).then((e5) => ParseStatus.mergeArray(t, e5)) : ParseStatus.mergeArray(t, r);
  }
  get items() {
    return this._def.items;
  }
  rest(e4) {
    return new ZodTuple({ ...this._def, rest: e4 });
  }
}

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e4) {
    const { status: t, ctx: i } = this._processInputParams(e4);
    if (i.parsedType !== ZodParsedType.object)
      return addIssueToContext(i, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.object, received: i.parsedType }), INVALID;
    const r = [], n = this._def.keyType, a = this._def.valueType;
    for (const e5 in i.data)
      r.push({ key: n._parse(new ParseInputLazyPath(i, e5, i.path, e5)), value: a._parse(new ParseInputLazyPath(i, i.data[e5], i.path, e5)), alwaysSet: e5 in i.data });
    return i.common.async ? ParseStatus.mergeObjectAsync(t, r) : ParseStatus.mergeObjectSync(t, r);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e4, t, i) {
    return new ZodRecord(t instanceof ZodType ? { keyType: e4, valueType: t, typeName: ZodFirstPartyTypeKind.ZodRecord, ...processCreateParams(i) } : { keyType: ZodString.create(), valueType: e4, typeName: ZodFirstPartyTypeKind.ZodRecord, ...processCreateParams(t) });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e4) {
    const { status: t, ctx: i } = this._processInputParams(e4);
    if (i.parsedType !== ZodParsedType.map)
      return addIssueToContext(i, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.map, received: i.parsedType }), INVALID;
    const r = this._def.keyType, n = this._def.valueType, a = [...i.data.entries()].map(([e5, t2], a2) => ({ key: r._parse(new ParseInputLazyPath(i, e5, i.path, [a2, "key"])), value: n._parse(new ParseInputLazyPath(i, t2, i.path, [a2, "value"])) }));
    if (i.common.async) {
      const e5 = new Map;
      return Promise.resolve().then(async () => {
        for (const i2 of a) {
          const r2 = await i2.key, n2 = await i2.value;
          if (r2.status === "aborted" || n2.status === "aborted")
            return INVALID;
          r2.status !== "dirty" && n2.status !== "dirty" || t.dirty(), e5.set(r2.value, n2.value);
        }
        return { status: t.value, value: e5 };
      });
    }
    {
      const e5 = new Map;
      for (const i2 of a) {
        const { key: r2, value: n2 } = i2;
        if (r2.status === "aborted" || n2.status === "aborted")
          return INVALID;
        r2.status !== "dirty" && n2.status !== "dirty" || t.dirty(), e5.set(r2.value, n2.value);
      }
      return { status: t.value, value: e5 };
    }
  }
}

class ZodSet extends ZodType {
  _parse(e4) {
    const { status: t, ctx: i } = this._processInputParams(e4);
    if (i.parsedType !== ZodParsedType.set)
      return addIssueToContext(i, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.set, received: i.parsedType }), INVALID;
    const r = this._def;
    r.minSize !== null && i.data.size < r.minSize.value && (addIssueToContext(i, { code: ZodIssueCode.too_small, minimum: r.minSize.value, type: "set", inclusive: true, exact: false, message: r.minSize.message }), t.dirty()), r.maxSize !== null && i.data.size > r.maxSize.value && (addIssueToContext(i, { code: ZodIssueCode.too_big, maximum: r.maxSize.value, type: "set", inclusive: true, exact: false, message: r.maxSize.message }), t.dirty());
    const n = this._def.valueType;
    function a(e5) {
      const i2 = new Set;
      for (const r2 of e5) {
        if (r2.status === "aborted")
          return INVALID;
        r2.status === "dirty" && t.dirty(), i2.add(r2.value);
      }
      return { status: t.value, value: i2 };
    }
    const o = [...i.data.values()].map((e5, t2) => n._parse(new ParseInputLazyPath(i, e5, i.path, t2)));
    return i.common.async ? Promise.all(o).then((e5) => a(e5)) : a(o);
  }
  min(e4, t) {
    return new ZodSet({ ...this._def, minSize: { value: e4, message: errorUtil.toString(t) } });
  }
  max(e4, t) {
    return new ZodSet({ ...this._def, maxSize: { value: e4, message: errorUtil.toString(t) } });
  }
  size(e4, t) {
    return this.min(e4, t).max(e4, t);
  }
  nonempty(e4) {
    return this.min(1, e4);
  }
}

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e4) {
    const { ctx: t } = this._processInputParams(e4);
    if (t.parsedType !== ZodParsedType.function)
      return addIssueToContext(t, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.function, received: t.parsedType }), INVALID;
    function i(e5, i2) {
      return makeIssue({ data: e5, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, getErrorMap(), errorMap].filter((e6) => !!e6), issueData: { code: ZodIssueCode.invalid_arguments, argumentsError: i2 } });
    }
    function r(e5, i2) {
      return makeIssue({ data: e5, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, getErrorMap(), errorMap].filter((e6) => !!e6), issueData: { code: ZodIssueCode.invalid_return_type, returnTypeError: i2 } });
    }
    const n = { errorMap: t.common.contextualErrorMap }, a = t.data;
    if (this._def.returns instanceof ZodPromise) {
      const e5 = this;
      return OK(async function(...t2) {
        const o = new ZodError([]), s = await e5._def.args.parseAsync(t2, n).catch((e6) => {
          throw o.addIssue(i(t2, e6)), o;
        }), l = await Reflect.apply(a, this, s), u = await e5._def.returns._def.type.parseAsync(l, n).catch((e6) => {
          throw o.addIssue(r(l, e6)), o;
        });
        return u;
      });
    }
    {
      const e5 = this;
      return OK(function(...t2) {
        const o = e5._def.args.safeParse(t2, n);
        if (!o.success)
          throw new ZodError([i(t2, o.error)]);
        const s = Reflect.apply(a, this, o.data), l = e5._def.returns.safeParse(s, n);
        if (!l.success)
          throw new ZodError([r(s, l.error)]);
        return l.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e4) {
    return new ZodFunction({ ...this._def, args: ZodTuple.create(e4).rest(ZodUnknown.create()) });
  }
  returns(e4) {
    return new ZodFunction({ ...this._def, returns: e4 });
  }
  implement(e4) {
    return this.parse(e4);
  }
  strictImplement(e4) {
    return this.parse(e4);
  }
  static create(e4, t, i) {
    return new ZodFunction({ args: e4 || ZodTuple.create([]).rest(ZodUnknown.create()), returns: t || ZodUnknown.create(), typeName: ZodFirstPartyTypeKind.ZodFunction, ...processCreateParams(i) });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(e4) {
    const { ctx: t } = this._processInputParams(e4);
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
  }
}

class ZodLiteral extends ZodType {
  _parse(e4) {
    if (e4.data !== this._def.value) {
      const t = this._getOrReturnCtx(e4);
      return addIssueToContext(t, { received: t.data, code: ZodIssueCode.invalid_literal, expected: this._def.value }), INVALID;
    }
    return { status: "valid", value: e4.data };
  }
  get value() {
    return this._def.value;
  }
}

class ZodEnum extends ZodType {
  constructor() {
    super(...arguments), _ZodEnum_cache.set(this, undefined);
  }
  _parse(e4) {
    if (typeof e4.data != "string") {
      const t = this._getOrReturnCtx(e4), i = this._def.values;
      return addIssueToContext(t, { expected: util$1.joinValues(i), received: t.parsedType, code: ZodIssueCode.invalid_type }), INVALID;
    }
    if (__classPrivateFieldGet(this, _ZodEnum_cache) || __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values)), !__classPrivateFieldGet(this, _ZodEnum_cache).has(e4.data)) {
      const t = this._getOrReturnCtx(e4), i = this._def.values;
      return addIssueToContext(t, { received: t.data, code: ZodIssueCode.invalid_enum_value, options: i }), INVALID;
    }
    return OK(e4.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e4 = {};
    for (const t of this._def.values)
      e4[t] = t;
    return e4;
  }
  get Values() {
    const e4 = {};
    for (const t of this._def.values)
      e4[t] = t;
    return e4;
  }
  get Enum() {
    const e4 = {};
    for (const t of this._def.values)
      e4[t] = t;
    return e4;
  }
  extract(e4, t = this._def) {
    return ZodEnum.create(e4, { ...this._def, ...t });
  }
  exclude(e4, t = this._def) {
    return ZodEnum.create(this.options.filter((t2) => !e4.includes(t2)), { ...this._def, ...t });
  }
}

class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments), _ZodNativeEnum_cache.set(this, undefined);
  }
  _parse(e4) {
    const t = util$1.getValidEnumValues(this._def.values), i = this._getOrReturnCtx(e4);
    if (i.parsedType !== ZodParsedType.string && i.parsedType !== ZodParsedType.number) {
      const e5 = util$1.objectValues(t);
      return addIssueToContext(i, { expected: util$1.joinValues(e5), received: i.parsedType, code: ZodIssueCode.invalid_type }), INVALID;
    }
    if (__classPrivateFieldGet(this, _ZodNativeEnum_cache) || __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util$1.getValidEnumValues(this._def.values))), !__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(e4.data)) {
      const e5 = util$1.objectValues(t);
      return addIssueToContext(i, { received: i.data, code: ZodIssueCode.invalid_enum_value, options: e5 }), INVALID;
    }
    return OK(e4.data);
  }
  get enum() {
    return this._def.values;
  }
}

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(e4) {
    const { ctx: t } = this._processInputParams(e4);
    if (t.parsedType !== ZodParsedType.promise && t.common.async === false)
      return addIssueToContext(t, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.promise, received: t.parsedType }), INVALID;
    const i = t.parsedType === ZodParsedType.promise ? t.data : Promise.resolve(t.data);
    return OK(i.then((e5) => this._def.type.parseAsync(e5, { path: t.path, errorMap: t.common.contextualErrorMap })));
  }
}

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e4) {
    const { status: t, ctx: i } = this._processInputParams(e4), r = this._def.effect || null, n = { addIssue: (e5) => {
      addIssueToContext(i, e5), e5.fatal ? t.abort() : t.dirty();
    }, get path() {
      return i.path;
    } };
    if (n.addIssue = n.addIssue.bind(n), r.type === "preprocess") {
      const e5 = r.transform(i.data, n);
      if (i.common.async)
        return Promise.resolve(e5).then(async (e6) => {
          if (t.value === "aborted")
            return INVALID;
          const r2 = await this._def.schema._parseAsync({ data: e6, path: i.path, parent: i });
          return r2.status === "aborted" ? INVALID : r2.status === "dirty" || t.value === "dirty" ? DIRTY(r2.value) : r2;
        });
      {
        if (t.value === "aborted")
          return INVALID;
        const r2 = this._def.schema._parseSync({ data: e5, path: i.path, parent: i });
        return r2.status === "aborted" ? INVALID : r2.status === "dirty" || t.value === "dirty" ? DIRTY(r2.value) : r2;
      }
    }
    if (r.type === "refinement") {
      const e5 = (e6) => {
        const t2 = r.refinement(e6, n);
        if (i.common.async)
          return Promise.resolve(t2);
        if (t2 instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return e6;
      };
      if (i.common.async === false) {
        const r2 = this._def.schema._parseSync({ data: i.data, path: i.path, parent: i });
        return r2.status === "aborted" ? INVALID : (r2.status === "dirty" && t.dirty(), e5(r2.value), { status: t.value, value: r2.value });
      }
      return this._def.schema._parseAsync({ data: i.data, path: i.path, parent: i }).then((i2) => i2.status === "aborted" ? INVALID : (i2.status === "dirty" && t.dirty(), e5(i2.value).then(() => ({ status: t.value, value: i2.value }))));
    }
    if (r.type === "transform") {
      if (i.common.async === false) {
        const e5 = this._def.schema._parseSync({ data: i.data, path: i.path, parent: i });
        if (!isValid(e5))
          return e5;
        const a = r.transform(e5.value, n);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: t.value, value: a };
      }
      return this._def.schema._parseAsync({ data: i.data, path: i.path, parent: i }).then((e5) => isValid(e5) ? Promise.resolve(r.transform(e5.value, n)).then((e6) => ({ status: t.value, value: e6 })) : e5);
    }
    util$1.assertNever(r);
  }
}

class ZodOptional extends ZodType {
  _parse(e4) {
    return this._getType(e4) === ZodParsedType.undefined ? OK(undefined) : this._def.innerType._parse(e4);
  }
  unwrap() {
    return this._def.innerType;
  }
}

class ZodNullable extends ZodType {
  _parse(e4) {
    return this._getType(e4) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(e4);
  }
  unwrap() {
    return this._def.innerType;
  }
}

class ZodDefault extends ZodType {
  _parse(e4) {
    const { ctx: t } = this._processInputParams(e4);
    let i = t.data;
    return t.parsedType === ZodParsedType.undefined && (i = this._def.defaultValue()), this._def.innerType._parse({ data: i, path: t.path, parent: t });
  }
  removeDefault() {
    return this._def.innerType;
  }
}

class ZodCatch extends ZodType {
  _parse(e4) {
    const { ctx: t } = this._processInputParams(e4), i = { ...t, common: { ...t.common, issues: [] } }, r = this._def.innerType._parse({ data: i.data, path: i.path, parent: { ...i } });
    return isAsync(r) ? r.then((e5) => ({ status: "valid", value: e5.status === "valid" ? e5.value : this._def.catchValue({ get error() {
      return new ZodError(i.common.issues);
    }, input: i.data }) })) : { status: "valid", value: r.status === "valid" ? r.value : this._def.catchValue({ get error() {
      return new ZodError(i.common.issues);
    }, input: i.data }) };
  }
  removeCatch() {
    return this._def.innerType;
  }
}

class ZodNaN extends ZodType {
  _parse(e4) {
    if (this._getType(e4) !== ZodParsedType.nan) {
      const t = this._getOrReturnCtx(e4);
      return addIssueToContext(t, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.nan, received: t.parsedType }), INVALID;
    }
    return { status: "valid", value: e4.data };
  }
}

class ZodBranded extends ZodType {
  _parse(e4) {
    const { ctx: t } = this._processInputParams(e4), i = t.data;
    return this._def.type._parse({ data: i, path: t.path, parent: t });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(e4) {
    const { status: t, ctx: i } = this._processInputParams(e4);
    if (i.common.async) {
      return (async () => {
        const e5 = await this._def.in._parseAsync({ data: i.data, path: i.path, parent: i });
        return e5.status === "aborted" ? INVALID : e5.status === "dirty" ? (t.dirty(), DIRTY(e5.value)) : this._def.out._parseAsync({ data: e5.value, path: i.path, parent: i });
      })();
    }
    {
      const e5 = this._def.in._parseSync({ data: i.data, path: i.path, parent: i });
      return e5.status === "aborted" ? INVALID : e5.status === "dirty" ? (t.dirty(), { status: "dirty", value: e5.value }) : this._def.out._parseSync({ data: e5.value, path: i.path, parent: i });
    }
  }
  static create(e4, t) {
    return new ZodPipeline({ in: e4, out: t, typeName: ZodFirstPartyTypeKind.ZodPipeline });
  }
}

class ZodReadonly extends ZodType {
  _parse(e4) {
    const t = this._def.innerType._parse(e4), i = (e5) => (isValid(e5) && (e5.value = Object.freeze(e5.value)), e5);
    return isAsync(t) ? t.then((e5) => i(e5)) : i(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}

class Deferred {
  constructor() {
    this.resolve = () => null, this.reject = () => null, this.promise = new Promise((e4, t) => {
      this.reject = t, this.resolve = e4;
    });
  }
}

class AbstractTokenizer {
  constructor(e4) {
    this.position = 0, this.numBuffer = new Uint8Array(8), this.fileInfo = e4 || {};
  }
  async readToken(e4, t = this.position) {
    const i = Buffer2.alloc(e4.len);
    if (await this.readBuffer(i, { position: t }) < e4.len)
      throw new peek_readable_1$2.EndOfStreamError;
    return e4.get(i, 0);
  }
  async peekToken(e4, t = this.position) {
    const i = Buffer2.alloc(e4.len);
    if (await this.peekBuffer(i, { position: t }) < e4.len)
      throw new peek_readable_1$2.EndOfStreamError;
    return e4.get(i, 0);
  }
  async readNumber(e4) {
    if (await this.readBuffer(this.numBuffer, { length: e4.len }) < e4.len)
      throw new peek_readable_1$2.EndOfStreamError;
    return e4.get(this.numBuffer, 0);
  }
  async peekNumber(e4) {
    if (await this.peekBuffer(this.numBuffer, { length: e4.len }) < e4.len)
      throw new peek_readable_1$2.EndOfStreamError;
    return e4.get(this.numBuffer, 0);
  }
  async ignore(e4) {
    if (this.fileInfo.size !== undefined) {
      const t = this.fileInfo.size - this.position;
      if (e4 > t)
        return this.position += t, t;
    }
    return this.position += e4, e4;
  }
  async close() {
  }
  normalizeOptions(e4, t) {
    if (t && t.position !== undefined && t.position < this.position)
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    return t ? { mayBeLess: t.mayBeLess === true, offset: t.offset ? t.offset : 0, length: t.length ? t.length : e4.length - (t.offset ? t.offset : 0), position: t.position ? t.position : this.position } : { mayBeLess: false, offset: 0, length: e4.length, position: this.position };
  }
}

class ReadStreamTokenizer extends AbstractTokenizer_1$1.AbstractTokenizer {
  constructor(e4, t) {
    super(t), this.streamReader = new peek_readable_1$1.StreamReader(e4);
  }
  async getFileInfo() {
    return this.fileInfo;
  }
  async readBuffer(e4, t) {
    const i = this.normalizeOptions(e4, t), r = i.position - this.position;
    if (r > 0)
      return await this.ignore(r), this.readBuffer(e4, t);
    if (r < 0)
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    if (i.length === 0)
      return 0;
    const n = await this.streamReader.read(e4, i.offset, i.length);
    if (this.position += n, (!t || !t.mayBeLess) && n < i.length)
      throw new peek_readable_1$1.EndOfStreamError;
    return n;
  }
  async peekBuffer(e4, t) {
    const i = this.normalizeOptions(e4, t);
    let r = 0;
    if (i.position) {
      const t2 = i.position - this.position;
      if (t2 > 0) {
        const n = new Uint8Array(i.length + t2);
        return r = await this.peekBuffer(n, { mayBeLess: i.mayBeLess }), e4.set(n.subarray(t2), i.offset), r - t2;
      }
      if (t2 < 0)
        throw new Error("Cannot peek from a negative offset in a stream");
    }
    if (i.length > 0) {
      try {
        r = await this.streamReader.peek(e4, i.offset, i.length);
      } catch (e5) {
        if (t && t.mayBeLess && e5 instanceof peek_readable_1$1.EndOfStreamError)
          return 0;
        throw e5;
      }
      if (!i.mayBeLess && r < i.length)
        throw new peek_readable_1$1.EndOfStreamError;
    }
    return r;
  }
  async ignore(e4) {
    const t = Math.min(maxBufferSize, e4), i = new Uint8Array(t);
    let r = 0;
    for (;r < e4; ) {
      const n = e4 - r, a = await this.readBuffer(i, { length: Math.min(t, n) });
      if (a < 0)
        return a;
      r += a;
    }
    return r;
  }
}

class BufferTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
  constructor(e4, t) {
    super(t), this.uint8Array = e4, this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : e4.length;
  }
  async readBuffer(e4, t) {
    if (t && t.position) {
      if (t.position < this.position)
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      this.position = t.position;
    }
    const i = await this.peekBuffer(e4, t);
    return this.position += i, i;
  }
  async peekBuffer(e4, t) {
    const i = this.normalizeOptions(e4, t), r = Math.min(this.uint8Array.length - i.position, i.length);
    if (!i.mayBeLess && r < i.length)
      throw new peek_readable_1.EndOfStreamError;
    return e4.set(this.uint8Array.subarray(i.position, i.position + r), i.offset), r;
  }
  async close() {
  }
}

class ImagePHash {
  constructor(e4, t) {
    __publicField$1(this, "size"), __publicField$1(this, "smallerSize"), this.size = e4 || 32, this.smallerSize = t || 8, initCoefficients(this.size);
  }
  distance(e4, t) {
    let i = 0;
    for (let r = 0;r < e4.length; r++)
      e4[r] !== t[r] && i++;
    return i / e4.length;
  }
  getHash(e4) {
    e4 = methods$d.resize(clone(e4), { w: this.size, h: this.size }), e4 = methods$e.greyscale(e4);
    const t = [];
    for (let i2 = 0;i2 < e4.bitmap.width; i2++) {
      const r2 = [];
      for (let t2 = 0;t2 < e4.bitmap.height; t2++)
        r2[t2] = intToRGBA(e4.getPixelColor(i2, t2)).b;
      t[i2] = r2;
    }
    const i = applyDCT(t, this.size);
    let r = 0;
    for (let e5 = 0;e5 < this.smallerSize; e5++)
      for (let t2 = 0;t2 < this.smallerSize; t2++)
        r += i[e5][t2];
    const n = r / (this.smallerSize * this.smallerSize);
    let a = "";
    for (let e5 = 0;e5 < this.smallerSize; e5++)
      for (let t2 = 0;t2 < this.smallerSize; t2++)
        a += i[e5][t2] > n ? "1" : "0";
    return a;
  }
}
var getDefaultExportFromCjs, getAugmentedNamespace, init, toByteArray, tripletToBase64, encodeChunk, fromByteArray, read, write, kMaxLength, createBuffer, Buffer2, from, assertSize, alloc, allocUnsafe, fromString, fromArrayLike, fromArrayBuffer, fromObject, checked, internalIsBuffer, byteLength, slowToString, swap, bidirectionalIndexOf, arrayIndexOf, hexWrite, utf8Write, asciiWrite, latin1Write, base64Write, ucs2Write, base64Slice, utf8Slice, decodeCodePointsArray, asciiSlice, latin1Slice, hexSlice, utf16leSlice, checkOffset, checkInt, objectWriteUInt16, objectWriteUInt32, checkIEEE754, writeFloat, writeDouble, base64clean, stringtrim, toHex, utf8ToBytes, asciiToBytes, utf16leToBytes, base64ToBytes, blitBuffer, isnan, isBuffer, isFastBuffer, isSlowBuffer, maskColor, createInteger, createColor, decode$2, encode$2, _typeof, tinycolor, inputToRGB, rgbToRgb, rgbToHsl, hslToRgb, rgbToHsv, hsvToRgb, rgbToHex, rgbaToHex, rgbaToArgbHex, _desaturate, _saturate, _greyscale, _lighten, _brighten, _darken, _spin, _complement, polyad, _splitcomplement, _analogous, _monochromatic, flip, boundAlpha, bound01, clamp01, parseIntFromHex, isOnePointZero, isPercentage, pad2, convertToPercentage, convertDecimalToHex, convertHexToDecimal, isValidCSSUnit, stringInputToObject, validateWCAG2Parms, clone, scan, intToRGBA$1, rgbaToInt, colorDiff, limit255, cssColorToHex, encode$1, decode$1, msBmp, bmp, GifWriter, GifWriterOutputLZWCodeStream, GifReader, GifReaderLZWOutputIndexStream, correctGamma$1, rgb2xyz$1, degrees2radians$1, max3$1, min3$1, intInRange$1, inRange0to255Rounded$1, inRange0to255$1, stableSort$1, rgb2hsl$1, pivot$1, xyz2lab$1, rgb2lab$1, pivot2$1, lab2xyz$1, correctGamma2$1, xyz2rgb$1, lab2rgb$1, hueGroup$1, createArray1D$1, createArray4D$1, createArray3D$1, fillArray3D$1, fillArray1D$1, visit$1, ssim$1, iterate$1, calculateLumaValuesForWindow$1, calculateAverageLuma$1, buildPaletteSync$1, applyPaletteSync$1, colorDistanceFormulaToColorDistance$1, imageQuantizationToImageQuantizer$1, paletteQuantizationToPaletteQuantizer$1, requireGifutil, requireGifcodec, gif, jpeg$2, commonjsRequire, png, requireCommon, requireTrees, requireAdler32, requireCrc32, requireMessages, requireDeflate$1, requireStrings, requireZstream, requireDeflate, requireInffast, requireInftrees, requireInflate$1, requireConstants, requireGzheader, requireInflate, requirePako, getDimensionValue, tiff, setErrorMap, getErrorMap, addIssueToContext, __classPrivateFieldGet, __classPrivateFieldSet, processCreateParams, timeRegexSource, timeRegex, datetimeRegex, isValidIP, floatSafeRemainder, deepPartialify, mergeValues, createZodEnum, custom, applyKernel, mix, histogram, _check, commonjsGlobal, global$1, lookup, revLookup, Arr, inited, toString, isArray, INSPECT_MAX_BYTES, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE, HeaderTypes, HeaderTypes$1, BmpCompression, trimLeft, trimRight, names$1, hexNames, matchers, CSS_UNIT, PERMISSIVE_MATCH3, PERMISSIVE_MATCH4, omggif, GifReader_1, GifWriter_1, BitmapImage$2, bitmapimage, gif$1, Gif$1, GifError$2, gifcodec, gifutil, _polyfillNode_fs, _polyfillNode_fs$1, require$$0, __defProp$3, __getOwnPropDesc2, __getOwnPropNames2, __hasOwnProp2, __defNormalProp$3, __markAsModule, __export$1, __reExport, __toCommonJS2, __publicField$3, src_exports, constants_exports$1, bt709_exports$1, Y$1, x$2, y$2, conversion_exports$1, arithmetic_exports$1, refX$1, refY$1, refZ$1, refX2$1, refY2$1, refZ2$1, distance_exports$1, AbstractDistanceCalculator$1, AbstractCIE94$1, CIE94Textiles$1, CIE94GraphicArts$1, _CIEDE2000$1, CIEDE2000$1, CMetric$1, AbstractEuclidean$1, Euclidean$1, EuclideanBT709$1, EuclideanBT709NoAlpha$1, AbstractManhattan$1, Manhattan$1, ManhattanNommyde$1, ManhattanBT709$1, PNGQuant$1, palette_exports$1, AbstractPaletteQuantizer$1, Point$1, PointContainer$1, hueGroups$1, Palette$1, utils_exports$1, HueGroup$1, HueStatistics$1, _ProgressTracker$1, ProgressTracker$1, networkBiasShift$1, Neuron$1, _NeuQuant$1, NeuQuant$1, networkBiasShift2$1, NeuronFloat$1, _NeuQuantFloat$1, NeuQuantFloat$1, _ColorHistogram$1, ColorHistogram$1, RemovedColor$1, RGBQuant$1, WuColorCube$1, _WuQuant$1, WuQuant$1, image_exports$1, AbstractImageQuantizer$1, NearestColor$1, ErrorDiffusionArrayKernel$1, ErrorDiffusionArray$1, ErrorDiffusionRiemersma$1, quality_exports$1, K1$1, K2$1, setImmediateImpl, imageQ, gifframe, BitmapImage$1, GifFrame$1, hasRequiredGifutil, hasRequiredGifcodec, BitmapImage, Gif, GifError$1, GifCodec, GifFrame, GifUtil, src, encoder, encoderExports, decoder, module, JpegImage, decoderExports, encode, decode, jpegJs, JPEG, browser$1, browserExports, PNGFilterType, PNGFilterType2, PNGColorType, PNGColorType2, UTIF, common, hasRequiredCommon, deflate$1, deflate, trees, hasRequiredTrees, adler32_1, hasRequiredAdler32, crc32_1, hasRequiredCrc32, messages, hasRequiredMessages, hasRequiredDeflate$1, strings, hasRequiredStrings, zstream, hasRequiredZstream, hasRequiredDeflate, inflate$1, inflate, inffast, hasRequiredInffast, inftrees, hasRequiredInftrees, hasRequiredInflate$1, constants, hasRequiredConstants, gzheader, hasRequiredGzheader, hasRequiredInflate, pako_1, hasRequiredPako, UTIFExports, utif, util$1, objectUtil, ZodParsedType, getParsedType, ZodIssueCode, quotelessJson, errorMap, overrideErrorMap, makeIssue, EMPTY_PATH, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, errorUtil, _ZodEnum_cache, _ZodNativeEnum_cache, handleResult, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv6Regex, base64Regex, dateRegexSource, dateRegex, getDiscriminator, BRAND, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER, z, Edge, Edge2, JimpClassSchema, BlitOptionsSchemaComplex, BlitOptionsSchema, methods$h, mulTable, shgTable, methods$g, CircleOptionsSchema, methods$f, ConvolutionMatrixSchema, ConvolutionComplexOptionsSchema, ConvolutionOptionsSchema, ConvoluteComplexOptionsSchema, ConvoluteOptionsSchema, PixelateSize, PixelateComplexOptionsSchema, PixelateOptionsSchema, HueActionSchema, SpinActionSchema, LightenActionSchema, RGBColorSchema, MixActionSchema, TintActionSchema, ShadeActionSchema, XorActionSchema, RedActionSchema, GreenActionSchema, BlueActionSchema, BrightenActionSchema, DarkenActionSchema, DesaturateActionSchema, SaturateActionSchema, GrayscaleActionSchema, ColorActionNameSchema, normalizeValue, getBounds, methods$e, lib$1, ieee754, core$1, ReadStreamTokenizer$1, AbstractTokenizer$1, lib, EndOfFileStream, StreamReader, Deferred$1, peek_readable_1$2, AbstractTokenizer_1$1, peek_readable_1$1, maxBufferSize, BufferTokenizer$1, peek_readable_1, AbstractTokenizer_1, util, supported$1, Token, strtok3, stringToBytes, tarHeaderChecksumMatches, uint32SyncSafeToken, supported, minimumBytes, stream2, fileType, core, fileType$1, writeFile, Mime_1, standard, Mime, lite, mime, HorizontalAlign, HorizontalAlign2, VerticalAlign, VerticalAlign2, BlendMode, BlendMode2, names, compositeModes, jpeg$1, exif$2, hours, minutes, date$1, exif$1, date, degreeTags, dateTags, simplify$1, exifTags, hasRequiredExifTags, jpeg, exif, simplify, parser, domBufferstream, hasRequiredDomBufferstream, bufferstream, hasRequiredBufferstream, Parser, exifParser, EXIFParser, __defProp$2, __defNormalProp$2, __publicField$2, emptyBitmap, ResizeStrategy, ResizeStrategy2, operations, ResizeOptionsSchema, ScaleToFitOptionsSchema, ScaleComplexOptionsSchema, methods$d, ContainOptionsSchema, methods$c, CropOptionsSchema, AutocropComplexOptionsSchema, methods$b, CoverOptionsSchema, methods$a, DisplaceOptionsSchema, methods$9, methods$8, FisheyeOptionsSchema, methods$7, FlipOptionsSchema, methods$6, converter, Converter, anyBase_1, anyBase$1, __defProp$1, __defNormalProp$1, __publicField$1, c$1, alphabet, maxHashLength, methods$5, MaskOptionsObjectSchema, MaskOptionsSchema, methods$4, PrintOptionsSchema, methods$3, RotateOptionsSchema, methods$2, ThresholdOptionsSchema, methods$1, __defProp2, __defNormalProp, __export2, __publicField, constants_exports, bt709_exports, Y, x$1, y$1, conversion_exports, arithmetic_exports, refX, refY, refZ, refX2, refY2, refZ2, distance_exports, AbstractDistanceCalculator, AbstractCIE94, CIE94Textiles, CIE94GraphicArts, _CIEDE2000, CIEDE2000, CMetric, AbstractEuclidean, Euclidean, EuclideanBT709, EuclideanBT709NoAlpha, AbstractManhattan, Manhattan, ManhattanNommyde, ManhattanBT709, PNGQuant, palette_exports, AbstractPaletteQuantizer, Point, PointContainer, hueGroups, Palette, utils_exports, HueGroup, HueStatistics, _ProgressTracker, ProgressTracker, networkBiasShift, Neuron, _NeuQuant, NeuQuant, networkBiasShift2, NeuronFloat, _NeuQuantFloat, NeuQuantFloat, _ColorHistogram, ColorHistogram, RemovedColor, RGBQuant, WuColorCube, _WuQuant, WuQuant, image_exports, AbstractImageQuantizer, NearestColor, ErrorDiffusionArrayKernel, ErrorDiffusionArray, ErrorDiffusionRiemersma, quality_exports, K1, K2, QuantizeOptionsSchema, methods, parseBmfontAscii, parseASCII, GLYPH_DESIGNER_ERROR, parseAttribs, xmlParseFromString, parseAttributes, parseFromString, NAME_MAP, browser, parseXML, HEADER$1, parseBmfontBinary, readBinary, splitPathRe, splitPath, sep, delimiter, path, substr, t, r, n, E, s, a, T, u, c, l, o, N, i, p, O, A, f, C, h, _, L, y, v, S, R, B, M, x, k, simpleXmlToJson_min, xmlPackage, convertXML, isWebWorker, CharacterJimp, HEADER, pixelmatch_1, defaultOptions, pixelMatch, defaultPlugins, defaultFormats, JimpMime, Jimp;
var init_browser = __esm(() => {
  getDefaultExportFromCjs = function(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
  };
  getAugmentedNamespace = function(e) {
    if (e.__esModule)
      return e;
    var t = e.default;
    if (typeof t == "function") {
      var i = function e() {
        return this instanceof e ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
      };
      i.prototype = t.prototype;
    } else
      i = {};
    return Object.defineProperty(i, "__esModule", { value: true }), Object.keys(e).forEach(function(t2) {
      var r = Object.getOwnPropertyDescriptor(e, t2);
      Object.defineProperty(i, t2, r.get ? r : { enumerable: true, get: function() {
        return e[t2];
      } });
    }), i;
  };
  init = function() {
    inited = true;
    for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0;t < 64; ++t)
      lookup[t] = e[t], revLookup[e.charCodeAt(t)] = t;
    revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
  };
  toByteArray = function(e) {
    var t, i, r, n, a, o;
    inited || init();
    var s = e.length;
    if (s % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    a = e[s - 2] === "=" ? 2 : e[s - 1] === "=" ? 1 : 0, o = new Arr(3 * s / 4 - a), r = a > 0 ? s - 4 : s;
    var l = 0;
    for (t = 0, i = 0;t < r; t += 4, i += 3)
      n = revLookup[e.charCodeAt(t)] << 18 | revLookup[e.charCodeAt(t + 1)] << 12 | revLookup[e.charCodeAt(t + 2)] << 6 | revLookup[e.charCodeAt(t + 3)], o[l++] = n >> 16 & 255, o[l++] = n >> 8 & 255, o[l++] = 255 & n;
    return a === 2 ? (n = revLookup[e.charCodeAt(t)] << 2 | revLookup[e.charCodeAt(t + 1)] >> 4, o[l++] = 255 & n) : a === 1 && (n = revLookup[e.charCodeAt(t)] << 10 | revLookup[e.charCodeAt(t + 1)] << 4 | revLookup[e.charCodeAt(t + 2)] >> 2, o[l++] = n >> 8 & 255, o[l++] = 255 & n), o;
  };
  tripletToBase64 = function(e) {
    return lookup[e >> 18 & 63] + lookup[e >> 12 & 63] + lookup[e >> 6 & 63] + lookup[63 & e];
  };
  encodeChunk = function(e, t, i) {
    for (var r, n = [], a = t;a < i; a += 3)
      r = (e[a] << 16) + (e[a + 1] << 8) + e[a + 2], n.push(tripletToBase64(r));
    return n.join("");
  };
  fromByteArray = function(e) {
    var t;
    inited || init();
    for (var i = e.length, r = i % 3, n = "", a = [], o = 16383, s = 0, l = i - r;s < l; s += o)
      a.push(encodeChunk(e, s, s + o > l ? l : s + o));
    return r === 1 ? (t = e[i - 1], n += lookup[t >> 2], n += lookup[t << 4 & 63], n += "==") : r === 2 && (t = (e[i - 2] << 8) + e[i - 1], n += lookup[t >> 10], n += lookup[t >> 4 & 63], n += lookup[t << 2 & 63], n += "="), a.push(n), a.join("");
  };
  read = function(e, t, i, r, n) {
    var a, o, s = 8 * n - r - 1, l = (1 << s) - 1, u = l >> 1, h = -7, c = i ? n - 1 : 0, f = i ? -1 : 1, d = e[t + c];
    for (c += f, a = d & (1 << -h) - 1, d >>= -h, h += s;h > 0; a = 256 * a + e[t + c], c += f, h -= 8)
      ;
    for (o = a & (1 << -h) - 1, a >>= -h, h += r;h > 0; o = 256 * o + e[t + c], c += f, h -= 8)
      ;
    if (a === 0)
      a = 1 - u;
    else {
      if (a === l)
        return o ? NaN : 1 / 0 * (d ? -1 : 1);
      o += Math.pow(2, r), a -= u;
    }
    return (d ? -1 : 1) * o * Math.pow(2, a - r);
  };
  write = function(e, t, i, r, n, a) {
    var o, s, l, u = 8 * a - n - 1, h = (1 << u) - 1, c = h >> 1, f = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : a - 1, p = r ? 1 : -1, m = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
    for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, o = h) : (o = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), (t += o + c >= 1 ? f / l : f * Math.pow(2, 1 - c)) * l >= 2 && (o++, l /= 2), o + c >= h ? (s = 0, o = h) : o + c >= 1 ? (s = (t * l - 1) * Math.pow(2, n), o += c) : (s = t * Math.pow(2, c - 1) * Math.pow(2, n), o = 0));n >= 8; e[i + d] = 255 & s, d += p, s /= 256, n -= 8)
      ;
    for (o = o << n | s, u += n;u > 0; e[i + d] = 255 & o, d += p, o /= 256, u -= 8)
      ;
    e[i + d - p] |= 128 * m;
  };
  kMaxLength = function() {
    return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  };
  createBuffer = function(e, t) {
    if (kMaxLength() < t)
      throw new RangeError("Invalid typed array length");
    return Buffer2.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = Buffer2.prototype : (e === null && (e = new Buffer2(t)), e.length = t), e;
  };
  Buffer2 = function(e, t, i) {
    if (!(Buffer2.TYPED_ARRAY_SUPPORT || this instanceof Buffer2))
      return new Buffer2(e, t, i);
    if (typeof e == "number") {
      if (typeof t == "string")
        throw new Error("If encoding is specified then the first argument must be a string");
      return allocUnsafe(this, e);
    }
    return from(this, e, t, i);
  };
  from = function(e, t, i, r) {
    if (typeof t == "number")
      throw new TypeError('"value" argument must not be a number');
    return typeof ArrayBuffer != "undefined" && t instanceof ArrayBuffer ? fromArrayBuffer(e, t, i, r) : typeof t == "string" ? fromString(e, t, i) : fromObject(e, t);
  };
  assertSize = function(e) {
    if (typeof e != "number")
      throw new TypeError('"size" argument must be a number');
    if (e < 0)
      throw new RangeError('"size" argument must not be negative');
  };
  alloc = function(e, t, i, r) {
    return assertSize(t), t <= 0 ? createBuffer(e, t) : i !== undefined ? typeof r == "string" ? createBuffer(e, t).fill(i, r) : createBuffer(e, t).fill(i) : createBuffer(e, t);
  };
  allocUnsafe = function(e, t) {
    if (assertSize(t), e = createBuffer(e, t < 0 ? 0 : 0 | checked(t)), !Buffer2.TYPED_ARRAY_SUPPORT)
      for (var i = 0;i < t; ++i)
        e[i] = 0;
    return e;
  };
  fromString = function(e, t, i) {
    if (typeof i == "string" && i !== "" || (i = "utf8"), !Buffer2.isEncoding(i))
      throw new TypeError('"encoding" must be a valid string encoding');
    var r = 0 | byteLength(t, i), n = (e = createBuffer(e, r)).write(t, i);
    return n !== r && (e = e.slice(0, n)), e;
  };
  fromArrayLike = function(e, t) {
    var i = t.length < 0 ? 0 : 0 | checked(t.length);
    e = createBuffer(e, i);
    for (var r = 0;r < i; r += 1)
      e[r] = 255 & t[r];
    return e;
  };
  fromArrayBuffer = function(e, t, i, r) {
    if (t.byteLength, i < 0 || t.byteLength < i)
      throw new RangeError("'offset' is out of bounds");
    if (t.byteLength < i + (r || 0))
      throw new RangeError("'length' is out of bounds");
    return t = i === undefined && r === undefined ? new Uint8Array(t) : r === undefined ? new Uint8Array(t, i) : new Uint8Array(t, i, r), Buffer2.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = Buffer2.prototype : e = fromArrayLike(e, t), e;
  };
  fromObject = function(e, t) {
    if (internalIsBuffer(t)) {
      var i = 0 | checked(t.length);
      return (e = createBuffer(e, i)).length === 0 || t.copy(e, 0, 0, i), e;
    }
    if (t) {
      if (typeof ArrayBuffer != "undefined" && t.buffer instanceof ArrayBuffer || "length" in t)
        return typeof t.length != "number" || isnan(t.length) ? createBuffer(e, 0) : fromArrayLike(e, t);
      if (t.type === "Buffer" && isArray(t.data))
        return fromArrayLike(e, t.data);
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  };
  checked = function(e) {
    if (e >= kMaxLength())
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
    return 0 | e;
  };
  internalIsBuffer = function(e) {
    return !(e == null || !e._isBuffer);
  };
  byteLength = function(e, t) {
    if (internalIsBuffer(e))
      return e.length;
    if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer))
      return e.byteLength;
    typeof e != "string" && (e = "" + e);
    var i = e.length;
    if (i === 0)
      return 0;
    for (var r = false;; )
      switch (t) {
        case "ascii":
        case "latin1":
        case "binary":
          return i;
        case "utf8":
        case "utf-8":
        case undefined:
          return utf8ToBytes(e).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * i;
        case "hex":
          return i >>> 1;
        case "base64":
          return base64ToBytes(e).length;
        default:
          if (r)
            return utf8ToBytes(e).length;
          t = ("" + t).toLowerCase(), r = true;
      }
  };
  slowToString = function(e, t, i) {
    var r = false;
    if ((t === undefined || t < 0) && (t = 0), t > this.length)
      return "";
    if ((i === undefined || i > this.length) && (i = this.length), i <= 0)
      return "";
    if ((i >>>= 0) <= (t >>>= 0))
      return "";
    for (e || (e = "utf8");; )
      switch (e) {
        case "hex":
          return hexSlice(this, t, i);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, t, i);
        case "ascii":
          return asciiSlice(this, t, i);
        case "latin1":
        case "binary":
          return latin1Slice(this, t, i);
        case "base64":
          return base64Slice(this, t, i);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, t, i);
        default:
          if (r)
            throw new TypeError("Unknown encoding: " + e);
          e = (e + "").toLowerCase(), r = true;
      }
  };
  swap = function(e, t, i) {
    var r = e[t];
    e[t] = e[i], e[i] = r;
  };
  bidirectionalIndexOf = function(e, t, i, r, n) {
    if (e.length === 0)
      return -1;
    if (typeof i == "string" ? (r = i, i = 0) : i > 2147483647 ? i = 2147483647 : i < -2147483648 && (i = -2147483648), i = +i, isNaN(i) && (i = n ? 0 : e.length - 1), i < 0 && (i = e.length + i), i >= e.length) {
      if (n)
        return -1;
      i = e.length - 1;
    } else if (i < 0) {
      if (!n)
        return -1;
      i = 0;
    }
    if (typeof t == "string" && (t = Buffer2.from(t, r)), internalIsBuffer(t))
      return t.length === 0 ? -1 : arrayIndexOf(e, t, i, r, n);
    if (typeof t == "number")
      return t &= 255, Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(e, t, i) : Uint8Array.prototype.lastIndexOf.call(e, t, i) : arrayIndexOf(e, [t], i, r, n);
    throw new TypeError("val must be string, number or Buffer");
  };
  arrayIndexOf = function(e, t, i, r, n) {
    var a, o = 1, s = e.length, l = t.length;
    if (r !== undefined && ((r = String(r).toLowerCase()) === "ucs2" || r === "ucs-2" || r === "utf16le" || r === "utf-16le")) {
      if (e.length < 2 || t.length < 2)
        return -1;
      o = 2, s /= 2, l /= 2, i /= 2;
    }
    function u(e2, t2) {
      return o === 1 ? e2[t2] : e2.readUInt16BE(t2 * o);
    }
    if (n) {
      var h = -1;
      for (a = i;a < s; a++)
        if (u(e, a) === u(t, h === -1 ? 0 : a - h)) {
          if (h === -1 && (h = a), a - h + 1 === l)
            return h * o;
        } else
          h !== -1 && (a -= a - h), h = -1;
    } else
      for (i + l > s && (i = s - l), a = i;a >= 0; a--) {
        for (var c = true, f = 0;f < l; f++)
          if (u(e, a + f) !== u(t, f)) {
            c = false;
            break;
          }
        if (c)
          return a;
      }
    return -1;
  };
  hexWrite = function(e, t, i, r) {
    i = Number(i) || 0;
    var n = e.length - i;
    r ? (r = Number(r)) > n && (r = n) : r = n;
    var a = t.length;
    if (a % 2 != 0)
      throw new TypeError("Invalid hex string");
    r > a / 2 && (r = a / 2);
    for (var o = 0;o < r; ++o) {
      var s = parseInt(t.substr(2 * o, 2), 16);
      if (isNaN(s))
        return o;
      e[i + o] = s;
    }
    return o;
  };
  utf8Write = function(e, t, i, r) {
    return blitBuffer(utf8ToBytes(t, e.length - i), e, i, r);
  };
  asciiWrite = function(e, t, i, r) {
    return blitBuffer(asciiToBytes(t), e, i, r);
  };
  latin1Write = function(e, t, i, r) {
    return asciiWrite(e, t, i, r);
  };
  base64Write = function(e, t, i, r) {
    return blitBuffer(base64ToBytes(t), e, i, r);
  };
  ucs2Write = function(e, t, i, r) {
    return blitBuffer(utf16leToBytes(t, e.length - i), e, i, r);
  };
  base64Slice = function(e, t, i) {
    return t === 0 && i === e.length ? fromByteArray(e) : fromByteArray(e.slice(t, i));
  };
  utf8Slice = function(e, t, i) {
    i = Math.min(e.length, i);
    for (var r = [], n = t;n < i; ) {
      var a, o, s, l, u = e[n], h = null, c = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
      if (n + c <= i)
        switch (c) {
          case 1:
            u < 128 && (h = u);
            break;
          case 2:
            (192 & (a = e[n + 1])) == 128 && (l = (31 & u) << 6 | 63 & a) > 127 && (h = l);
            break;
          case 3:
            a = e[n + 1], o = e[n + 2], (192 & a) == 128 && (192 & o) == 128 && (l = (15 & u) << 12 | (63 & a) << 6 | 63 & o) > 2047 && (l < 55296 || l > 57343) && (h = l);
            break;
          case 4:
            a = e[n + 1], o = e[n + 2], s = e[n + 3], (192 & a) == 128 && (192 & o) == 128 && (192 & s) == 128 && (l = (15 & u) << 18 | (63 & a) << 12 | (63 & o) << 6 | 63 & s) > 65535 && l < 1114112 && (h = l);
        }
      h === null ? (h = 65533, c = 1) : h > 65535 && (h -= 65536, r.push(h >>> 10 & 1023 | 55296), h = 56320 | 1023 & h), r.push(h), n += c;
    }
    return decodeCodePointsArray(r);
  };
  decodeCodePointsArray = function(e) {
    var t = e.length;
    if (t <= MAX_ARGUMENTS_LENGTH)
      return String.fromCharCode.apply(String, e);
    for (var i = "", r = 0;r < t; )
      i += String.fromCharCode.apply(String, e.slice(r, r += MAX_ARGUMENTS_LENGTH));
    return i;
  };
  asciiSlice = function(e, t, i) {
    var r = "";
    i = Math.min(e.length, i);
    for (var n = t;n < i; ++n)
      r += String.fromCharCode(127 & e[n]);
    return r;
  };
  latin1Slice = function(e, t, i) {
    var r = "";
    i = Math.min(e.length, i);
    for (var n = t;n < i; ++n)
      r += String.fromCharCode(e[n]);
    return r;
  };
  hexSlice = function(e, t, i) {
    var r = e.length;
    (!t || t < 0) && (t = 0), (!i || i < 0 || i > r) && (i = r);
    for (var n = "", a = t;a < i; ++a)
      n += toHex(e[a]);
    return n;
  };
  utf16leSlice = function(e, t, i) {
    for (var r = e.slice(t, i), n = "", a = 0;a < r.length; a += 2)
      n += String.fromCharCode(r[a] + 256 * r[a + 1]);
    return n;
  };
  checkOffset = function(e, t, i) {
    if (e % 1 != 0 || e < 0)
      throw new RangeError("offset is not uint");
    if (e + t > i)
      throw new RangeError("Trying to access beyond buffer length");
  };
  checkInt = function(e, t, i, r, n, a) {
    if (!internalIsBuffer(e))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t > n || t < a)
      throw new RangeError('"value" argument is out of bounds');
    if (i + r > e.length)
      throw new RangeError("Index out of range");
  };
  objectWriteUInt16 = function(e, t, i, r) {
    t < 0 && (t = 65535 + t + 1);
    for (var n = 0, a = Math.min(e.length - i, 2);n < a; ++n)
      e[i + n] = (t & 255 << 8 * (r ? n : 1 - n)) >>> 8 * (r ? n : 1 - n);
  };
  objectWriteUInt32 = function(e, t, i, r) {
    t < 0 && (t = 4294967295 + t + 1);
    for (var n = 0, a = Math.min(e.length - i, 4);n < a; ++n)
      e[i + n] = t >>> 8 * (r ? n : 3 - n) & 255;
  };
  checkIEEE754 = function(e, t, i, r, n, a) {
    if (i + r > e.length)
      throw new RangeError("Index out of range");
    if (i < 0)
      throw new RangeError("Index out of range");
  };
  writeFloat = function(e, t, i, r, n) {
    return n || checkIEEE754(e, t, i, 4), write(e, t, i, r, 23, 4), i + 4;
  };
  writeDouble = function(e, t, i, r, n) {
    return n || checkIEEE754(e, t, i, 8), write(e, t, i, r, 52, 8), i + 8;
  };
  base64clean = function(e) {
    if ((e = stringtrim(e).replace(INVALID_BASE64_RE, "")).length < 2)
      return "";
    for (;e.length % 4 != 0; )
      e += "=";
    return e;
  };
  stringtrim = function(e) {
    return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "");
  };
  toHex = function(e) {
    return e < 16 ? "0" + e.toString(16) : e.toString(16);
  };
  utf8ToBytes = function(e, t) {
    var i;
    t = t || 1 / 0;
    for (var r = e.length, n = null, a = [], o = 0;o < r; ++o) {
      if ((i = e.charCodeAt(o)) > 55295 && i < 57344) {
        if (!n) {
          if (i > 56319) {
            (t -= 3) > -1 && a.push(239, 191, 189);
            continue;
          }
          if (o + 1 === r) {
            (t -= 3) > -1 && a.push(239, 191, 189);
            continue;
          }
          n = i;
          continue;
        }
        if (i < 56320) {
          (t -= 3) > -1 && a.push(239, 191, 189), n = i;
          continue;
        }
        i = 65536 + (n - 55296 << 10 | i - 56320);
      } else
        n && (t -= 3) > -1 && a.push(239, 191, 189);
      if (n = null, i < 128) {
        if ((t -= 1) < 0)
          break;
        a.push(i);
      } else if (i < 2048) {
        if ((t -= 2) < 0)
          break;
        a.push(i >> 6 | 192, 63 & i | 128);
      } else if (i < 65536) {
        if ((t -= 3) < 0)
          break;
        a.push(i >> 12 | 224, i >> 6 & 63 | 128, 63 & i | 128);
      } else {
        if (!(i < 1114112))
          throw new Error("Invalid code point");
        if ((t -= 4) < 0)
          break;
        a.push(i >> 18 | 240, i >> 12 & 63 | 128, i >> 6 & 63 | 128, 63 & i | 128);
      }
    }
    return a;
  };
  asciiToBytes = function(e) {
    for (var t = [], i = 0;i < e.length; ++i)
      t.push(255 & e.charCodeAt(i));
    return t;
  };
  utf16leToBytes = function(e, t) {
    for (var i, r, n, a = [], o = 0;o < e.length && !((t -= 2) < 0); ++o)
      r = (i = e.charCodeAt(o)) >> 8, n = i % 256, a.push(n), a.push(r);
    return a;
  };
  base64ToBytes = function(e) {
    return toByteArray(base64clean(e));
  };
  blitBuffer = function(e, t, i, r) {
    for (var n = 0;n < r && !(n + i >= t.length || n >= e.length); ++n)
      t[n + i] = e[n];
    return n;
  };
  isnan = function(e) {
    return e != e;
  };
  isBuffer = function(e) {
    return e != null && (!!e._isBuffer || isFastBuffer(e) || isSlowBuffer(e));
  };
  isFastBuffer = function(e) {
    return !!e.constructor && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e);
  };
  isSlowBuffer = function(e) {
    return typeof e.readFloatLE == "function" && typeof e.slice == "function" && isFastBuffer(e.slice(0, 0));
  };
  maskColor = function(e, t, i, r) {
    const n = 1 + ~e & e, a = 1 + ~t & t, o = 1 + ~i & i, s = 1 + ~r & r, l = e / n + 1, u = t / a + 1, h = i / o + 1, c = r / s + 1;
    return { shiftRed: (t2) => (t2 & e) / n * 256 / l, shiftGreen: (e2) => (e2 & t) / a * 256 / u, shiftBlue: (e2) => (e2 & i) / o * 256 / h, shiftAlpha: r !== 0 ? (e2) => (e2 & r) / s * 256 / c : () => 255 };
  };
  createInteger = function(e) {
    return e.reduce((e2, t) => e2 << 1 | t, 0);
  };
  createColor = function(e) {
    return e.quad << 24 | e.red << 16 | e.green << 8 | e.blue;
  };
  decode$2 = function(e, t) {
    return new BmpDecoder(e, t);
  };
  encode$2 = function(e) {
    return new BmpEncoder(e);
  };
  _typeof = function(e) {
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e2) {
      return typeof e2;
    } : function(e2) {
      return e2 && typeof Symbol == "function" && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
    }, _typeof(e);
  };
  tinycolor = function(e, t) {
    if (t = t || {}, (e = e || "") instanceof tinycolor)
      return e;
    if (!(this instanceof tinycolor))
      return new tinycolor(e, t);
    var i = inputToRGB(e);
    this._originalInput = e, this._r = i.r, this._g = i.g, this._b = i.b, this._a = i.a, this._roundA = Math.round(100 * this._a) / 100, this._format = t.format || i.format, this._gradientType = t.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = i.ok;
  };
  inputToRGB = function(e) {
    var t = { r: 0, g: 0, b: 0 }, i = 1, r = null, n = null, a = null, o = false, s = false;
    return typeof e == "string" && (e = stringInputToObject(e)), _typeof(e) == "object" && (isValidCSSUnit(e.r) && isValidCSSUnit(e.g) && isValidCSSUnit(e.b) ? (t = rgbToRgb(e.r, e.g, e.b), o = true, s = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : isValidCSSUnit(e.h) && isValidCSSUnit(e.s) && isValidCSSUnit(e.v) ? (r = convertToPercentage(e.s), n = convertToPercentage(e.v), t = hsvToRgb(e.h, r, n), o = true, s = "hsv") : isValidCSSUnit(e.h) && isValidCSSUnit(e.s) && isValidCSSUnit(e.l) && (r = convertToPercentage(e.s), a = convertToPercentage(e.l), t = hslToRgb(e.h, r, a), o = true, s = "hsl"), e.hasOwnProperty("a") && (i = e.a)), i = boundAlpha(i), { ok: o, format: e.format || s, r: Math.min(255, Math.max(t.r, 0)), g: Math.min(255, Math.max(t.g, 0)), b: Math.min(255, Math.max(t.b, 0)), a: i };
  };
  rgbToRgb = function(e, t, i) {
    return { r: 255 * bound01(e, 255), g: 255 * bound01(t, 255), b: 255 * bound01(i, 255) };
  };
  rgbToHsl = function(e, t, i) {
    e = bound01(e, 255), t = bound01(t, 255), i = bound01(i, 255);
    var r, n, a = Math.max(e, t, i), o = Math.min(e, t, i), s = (a + o) / 2;
    if (a == o)
      r = n = 0;
    else {
      var l = a - o;
      switch (n = s > 0.5 ? l / (2 - a - o) : l / (a + o), a) {
        case e:
          r = (t - i) / l + (t < i ? 6 : 0);
          break;
        case t:
          r = (i - e) / l + 2;
          break;
        case i:
          r = (e - t) / l + 4;
      }
      r /= 6;
    }
    return { h: r, s: n, l: s };
  };
  hslToRgb = function(e, t, i) {
    var r, n, a;
    function o(e2, t2, i2) {
      return i2 < 0 && (i2 += 1), i2 > 1 && (i2 -= 1), i2 < 1 / 6 ? e2 + 6 * (t2 - e2) * i2 : i2 < 0.5 ? t2 : i2 < 2 / 3 ? e2 + (t2 - e2) * (2 / 3 - i2) * 6 : e2;
    }
    if (e = bound01(e, 360), t = bound01(t, 100), i = bound01(i, 100), t === 0)
      r = n = a = i;
    else {
      var s = i < 0.5 ? i * (1 + t) : i + t - i * t, l = 2 * i - s;
      r = o(l, s, e + 1 / 3), n = o(l, s, e), a = o(l, s, e - 1 / 3);
    }
    return { r: 255 * r, g: 255 * n, b: 255 * a };
  };
  rgbToHsv = function(e, t, i) {
    e = bound01(e, 255), t = bound01(t, 255), i = bound01(i, 255);
    var r, n, a = Math.max(e, t, i), o = Math.min(e, t, i), s = a, l = a - o;
    if (n = a === 0 ? 0 : l / a, a == o)
      r = 0;
    else {
      switch (a) {
        case e:
          r = (t - i) / l + (t < i ? 6 : 0);
          break;
        case t:
          r = (i - e) / l + 2;
          break;
        case i:
          r = (e - t) / l + 4;
      }
      r /= 6;
    }
    return { h: r, s: n, v: s };
  };
  hsvToRgb = function(e, t, i) {
    e = 6 * bound01(e, 360), t = bound01(t, 100), i = bound01(i, 100);
    var r = Math.floor(e), n = e - r, a = i * (1 - t), o = i * (1 - n * t), s = i * (1 - (1 - n) * t), l = r % 6;
    return { r: 255 * [i, o, a, a, s, i][l], g: 255 * [s, i, i, o, a, a][l], b: 255 * [a, a, s, i, i, o][l] };
  };
  rgbToHex = function(e, t, i, r) {
    var n = [pad2(Math.round(e).toString(16)), pad2(Math.round(t).toString(16)), pad2(Math.round(i).toString(16))];
    return r && n[0].charAt(0) == n[0].charAt(1) && n[1].charAt(0) == n[1].charAt(1) && n[2].charAt(0) == n[2].charAt(1) ? n[0].charAt(0) + n[1].charAt(0) + n[2].charAt(0) : n.join("");
  };
  rgbaToHex = function(e, t, i, r, n) {
    var a = [pad2(Math.round(e).toString(16)), pad2(Math.round(t).toString(16)), pad2(Math.round(i).toString(16)), pad2(convertDecimalToHex(r))];
    return n && a[0].charAt(0) == a[0].charAt(1) && a[1].charAt(0) == a[1].charAt(1) && a[2].charAt(0) == a[2].charAt(1) && a[3].charAt(0) == a[3].charAt(1) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("");
  };
  rgbaToArgbHex = function(e, t, i, r) {
    return [pad2(convertDecimalToHex(r)), pad2(Math.round(e).toString(16)), pad2(Math.round(t).toString(16)), pad2(Math.round(i).toString(16))].join("");
  };
  _desaturate = function(e, t) {
    t = t === 0 ? 0 : t || 10;
    var i = tinycolor(e).toHsl();
    return i.s -= t / 100, i.s = clamp01(i.s), tinycolor(i);
  };
  _saturate = function(e, t) {
    t = t === 0 ? 0 : t || 10;
    var i = tinycolor(e).toHsl();
    return i.s += t / 100, i.s = clamp01(i.s), tinycolor(i);
  };
  _greyscale = function(e) {
    return tinycolor(e).desaturate(100);
  };
  _lighten = function(e, t) {
    t = t === 0 ? 0 : t || 10;
    var i = tinycolor(e).toHsl();
    return i.l += t / 100, i.l = clamp01(i.l), tinycolor(i);
  };
  _brighten = function(e, t) {
    t = t === 0 ? 0 : t || 10;
    var i = tinycolor(e).toRgb();
    return i.r = Math.max(0, Math.min(255, i.r - Math.round(-t / 100 * 255))), i.g = Math.max(0, Math.min(255, i.g - Math.round(-t / 100 * 255))), i.b = Math.max(0, Math.min(255, i.b - Math.round(-t / 100 * 255))), tinycolor(i);
  };
  _darken = function(e, t) {
    t = t === 0 ? 0 : t || 10;
    var i = tinycolor(e).toHsl();
    return i.l -= t / 100, i.l = clamp01(i.l), tinycolor(i);
  };
  _spin = function(e, t) {
    var i = tinycolor(e).toHsl(), r = (i.h + t) % 360;
    return i.h = r < 0 ? 360 + r : r, tinycolor(i);
  };
  _complement = function(e) {
    var t = tinycolor(e).toHsl();
    return t.h = (t.h + 180) % 360, tinycolor(t);
  };
  polyad = function(e, t) {
    if (isNaN(t) || t <= 0)
      throw new Error("Argument to polyad must be a positive number");
    for (var i = tinycolor(e).toHsl(), r = [tinycolor(e)], n = 360 / t, a = 1;a < t; a++)
      r.push(tinycolor({ h: (i.h + a * n) % 360, s: i.s, l: i.l }));
    return r;
  };
  _splitcomplement = function(e) {
    var t = tinycolor(e).toHsl(), i = t.h;
    return [tinycolor(e), tinycolor({ h: (i + 72) % 360, s: t.s, l: t.l }), tinycolor({ h: (i + 216) % 360, s: t.s, l: t.l })];
  };
  _analogous = function(e, t, i) {
    t = t || 6, i = i || 30;
    var r = tinycolor(e).toHsl(), n = 360 / i, a = [tinycolor(e)];
    for (r.h = (r.h - (n * t >> 1) + 720) % 360;--t; )
      r.h = (r.h + n) % 360, a.push(tinycolor(r));
    return a;
  };
  _monochromatic = function(e, t) {
    t = t || 6;
    for (var i = tinycolor(e).toHsv(), r = i.h, n = i.s, a = i.v, o = [], s = 1 / t;t--; )
      o.push(tinycolor({ h: r, s: n, v: a })), a = (a + s) % 1;
    return o;
  };
  flip = function(e) {
    var t = {};
    for (var i in e)
      e.hasOwnProperty(i) && (t[e[i]] = i);
    return t;
  };
  boundAlpha = function(e) {
    return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e;
  };
  bound01 = function(e, t) {
    isOnePointZero(e) && (e = "100%");
    var i = isPercentage(e);
    return e = Math.min(t, Math.max(0, parseFloat(e))), i && (e = parseInt(e * t, 10) / 100), Math.abs(e - t) < 0.000001 ? 1 : e % t / parseFloat(t);
  };
  clamp01 = function(e) {
    return Math.min(1, Math.max(0, e));
  };
  parseIntFromHex = function(e) {
    return parseInt(e, 16);
  };
  isOnePointZero = function(e) {
    return typeof e == "string" && e.indexOf(".") != -1 && parseFloat(e) === 1;
  };
  isPercentage = function(e) {
    return typeof e == "string" && e.indexOf("%") != -1;
  };
  pad2 = function(e) {
    return e.length == 1 ? "0" + e : "" + e;
  };
  convertToPercentage = function(e) {
    return e <= 1 && (e = 100 * e + "%"), e;
  };
  convertDecimalToHex = function(e) {
    return Math.round(255 * parseFloat(e)).toString(16);
  };
  convertHexToDecimal = function(e) {
    return parseIntFromHex(e) / 255;
  };
  isValidCSSUnit = function(e) {
    return !!matchers.CSS_UNIT.exec(e);
  };
  stringInputToObject = function(e) {
    e = e.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
    var t, i = false;
    if (names$1[e])
      e = names$1[e], i = true;
    else if (e == "transparent")
      return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    return (t = matchers.rgb.exec(e)) ? { r: t[1], g: t[2], b: t[3] } : (t = matchers.rgba.exec(e)) ? { r: t[1], g: t[2], b: t[3], a: t[4] } : (t = matchers.hsl.exec(e)) ? { h: t[1], s: t[2], l: t[3] } : (t = matchers.hsla.exec(e)) ? { h: t[1], s: t[2], l: t[3], a: t[4] } : (t = matchers.hsv.exec(e)) ? { h: t[1], s: t[2], v: t[3] } : (t = matchers.hsva.exec(e)) ? { h: t[1], s: t[2], v: t[3], a: t[4] } : (t = matchers.hex8.exec(e)) ? { r: parseIntFromHex(t[1]), g: parseIntFromHex(t[2]), b: parseIntFromHex(t[3]), a: convertHexToDecimal(t[4]), format: i ? "name" : "hex8" } : (t = matchers.hex6.exec(e)) ? { r: parseIntFromHex(t[1]), g: parseIntFromHex(t[2]), b: parseIntFromHex(t[3]), format: i ? "name" : "hex" } : (t = matchers.hex4.exec(e)) ? { r: parseIntFromHex(t[1] + "" + t[1]), g: parseIntFromHex(t[2] + "" + t[2]), b: parseIntFromHex(t[3] + "" + t[3]), a: convertHexToDecimal(t[4] + "" + t[4]), format: i ? "name" : "hex8" } : !!(t = matchers.hex3.exec(e)) && { r: parseIntFromHex(t[1] + "" + t[1]), g: parseIntFromHex(t[2] + "" + t[2]), b: parseIntFromHex(t[3] + "" + t[3]), format: i ? "name" : "hex" };
  };
  validateWCAG2Parms = function(e) {
    var t, i;
    return (t = ((e = e || { level: "AA", size: "small" }).level || "AA").toUpperCase()) !== "AA" && t !== "AAA" && (t = "AA"), (i = (e.size || "small").toLowerCase()) !== "small" && i !== "large" && (i = "small"), { level: t, size: i };
  };
  clone = function(e) {
    const t = { width: e.bitmap.width, height: e.bitmap.height, data: Buffer2.from(e.bitmap.data) };
    return new e.constructor(t);
  };
  scan = function(e, t, i, r, n, a) {
    let o, s, l, u, h;
    if (typeof t == "function")
      h = t, o = 0, s = 0, l = e.bitmap.width, u = e.bitmap.height;
    else {
      if (o = t, typeof i != "number")
        throw new Error("y must be a number");
      if (s = i, typeof r != "number")
        throw new Error("w must be a number");
      if (l = r, typeof n != "number")
        throw new Error("h must be a number");
      if (u = n, typeof a != "function")
        throw new Error("cb must be a function");
      h = a;
    }
    o = Math.round(o), s = Math.round(s), l = Math.round(l), u = Math.round(u);
    const c = h.bind(e);
    for (let t2 = s;t2 < s + u; t2++)
      for (let i2 = o;i2 < o + l; i2++) {
        c(i2, t2, e.bitmap.width * t2 + i2 << 2);
      }
    return e;
  };
  intToRGBA$1 = function(e) {
    if (typeof e != "number")
      throw new Error("i must be a number");
    const t = { r: 0, g: 0, b: 0, a: 0 };
    return t.r = Math.floor(e / Math.pow(256, 3)), t.g = Math.floor((e - t.r * Math.pow(256, 3)) / Math.pow(256, 2)), t.b = Math.floor((e - t.r * Math.pow(256, 3) - t.g * Math.pow(256, 2)) / Math.pow(256, 1)), t.a = Math.floor((e - t.r * Math.pow(256, 3) - t.g * Math.pow(256, 2) - t.b * Math.pow(256, 1)) / Math.pow(256, 0)), t;
  };
  rgbaToInt = function(e, t, i, r) {
    if (typeof e != "number" || typeof t != "number" || typeof i != "number" || typeof r != "number")
      throw new Error("r, g, b and a must be numbers");
    if (e < 0 || e > 255)
      throw new Error("r must be between 0 and 255");
    if (t < 0 || t > 255)
      throw new Error("g must be between 0 and 255");
    if (i < 0 || i > 255)
      throw new Error("b must be between 0 and 255");
    if (r < 0 || r > 255)
      throw new Error("a must be between 0 and 255");
    let n = 255 & e;
    return n <<= 8, n |= 255 & t, n <<= 8, n |= 255 & i, n <<= 8, n |= 255 & r, n >>>= 0, n;
  };
  colorDiff = function(e, t) {
    const i = (e2) => Math.pow(e2, 2), { max: r } = Math, n = "a" in e ? e.a : 255, a = "a" in t ? t.a : 255;
    return (r(i(e.r - t.r), i(e.r - t.r - n + a)) + r(i(e.g - t.g), i(e.g - t.g - n + a)) + r(i(e.b - t.b), i(e.b - t.b - n + a))) / 195075;
  };
  limit255 = function(e) {
    return e = Math.max(e, 0), e = Math.min(e, 255);
  };
  cssColorToHex = function(e) {
    return typeof e == "number" ? e : parseInt(tinycolor(e).toHex8(), 16);
  };
  encode$1 = function(e, t = {}) {
    return scan({ bitmap: e }, 0, 0, e.width, e.height, function(t2, i, r) {
      const n = e.data[r + 0], a = e.data[r + 1], o = e.data[r + 2], s = e.data[r + 3];
      e.data[r + 0] = s, e.data[r + 1] = o, e.data[r + 2] = a, e.data[r + 3] = n;
    }), encode$2({ ...e, ...t }).data;
  };
  decode$1 = function(e, t) {
    const i = decode$2(e, t);
    return scan({ bitmap: i }, 0, 0, i.width, i.height, function(e2, t2, r) {
      const n = i.data[r + 1], a = i.data[r + 2], o = i.data[r + 3];
      i.data[r + 0] = o, i.data[r + 1] = a, i.data[r + 2] = n, i.data[r + 3] = 255;
    }), i;
  };
  msBmp = function() {
    return { mime: "image/x-ms-bmp", encode: encode$1, decode: decode$1 };
  };
  bmp = function() {
    return { mime: "image/bmp", encode: encode$1, decode: decode$1 };
  };
  GifWriter = function(e, t, i, r) {
    var n = 0, a = (r = r === undefined ? {} : r).loop === undefined ? null : r.loop, o = r.palette === undefined ? null : r.palette;
    if (t <= 0 || i <= 0 || t > 65535 || i > 65535)
      throw new Error("Width/Height invalid.");
    function s(e2) {
      var t2 = e2.length;
      if (t2 < 2 || t2 > 256 || t2 & t2 - 1)
        throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
      return t2;
    }
    e[n++] = 71, e[n++] = 73, e[n++] = 70, e[n++] = 56, e[n++] = 57, e[n++] = 97;
    var l = 0, u = 0;
    if (o !== null) {
      for (var h = s(o);h >>= 1; )
        ++l;
      if (h = 1 << l, --l, r.background !== undefined) {
        if ((u = r.background) >= h)
          throw new Error("Background index out of range.");
        if (u === 0)
          throw new Error("Background index explicitly passed as 0.");
      }
    }
    if (e[n++] = 255 & t, e[n++] = t >> 8 & 255, e[n++] = 255 & i, e[n++] = i >> 8 & 255, e[n++] = (o !== null ? 128 : 0) | l, e[n++] = u, e[n++] = 0, o !== null)
      for (var c = 0, f = o.length;c < f; ++c) {
        var d = o[c];
        e[n++] = d >> 16 & 255, e[n++] = d >> 8 & 255, e[n++] = 255 & d;
      }
    if (a !== null) {
      if (a < 0 || a > 65535)
        throw new Error("Loop count invalid.");
      e[n++] = 33, e[n++] = 255, e[n++] = 11, e[n++] = 78, e[n++] = 69, e[n++] = 84, e[n++] = 83, e[n++] = 67, e[n++] = 65, e[n++] = 80, e[n++] = 69, e[n++] = 50, e[n++] = 46, e[n++] = 48, e[n++] = 3, e[n++] = 1, e[n++] = 255 & a, e[n++] = a >> 8 & 255, e[n++] = 0;
    }
    var p = false;
    this.addFrame = function(t2, i2, r2, a2, l2, u2) {
      if (p === true && (--n, p = false), u2 = u2 === undefined ? {} : u2, t2 < 0 || i2 < 0 || t2 > 65535 || i2 > 65535)
        throw new Error("x/y invalid.");
      if (r2 <= 0 || a2 <= 0 || r2 > 65535 || a2 > 65535)
        throw new Error("Width/Height invalid.");
      if (l2.length < r2 * a2)
        throw new Error("Not enough pixels for the frame size.");
      var h2 = true, c2 = u2.palette;
      if (c2 == null && (h2 = false, c2 = o), c2 == null)
        throw new Error("Must supply either a local or global palette.");
      for (var f2 = s(c2), d2 = 0;f2 >>= 1; )
        ++d2;
      f2 = 1 << d2;
      var m = u2.delay === undefined ? 0 : u2.delay, _ = u2.disposal === undefined ? 0 : u2.disposal;
      if (_ < 0 || _ > 3)
        throw new Error("Disposal out of range.");
      var g = false, b = 0;
      if (u2.transparent !== undefined && u2.transparent !== null && (g = true, (b = u2.transparent) < 0 || b >= f2))
        throw new Error("Transparent color index.");
      if ((_ !== 0 || g || m !== 0) && (e[n++] = 33, e[n++] = 249, e[n++] = 4, e[n++] = _ << 2 | (g === true ? 1 : 0), e[n++] = 255 & m, e[n++] = m >> 8 & 255, e[n++] = b, e[n++] = 0), e[n++] = 44, e[n++] = 255 & t2, e[n++] = t2 >> 8 & 255, e[n++] = 255 & i2, e[n++] = i2 >> 8 & 255, e[n++] = 255 & r2, e[n++] = r2 >> 8 & 255, e[n++] = 255 & a2, e[n++] = a2 >> 8 & 255, e[n++] = h2 === true ? 128 | d2 - 1 : 0, h2 === true)
        for (var y = 0, w = c2.length;y < w; ++y) {
          var v = c2[y];
          e[n++] = v >> 16 & 255, e[n++] = v >> 8 & 255, e[n++] = 255 & v;
        }
      return n = GifWriterOutputLZWCodeStream(e, n, d2 < 2 ? 2 : d2, l2);
    }, this.end = function() {
      return p === false && (e[n++] = 59, p = true), n;
    }, this.getOutputBuffer = function() {
      return e;
    }, this.setOutputBuffer = function(t2) {
      e = t2;
    }, this.getOutputBufferPosition = function() {
      return n;
    }, this.setOutputBufferPosition = function(e2) {
      n = e2;
    };
  };
  GifWriterOutputLZWCodeStream = function(e, t, i, r) {
    e[t++] = i;
    var n = t++, a = 1 << i, o = a - 1, s = a + 1, l = s + 1, u = i + 1, h = 0, c = 0;
    function f(i2) {
      for (;h >= i2; )
        e[t++] = 255 & c, c >>= 8, h -= 8, t === n + 256 && (e[n] = 255, n = t++);
    }
    function d(e2) {
      c |= e2 << h, h += u, f(8);
    }
    var p = r[0] & o, m = {};
    d(a);
    for (var _ = 1, g = r.length;_ < g; ++_) {
      var b = r[_] & o, y = p << 8 | b, w = m[y];
      if (w === undefined) {
        for (c |= p << h, h += u;h >= 8; )
          e[t++] = 255 & c, c >>= 8, h -= 8, t === n + 256 && (e[n] = 255, n = t++);
        l === 4096 ? (d(a), l = s + 1, u = i + 1, m = {}) : (l >= 1 << u && ++u, m[y] = l++), p = b;
      } else
        p = w;
    }
    return d(p), d(s), f(1), n + 1 === t ? e[n] = 0 : (e[n] = t - n - 1, e[t++] = 0), t;
  };
  GifReader = function(e) {
    var t = 0;
    if (e[t++] !== 71 || e[t++] !== 73 || e[t++] !== 70 || e[t++] !== 56 || (e[t++] + 1 & 253) != 56 || e[t++] !== 97)
      throw new Error("Invalid GIF 87a/89a header.");
    var i = e[t++] | e[t++] << 8, r = e[t++] | e[t++] << 8, n = e[t++], a = n >> 7, o = 1 << (7 & n) + 1;
    e[t++], e[t++];
    var s = null, l = null;
    a && (s = t, l = o, t += 3 * o);
    var u = true, h = [], c = 0, f = null, d = 0, p = null;
    for (this.width = i, this.height = r;u && t < e.length; )
      switch (e[t++]) {
        case 33:
          switch (e[t++]) {
            case 255:
              if (e[t] !== 11 || e[t + 1] == 78 && e[t + 2] == 69 && e[t + 3] == 84 && e[t + 4] == 83 && e[t + 5] == 67 && e[t + 6] == 65 && e[t + 7] == 80 && e[t + 8] == 69 && e[t + 9] == 50 && e[t + 10] == 46 && e[t + 11] == 48 && e[t + 12] == 3 && e[t + 13] == 1 && e[t + 16] == 0)
                t += 14, p = e[t++] | e[t++] << 8, t++;
              else
                for (t += 12;; ) {
                  if (!((I = e[t++]) >= 0))
                    throw Error("Invalid block size");
                  if (I === 0)
                    break;
                  t += I;
                }
              break;
            case 249:
              if (e[t++] !== 4 || e[t + 4] !== 0)
                throw new Error("Invalid graphics extension block.");
              var m = e[t++];
              c = e[t++] | e[t++] << 8, f = e[t++], 1 & m || (f = null), d = m >> 2 & 7, t++;
              break;
            case 254:
              for (;; ) {
                if (!((I = e[t++]) >= 0))
                  throw Error("Invalid block size");
                if (I === 0)
                  break;
                t += I;
              }
              break;
            default:
              throw new Error("Unknown graphic control label: 0x" + e[t - 1].toString(16));
          }
          break;
        case 44:
          var _ = e[t++] | e[t++] << 8, g = e[t++] | e[t++] << 8, b = e[t++] | e[t++] << 8, y = e[t++] | e[t++] << 8, w = e[t++], v = w >> 6 & 1, x = 1 << (7 & w) + 1, E = s, k = l, S = false;
          if (w >> 7) {
            S = true;
            E = t, k = x, t += 3 * x;
          }
          var A = t;
          for (t++;; ) {
            var I;
            if (!((I = e[t++]) >= 0))
              throw Error("Invalid block size");
            if (I === 0)
              break;
            t += I;
          }
          h.push({ x: _, y: g, width: b, height: y, has_local_palette: S, palette_offset: E, palette_size: k, data_offset: A, data_length: t - A, transparent_index: f, interlaced: !!v, delay: c, disposal: d });
          break;
        case 59:
          u = false;
          break;
        default:
          throw new Error("Unknown gif block: 0x" + e[t - 1].toString(16));
      }
    this.numFrames = function() {
      return h.length;
    }, this.loopCount = function() {
      return p;
    }, this.frameInfo = function(e2) {
      if (e2 < 0 || e2 >= h.length)
        throw new Error("Frame index out of range.");
      return h[e2];
    }, this.decodeAndBlitFrameBGRA = function(t2, r2) {
      var n2 = this.frameInfo(t2), a2 = n2.width * n2.height, o2 = new Uint8Array(a2);
      GifReaderLZWOutputIndexStream(e, n2.data_offset, o2, a2);
      var { palette_offset: s2, transparent_index: l2 } = n2;
      l2 === null && (l2 = 256);
      var u2 = n2.width, h2 = i - u2, c2 = u2, f2 = 4 * (n2.y * i + n2.x), d2 = 4 * ((n2.y + n2.height) * i + n2.x), p2 = f2, m2 = 4 * h2;
      n2.interlaced === true && (m2 += 4 * i * 7);
      for (var _2 = 8, g2 = 0, b2 = o2.length;g2 < b2; ++g2) {
        var y2 = o2[g2];
        if (c2 === 0 && (c2 = u2, (p2 += m2) >= d2 && (m2 = 4 * h2 + 4 * i * (_2 - 1), p2 = f2 + (u2 + h2) * (_2 << 1), _2 >>= 1)), y2 === l2)
          p2 += 4;
        else {
          var w2 = e[s2 + 3 * y2], v2 = e[s2 + 3 * y2 + 1], x2 = e[s2 + 3 * y2 + 2];
          r2[p2++] = x2, r2[p2++] = v2, r2[p2++] = w2, r2[p2++] = 255;
        }
        --c2;
      }
    }, this.decodeAndBlitFrameRGBA = function(t2, r2) {
      var n2 = this.frameInfo(t2), a2 = n2.width * n2.height, o2 = new Uint8Array(a2);
      GifReaderLZWOutputIndexStream(e, n2.data_offset, o2, a2);
      var { palette_offset: s2, transparent_index: l2 } = n2;
      l2 === null && (l2 = 256);
      var u2 = n2.width, h2 = i - u2, c2 = u2, f2 = 4 * (n2.y * i + n2.x), d2 = 4 * ((n2.y + n2.height) * i + n2.x), p2 = f2, m2 = 4 * h2;
      n2.interlaced === true && (m2 += 4 * i * 7);
      for (var _2 = 8, g2 = 0, b2 = o2.length;g2 < b2; ++g2) {
        var y2 = o2[g2];
        if (c2 === 0 && (c2 = u2, (p2 += m2) >= d2 && (m2 = 4 * h2 + 4 * i * (_2 - 1), p2 = f2 + (u2 + h2) * (_2 << 1), _2 >>= 1)), y2 === l2)
          p2 += 4;
        else {
          var w2 = e[s2 + 3 * y2], v2 = e[s2 + 3 * y2 + 1], x2 = e[s2 + 3 * y2 + 2];
          r2[p2++] = w2, r2[p2++] = v2, r2[p2++] = x2, r2[p2++] = 255;
        }
        --c2;
      }
    };
  };
  GifReaderLZWOutputIndexStream = function(e, t, i, r) {
    for (var n = e[t++], a = 1 << n, o = a + 1, s = o + 1, l = n + 1, u = (1 << l) - 1, h = 0, c = 0, f = 0, d = e[t++], p = new Int32Array(4096), m = null;; ) {
      for (;h < 16 && d !== 0; )
        c |= e[t++] << h, h += 8, d === 1 ? d = e[t++] : --d;
      if (h < l)
        break;
      var _ = c & u;
      if (c >>= l, h -= l, _ !== a) {
        if (_ === o)
          break;
        for (var g = _ < s ? _ : m, b = 0, y = g;y > a; )
          y = p[y] >> 8, ++b;
        var w = y;
        if (f + b + (g !== _ ? 1 : 0) > r)
          return void console.log("Warning, gif stream longer than expected.");
        i[f++] = w;
        var v = f += b;
        for (g !== _ && (i[f++] = w), y = g;b--; )
          y = p[y], i[--v] = 255 & y, y >>= 8;
        m !== null && s < 4096 && (p[s++] = m << 8 | w, s >= u + 1 && l < 12 && (++l, u = u << 1 | 1)), m = _;
      } else
        s = o + 1, u = (1 << (l = n + 1)) - 1, m = null;
    }
    return f !== r && console.log("Warning, gif stream shorter than expected."), i;
  };
  correctGamma$1 = function(e) {
    return e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92;
  };
  rgb2xyz$1 = function(e, t, i) {
    return { x: 0.4124 * (e = correctGamma$1(e / 255)) + 0.3576 * (t = correctGamma$1(t / 255)) + 0.1805 * (i = correctGamma$1(i / 255)), y: 0.2126 * e + 0.7152 * t + 0.0722 * i, z: 0.0193 * e + 0.1192 * t + 0.9505 * i };
  };
  degrees2radians$1 = function(e) {
    return e * (Math.PI / 180);
  };
  max3$1 = function(e, t, i) {
    let r = e;
    return r < t && (r = t), r < i && (r = i), r;
  };
  min3$1 = function(e, t, i) {
    let r = e;
    return r > t && (r = t), r > i && (r = i), r;
  };
  intInRange$1 = function(e, t, i) {
    return e > i && (e = i), e < t && (e = t), 0 | e;
  };
  inRange0to255Rounded$1 = function(e) {
    return (e = Math.round(e)) > 255 ? e = 255 : e < 0 && (e = 0), e;
  };
  inRange0to255$1 = function(e) {
    return e > 255 ? e = 255 : e < 0 && (e = 0), e;
  };
  stableSort$1 = function(e, t) {
    const i = typeof e[0];
    let r;
    if (i === "number" || i === "string") {
      const i2 = Object.create(null);
      for (let t2 = 0, r2 = e.length;t2 < r2; t2++) {
        const r3 = e[t2];
        i2[r3] || i2[r3] === 0 || (i2[r3] = t2);
      }
      r = e.sort((e2, r2) => t(e2, r2) || i2[e2] - i2[r2]);
    } else {
      const i2 = e.slice(0);
      r = e.sort((e2, r2) => t(e2, r2) || i2.indexOf(e2) - i2.indexOf(r2));
    }
    return r;
  };
  rgb2hsl$1 = function(e, t, i) {
    const r = min3$1(e, t, i), n = max3$1(e, t, i), a = n - r, o = (r + n) / 510;
    let s = 0;
    o > 0 && o < 1 && (s = a / (o < 0.5 ? n + r : 510 - n - r));
    let l = 0;
    return a > 0 && (l = n === e ? (t - i) / a : n === t ? 2 + (i - e) / a : 4 + (e - t) / a, l *= 60, l < 0 && (l += 360)), { h: l, s, l: o };
  };
  pivot$1 = function(e) {
    return e > 0.008856 ? e ** (1 / 3) : 7.787 * e + 16 / 116;
  };
  xyz2lab$1 = function(e, t, i) {
    if (e = pivot$1(e / refX$1), t = pivot$1(t / refY$1), i = pivot$1(i / refZ$1), 116 * t - 16 < 0)
      throw new Error("xxx");
    return { L: Math.max(0, 116 * t - 16), a: 500 * (e - t), b: 200 * (t - i) };
  };
  rgb2lab$1 = function(e, t, i) {
    const r = rgb2xyz$1(e, t, i);
    return xyz2lab$1(r.x, r.y, r.z);
  };
  pivot2$1 = function(e) {
    return e > 0.206893034 ? e ** 3 : (e - 16 / 116) / 7.787;
  };
  lab2xyz$1 = function(e, t, i) {
    const r = (e + 16) / 116, n = r - i / 200;
    return { x: refX2$1 * pivot2$1(t / 500 + r), y: refY2$1 * pivot2$1(r), z: refZ2$1 * pivot2$1(n) };
  };
  correctGamma2$1 = function(e) {
    return e > 0.0031308 ? 1.055 * e ** (1 / 2.4) - 0.055 : 12.92 * e;
  };
  xyz2rgb$1 = function(e, t, i) {
    const r = correctGamma2$1(3.2406 * e + -1.5372 * t + -0.4986 * i), n = correctGamma2$1(-0.9689 * e + 1.8758 * t + 0.0415 * i), a = correctGamma2$1(0.0557 * e + -0.204 * t + 1.057 * i);
    return { r: inRange0to255Rounded$1(255 * r), g: inRange0to255Rounded$1(255 * n), b: inRange0to255Rounded$1(255 * a) };
  };
  lab2rgb$1 = function(e, t, i) {
    const r = lab2xyz$1(e, t, i);
    return xyz2rgb$1(r.x, r.y, r.z);
  };
  hueGroup$1 = function(e, t) {
    const i = 360 / t;
    for (let r = 1, n = i - i / 2;r < t; r++, n += i)
      if (e >= n && e < n + i)
        return r;
    return 0;
  };
  createArray1D$1 = function(e) {
    const t = [];
    for (let i = 0;i < e; i++)
      t[i] = 0;
    return t;
  };
  createArray4D$1 = function(e, t, i, r) {
    const n = new Array(e);
    for (let a = 0;a < e; a++) {
      n[a] = new Array(t);
      for (let e2 = 0;e2 < t; e2++) {
        n[a][e2] = new Array(i);
        for (let t2 = 0;t2 < i; t2++) {
          n[a][e2][t2] = new Array(r);
          for (let i2 = 0;i2 < r; i2++)
            n[a][e2][t2][i2] = 0;
        }
      }
    }
    return n;
  };
  createArray3D$1 = function(e, t, i) {
    const r = new Array(e);
    for (let n = 0;n < e; n++) {
      r[n] = new Array(t);
      for (let e2 = 0;e2 < t; e2++) {
        r[n][e2] = new Array(i);
        for (let t2 = 0;t2 < i; t2++)
          r[n][e2][t2] = 0;
      }
    }
    return r;
  };
  fillArray3D$1 = function(e, t, i, r, n) {
    for (let a = 0;a < t; a++) {
      e[a] = [];
      for (let t2 = 0;t2 < i; t2++) {
        e[a][t2] = [];
        for (let i2 = 0;i2 < r; i2++)
          e[a][t2][i2] = n;
      }
    }
  };
  fillArray1D$1 = function(e, t, i) {
    for (let r = 0;r < t; r++)
      e[r] = i;
  };
  visit$1 = function(e, t) {
    switch (e.x >= 0 && e.x < e.width && e.y >= 0 && e.y < e.height && (e.callback(e.x, e.y), e.index++), t) {
      case 2:
        e.x--;
        break;
      case 3:
        e.x++;
        break;
      case 1:
        e.y--;
        break;
      case 4:
        e.y++;
    }
  };
  ssim$1 = function(e, t) {
    if (e.getHeight() !== t.getHeight() || e.getWidth() !== t.getWidth())
      throw new Error("Images have different sizes!");
    const i = (255 * K1$1) ** 2, r = (255 * K2$1) ** 2;
    let n = 0, a = 0;
    return iterate$1(e, t, (e2, t2, o, s) => {
      let l = 0, u = 0, h = 0;
      for (let i2 = 0;i2 < e2.length; i2++)
        u += (e2[i2] - o) ** 2, h += (t2[i2] - s) ** 2, l += (e2[i2] - o) * (t2[i2] - s);
      const c = e2.length - 1;
      u /= c, h /= c, l /= c;
      a += (2 * o * s + i) * (2 * l + r) / ((o ** 2 + s ** 2 + i) * (u + h + r)), n++;
    }), a / n;
  };
  iterate$1 = function(e, t, i) {
    const r = e.getWidth(), n = e.getHeight();
    for (let a = 0;a < n; a += 8)
      for (let o = 0;o < r; o += 8) {
        const s = Math.min(8, r - o), l = Math.min(8, n - a), u = calculateLumaValuesForWindow$1(e, o, a, s, l), h = calculateLumaValuesForWindow$1(t, o, a, s, l);
        i(u, h, calculateAverageLuma$1(u), calculateAverageLuma$1(h));
      }
  };
  calculateLumaValuesForWindow$1 = function(e, t, i, r, n) {
    const a = e.getPointArray(), o = [];
    let s = 0;
    for (let l = i;l < i + n; l++) {
      const i2 = l * e.getWidth();
      for (let e2 = t;e2 < t + r; e2++) {
        const t2 = a[i2 + e2];
        o[s] = 0.2126 * t2.r + 0.7152 * t2.g + 0.0722 * t2.b, s++;
      }
    }
    return o;
  };
  calculateAverageLuma$1 = function(e) {
    let t = 0;
    for (const i of e)
      t += i;
    return t / e.length;
  };
  buildPaletteSync$1 = function(e, { colorDistanceFormula: t, paletteQuantization: i, colors: r } = {}) {
    const n = paletteQuantizationToPaletteQuantizer$1(colorDistanceFormulaToColorDistance$1(t), i, r);
    return e.forEach((e2) => n.sample(e2)), n.quantizeSync();
  };
  applyPaletteSync$1 = function(e, t, { colorDistanceFormula: i, imageQuantization: r } = {}) {
    return imageQuantizationToImageQuantizer$1(colorDistanceFormulaToColorDistance$1(i), r).quantizeSync(e, t);
  };
  colorDistanceFormulaToColorDistance$1 = function(e = "euclidean-bt709") {
    switch (e) {
      case "cie94-graphic-arts":
        return new CIE94GraphicArts$1;
      case "cie94-textiles":
        return new CIE94Textiles$1;
      case "ciede2000":
        return new CIEDE2000$1;
      case "color-metric":
        return new CMetric$1;
      case "euclidean":
        return new Euclidean$1;
      case "euclidean-bt709":
        return new EuclideanBT709$1;
      case "euclidean-bt709-noalpha":
        return new EuclideanBT709NoAlpha$1;
      case "manhattan":
        return new Manhattan$1;
      case "manhattan-bt709":
        return new ManhattanBT709$1;
      case "manhattan-nommyde":
        return new ManhattanNommyde$1;
      case "pngquant":
        return new PNGQuant$1;
      default:
        throw new Error(`Unknown colorDistanceFormula ${e}`);
    }
  };
  imageQuantizationToImageQuantizer$1 = function(e, t = "floyd-steinberg") {
    switch (t) {
      case "nearest":
        return new NearestColor$1(e);
      case "riemersma":
        return new ErrorDiffusionRiemersma$1(e);
      case "floyd-steinberg":
        return new ErrorDiffusionArray$1(e, 0);
      case "false-floyd-steinberg":
        return new ErrorDiffusionArray$1(e, 1);
      case "stucki":
        return new ErrorDiffusionArray$1(e, 2);
      case "atkinson":
        return new ErrorDiffusionArray$1(e, 3);
      case "jarvis":
        return new ErrorDiffusionArray$1(e, 4);
      case "burkes":
        return new ErrorDiffusionArray$1(e, 5);
      case "sierra":
        return new ErrorDiffusionArray$1(e, 6);
      case "two-sierra":
        return new ErrorDiffusionArray$1(e, 7);
      case "sierra-lite":
        return new ErrorDiffusionArray$1(e, 8);
      default:
        throw new Error(`Unknown imageQuantization ${t}`);
    }
  };
  paletteQuantizationToPaletteQuantizer$1 = function(e, t = "wuquant", i = 256) {
    switch (t) {
      case "neuquant":
        return new NeuQuant$1(e, i);
      case "rgbquant":
        return new RGBQuant$1(e, i);
      case "wuquant":
        return new WuQuant$1(e, i);
      case "neuquant-float":
        return new NeuQuantFloat$1(e, i);
      default:
        throw new Error(`Unknown paletteQuantization ${t}`);
    }
  };
  requireGifutil = function() {
    return hasRequiredGifutil || (hasRequiredGifutil = 1, function(e) {
      const t = require$$0, i = imageQ, r = bitmapimage, { GifFrame: n } = gifframe, { GifError: a } = gif$1, { GifCodec: o } = requireGifcodec(), s = [".jpg", ".jpeg", ".png", ".bmp"], l = new o;
      function u(e2, t2, r2, n2, a2) {
        const o2 = Array.isArray(e2) ? e2 : [e2];
        if (a2) {
          if (["FloydSteinberg", "FalseFloydSteinberg", "Stucki", "Atkinson", "Jarvis", "Burkes", "Sierra", "TwoSierra", "SierraLite"].indexOf(a2.ditherAlgorithm) < 0)
            throw new Error(`Invalid ditherAlgorithm '${a2.ditherAlgorithm}'`);
          a2.serpentine === undefined && (a2.serpentine = true), a2.minimumColorDistanceToDither === undefined && (a2.minimumColorDistanceToDither = 0), a2.calculateErrorLikeGIMP === undefined && (a2.calculateErrorLikeGIMP = false);
        }
        const s2 = new i.distance.Euclidean, l2 = new i.palette[t2](s2, r2, n2);
        let u2;
        u2 = a2 ? new i.image.ErrorDiffusionArray(s2, i.image.ErrorDiffusionArrayKernel[a2.ditherAlgorithm], a2.serpentine, a2.minimumColorDistanceToDither, a2.calculateErrorLikeGIMP) : new i.image.NearestColor(s2);
        const h = [];
        o2.forEach((e3) => {
          const t3 = e3.bitmap.data, r3 = new ArrayBuffer(t3.length), n3 = new Uint32Array(r3);
          for (let e4 = 0, i2 = 0;e4 < t3.length; e4 += 4, ++i2)
            n3[i2] = t3.readUInt32LE(e4, true);
          const a3 = i.utils.PointContainer.fromUint32Array(n3, e3.bitmap.width, e3.bitmap.height);
          l2.sample(a3), h.push(a3);
        });
        const c = l2.quantizeSync();
        for (let e3 = 0;e3 < o2.length; ++e3) {
          const t3 = o2[e3].bitmap.data, i2 = u2.quantizeSync(h[e3], c).toUint32Array();
          for (let e4 = 0, r3 = 0;e4 < t3.length; e4 += 4, ++r3)
            t3.writeUInt32LE(i2[r3], e4);
        }
      }
      e.cloneFrames = function(e2) {
        let t2 = [];
        return e2.forEach((e3) => {
          t2.push(new n(e3));
        }), t2;
      }, e.getColorInfo = function(e2, t2) {
        let i2 = false;
        const r2 = [];
        for (let t3 = 0;t3 < e2.length; ++t3) {
          let n3 = e2[t3].getPalette();
          if (n3.usesTransparency && (i2 = true), n3.indexCount > 256)
            throw new a(`Frame ${t3} uses more than 256 color indexes`);
          r2.push(n3);
        }
        if (t2 === 0)
          return { usesTransparency: i2, palettes: r2 };
        const n2 = new Set;
        r2.forEach((e3) => {
          e3.colors.forEach((e4) => {
            n2.add(e4);
          });
        });
        let o2 = n2.size;
        if (i2 && ++o2, t2 && o2 > t2)
          return { usesTransparency: i2, palettes: r2 };
        const s2 = new Array(n2.size), l2 = n2.values();
        for (let e3 = 0;e3 < s2.length; ++e3)
          s2[e3] = l2.next().value;
        return s2.sort((e3, t3) => e3 - t3), { colors: s2, indexCount: o2, usesTransparency: i2, palettes: r2 };
      }, e.copyAsJimp = function(t2, i2) {
        return e.shareAsJimp(t2, new r(i2));
      }, e.getMaxDimensions = function(e2) {
        let t2 = 0, i2 = 0;
        return e2.forEach((e3) => {
          const r2 = e3.xOffset + e3.bitmap.width;
          r2 > t2 && (t2 = r2);
          const n2 = e3.yOffset + e3.bitmap.height;
          n2 > i2 && (i2 = n2);
        }), { maxWidth: t2, maxHeight: i2 };
      }, e.quantizeDekker = function(e2, t2, i2) {
        u(e2, "NeuQuantFloat", t2 = t2 || 256, 0, i2);
      }, e.quantizeSorokin = function(e2, t2, i2, r2) {
        let n2;
        switch (t2 = t2 || 256, i2 = i2 || "min-pop") {
          case "min-pop":
            n2 = 2;
            break;
          case "top-pop":
            n2 = 1;
            break;
          default:
            throw new Error(`Invalid quantizeSorokin histogram '${i2}'`);
        }
        u(e2, "RGBQuant", t2, n2, r2);
      }, e.quantizeWu = function(e2, t2, i2, r2) {
        if (t2 = t2 || 256, (i2 = i2 || 5) < 1 || i2 > 8)
          throw new Error("Invalid quantization quality");
        u(e2, "WuQuant", t2, i2, r2);
      }, e.read = function(e2, i2) {
        return i2 = i2 || l, Buffer2.isBuffer(e2) ? i2.decodeGif(e2) : function(e3) {
          return new Promise((i3, r2) => {
            t.readFile(e3, (e4, t2) => e4 ? r2(e4) : i3(t2));
          });
        }(e2).then((e3) => i2.decodeGif(e3));
      }, e.shareAsJimp = function(e2, t2) {
        const i2 = new e2(t2.bitmap.width, t2.bitmap.height, 0);
        return i2.bitmap.data = t2.bitmap.data, i2;
      }, e.write = function(e2, i2, r2, n2) {
        n2 = n2 || l;
        const a2 = e2.match(/\.[a-zA-Z]+$/);
        if (a2 !== null && s.includes(a2[0].toLowerCase()))
          throw new Error(`GIF '${e2}' has an unexpected suffix`);
        return n2.encodeGif(i2, r2).then((i3) => function(e3, i4) {
          return new Promise((r3, n3) => {
            t.writeFile(e3, i4, (e4) => e4 ? n3(e4) : r3());
          });
        }(e2, i3.buffer).then(() => i3));
      };
    }(gifutil)), gifutil;
  };
  requireGifcodec = function() {
    if (hasRequiredGifcodec)
      return gifcodec;
    hasRequiredGifcodec = 1;
    const e = omggif, { Gif: t, GifError: i } = gif$1;
    function r() {
      const e2 = requireGifutil();
      return r = function() {
        return e2;
      }, e2;
    }
    const { GifFrame: n } = gifframe;
    function a(e2, t2) {
      const i2 = e2.indexOf(t2);
      return i2 === -1 ? null : i2;
    }
    function o(e2, t2) {
      for (var i2, r2 = 0, n2 = e2.length - 1;r2 <= n2; )
        if (e2[i2 = Math.floor((r2 + n2) / 2)] > t2)
          n2 = i2 - 1;
        else {
          if (!(e2[i2] < t2))
            return i2;
          r2 = i2 + 1;
        }
      return null;
    }
    function s(e2) {
      const t2 = e2.colors;
      e2.usesTransparency && t2.push(0);
      const i2 = t2.length;
      let r2 = 2;
      for (;i2 > r2; )
        r2 <<= 1;
      t2.length = r2, t2.fill(0, i2);
    }
    function l(e2, t2) {
      let i2 = e2.bitmap.width * e2.bitmap.height;
      return i2 = Math.ceil(i2 * t2 / 8), i2 += Math.ceil(i2 / 255), 100 + i2 + 768;
    }
    function u(e2) {
      let t2 = e2.indexCount, i2 = 0;
      for (--t2;t2; )
        ++i2, t2 >>= 1;
      return i2 > 0 ? i2 : 1;
    }
    function h(e2, t2, r2, n2, l2) {
      if (r2.interlaced)
        throw new i("writing interlaced GIFs is not supported");
      const u2 = function(e3, t3, r3) {
        const n3 = r3.colors, s2 = n3.length <= 8 ? a : o, l3 = t3.bitmap.data, u3 = new Buffer2(l3.length / 4);
        let h3 = n3.length, c = 0, f = 0;
        for (;c < l3.length; ) {
          if (l3[c + 3] !== 0) {
            const e4 = l3.readUInt32BE(c, true) >> 8 & 16777215;
            u3[f] = s2(n3, e4);
          } else
            u3[f] = h3;
          c += 4, ++f;
        }
        if (r3.usesTransparency) {
          if (h3 === 256)
            throw new i(`Frame ${e3} already has 256 colorsand so can't use transparency`);
        } else
          h3 = null;
        return { buffer: u3, transparentIndex: h3 };
      }(t2, r2, n2), h2 = { delay: r2.delayCentisecs, disposal: r2.disposalMethod, transparent: u2.transparentIndex };
      l2 && (s(n2), h2.palette = n2.colors);
      try {
        let t3, i2 = e2.getOutputBuffer(), n3 = e2.getOutputBufferPosition(), a2 = true;
        for (;a2; )
          if (t3 = e2.addFrame(r2.xOffset, r2.yOffset, r2.bitmap.width, r2.bitmap.height, u2.buffer, h2), a2 = false, t3 >= i2.length - 1) {
            const t4 = new Buffer2(1.5 * i2.length);
            i2.copy(t4), e2.setOutputBuffer(t4), e2.setOutputBufferPosition(n3), i2 = t4, a2 = true;
          }
        return i2;
      } catch (e3) {
        throw new i(e3);
      }
    }
    return gifcodec.GifCodec = class {
      constructor(e2 = {}) {
        this._transparentRGB = null, typeof e2.transparentRGB == "number" && e2.transparentRGB !== 0 && (this._transparentRGBA = 256 * e2.transparentRGB), this._testInitialBufferSize = 0;
      }
      decodeGif(r2) {
        try {
          let n2;
          try {
            n2 = new e.GifReader(r2);
          } catch (e2) {
            throw new i(e2);
          }
          const a2 = n2.numFrames(), o2 = [], s2 = { width: n2.width, height: n2.height, loops: n2.loopCount(), usesTransparency: false };
          for (let e2 = 0;e2 < a2; ++e2) {
            const t2 = this._decodeFrame(n2, e2, s2.usesTransparency);
            o2.push(t2.frame), t2.usesTransparency && (s2.usesTransparency = true);
          }
          return Promise.resolve(new t(r2, o2, s2));
        } catch (e2) {
          return Promise.reject(e2);
        }
      }
      encodeGif(e2, n2 = {}) {
        try {
          if (e2 === null || e2.length === 0)
            throw new i("there are no frames");
          const a2 = r().getMaxDimensions(e2);
          return (n2 = Object.assign({}, n2)).width = a2.maxWidth, n2.height = a2.maxHeight, n2.loops === undefined && (n2.loops = 0), n2.colorScope = n2.colorScope || t.GlobalColorsPreferred, Promise.resolve(this._encodeGif(e2, n2));
        } catch (e3) {
          return Promise.reject(e3);
        }
      }
      _decodeFrame(e2, t2, r2) {
        let a2, o2;
        try {
          if (a2 = e2.frameInfo(t2), o2 = new Buffer2(e2.width * e2.height * 4), e2.decodeAndBlitFrameRGBA(t2, o2), a2.width !== e2.width || a2.height !== e2.height) {
            if (a2.y && (o2 = o2.slice(a2.y * e2.width * 4)), e2.width > a2.width)
              for (let t3 = 0;t3 < a2.height; ++t3)
                o2.copy(o2, t3 * a2.width * 4, 4 * (a2.x + t3 * e2.width), 4 * (a2.x + t3 * e2.width) + 4 * a2.width);
            o2 = o2.slice(0, a2.width * a2.height * 4);
          }
        } catch (e3) {
          throw new i(e3);
        }
        let s2 = false;
        if (this._transparentRGBA === null) {
          if (!r2)
            for (let e3 = 3;e3 < o2.length; e3 += 4)
              o2[e3] === 0 && (s2 = true, e3 = o2.length);
        } else
          for (let e3 = 3;e3 < o2.length; e3 += 4)
            o2[e3] === 0 && (o2.writeUInt32BE(this._transparentRGBA, e3 - 3), s2 = true);
        return { frame: new n(a2.width, a2.height, o2, { xOffset: a2.x, yOffset: a2.y, disposalMethod: a2.disposal, interlaced: a2.interlaced, delayCentisecs: a2.delay }), usesTransparency: s2 };
      }
      _encodeGif(n2, a2) {
        let o2;
        if (a2.colorScope === t.LocalColorsOnly)
          o2 = r().getColorInfo(n2, 0);
        else if (o2 = r().getColorInfo(n2, 256), !o2.colors) {
          if (a2.colorScope === t.GlobalColorsOnly)
            throw new i("Too many color indexes for global color table");
          a2.colorScope = t.LocalColorsOnly;
        }
        a2.usesTransparency = o2.usesTransparency;
        const l2 = o2.palettes;
        if (a2.colorScope === t.LocalColorsOnly) {
          return function(r2, n3, a3, o3) {
            const s2 = { loop: n3.loops };
            let l3, u2 = new Buffer2(a3);
            try {
              l3 = new e.GifWriter(u2, n3.width, n3.height, s2);
            } catch (e2) {
              throw new i(e2);
            }
            for (let e2 = 0;e2 < r2.length; ++e2)
              u2 = h(l3, e2, r2[e2], o3[e2], true);
            return new t(u2.slice(0, l3.end()), r2, n3);
          }(n2, a2, 2000, l2);
        }
        return function(r2, n3, a3, o3) {
          const l3 = { colors: o3.colors.slice(), usesTransparency: o3.usesTransparency };
          s(l3);
          const u2 = { palette: l3.colors, loop: n3.loops };
          let c, f = new Buffer2(a3);
          try {
            c = new e.GifWriter(f, n3.width, n3.height, u2);
          } catch (e2) {
            throw new i(e2);
          }
          for (let e2 = 0;e2 < r2.length; ++e2)
            f = h(c, e2, r2[e2], o3, false);
          return new t(f.slice(0, c.end()), r2, n3);
        }(n2, a2, 2000, o2);
      }
      _getSizeEstimateGlobal(e2, t2) {
        if (this._testInitialBufferSize > 0)
          return this._testInitialBufferSize;
        let i2 = 968;
        const r2 = u(e2);
        return t2.forEach((e3) => {
          i2 += l(e3, r2);
        }), i2;
      }
      _getSizeEstimateLocal(e2, t2) {
        if (this._testInitialBufferSize > 0)
          return this._testInitialBufferSize;
        let i2 = 200;
        for (let r2 = 0;r2 < t2.length; ++r2) {
          const n2 = u(e2[r2]);
          i2 += l(t2[r2], n2);
        }
        return i2;
      }
    }, gifcodec;
  };
  gif = function() {
    return { mime: "image/gif", encode: async (e) => {
      const t = new src.BitmapImage(e);
      src.GifUtil.quantizeDekker(t, 256);
      const i = new src.GifFrame(e), r = new src.GifCodec;
      return (await r.encodeGif([i], {})).buffer;
    }, decode: (e) => {
      const t = new omggif.GifReader(e), i = Buffer2.alloc(t.width * t.height * 4);
      return t.decodeAndBlitFrameRGBA(0, i), { data: i, width: t.width, height: t.height };
    } };
  };
  jpeg$2 = function() {
    return { mime: "image/jpeg", encode: (e, { quality: t = 100 } = {}) => JPEG.encode(e, t).data, decode: (e, t) => JPEG.decode(e, t) };
  };
  commonjsRequire = function(e) {
    throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  };
  png = function() {
    return { mime: "image/png", hasAlpha: true, encode: (e, { deflateLevel: t = 9, deflateStrategy: i = 3, filterType: r = PNGFilterType.AUTO, colorType: n, inputHasAlpha: a = true, ...o } = {}) => {
      const s = new browserExports.PNG({ width: e.width, height: e.height });
      return s.data = e.data, browserExports.PNG.sync.write(s, { ...o, deflateLevel: t, deflateStrategy: i, filterType: r, colorType: n !== undefined ? n : a ? PNGColorType.COLOR_ALPHA : PNGColorType.COLOR, inputHasAlpha: a });
    }, decode: (e, t) => {
      const i = browserExports.PNG.sync.read(e, t);
      return { data: i.data, width: i.width, height: i.height };
    } };
  };
  requireCommon = function() {
    return hasRequiredCommon || (hasRequiredCommon = 1, function(e) {
      var t = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
      function i(e2, t2) {
        return Object.prototype.hasOwnProperty.call(e2, t2);
      }
      e.assign = function(e2) {
        for (var t2 = Array.prototype.slice.call(arguments, 1);t2.length; ) {
          var r2 = t2.shift();
          if (r2) {
            if (typeof r2 != "object")
              throw new TypeError(r2 + "must be non-object");
            for (var n2 in r2)
              i(r2, n2) && (e2[n2] = r2[n2]);
          }
        }
        return e2;
      }, e.shrinkBuf = function(e2, t2) {
        return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
      };
      var r = { arraySet: function(e2, t2, i2, r2, n2) {
        if (t2.subarray && e2.subarray)
          e2.set(t2.subarray(i2, i2 + r2), n2);
        else
          for (var a = 0;a < r2; a++)
            e2[n2 + a] = t2[i2 + a];
      }, flattenChunks: function(e2) {
        var t2, i2, r2, n2, a, o;
        for (r2 = 0, t2 = 0, i2 = e2.length;t2 < i2; t2++)
          r2 += e2[t2].length;
        for (o = new Uint8Array(r2), n2 = 0, t2 = 0, i2 = e2.length;t2 < i2; t2++)
          a = e2[t2], o.set(a, n2), n2 += a.length;
        return o;
      } }, n = { arraySet: function(e2, t2, i2, r2, n2) {
        for (var a = 0;a < r2; a++)
          e2[n2 + a] = t2[i2 + a];
      }, flattenChunks: function(e2) {
        return [].concat.apply([], e2);
      } };
      e.setTyped = function(t2) {
        t2 ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, r)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, n));
      }, e.setTyped(t);
    }(common)), common;
  };
  requireTrees = function() {
    if (hasRequiredTrees)
      return trees;
    hasRequiredTrees = 1;
    var e = requireCommon(), t = 0, i = 1;
    function r(e2) {
      for (var t2 = e2.length;--t2 >= 0; )
        e2[t2] = 0;
    }
    var n = 0, a = 29, o = 256, s = o + 1 + a, l = 30, u = 19, h = 2 * s + 1, c = 15, f = 16, d = 7, p = 256, m = 16, _ = 17, g = 18, b = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], y = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], v = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], x = new Array(2 * (s + 2));
    r(x);
    var E = new Array(2 * l);
    r(E);
    var k = new Array(512);
    r(k);
    var S = new Array(256);
    r(S);
    var A = new Array(a);
    r(A);
    var I, M, T, P = new Array(l);
    function B(e2, t2, i2, r2, n2) {
      this.static_tree = e2, this.extra_bits = t2, this.extra_base = i2, this.elems = r2, this.max_length = n2, this.has_stree = e2 && e2.length;
    }
    function C(e2, t2) {
      this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
    }
    function R(e2) {
      return e2 < 256 ? k[e2] : k[256 + (e2 >>> 7)];
    }
    function z(e2, t2) {
      e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
    }
    function F(e2, t2, i2) {
      e2.bi_valid > f - i2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, z(e2, e2.bi_buf), e2.bi_buf = t2 >> f - e2.bi_valid, e2.bi_valid += i2 - f) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += i2);
    }
    function N(e2, t2, i2) {
      F(e2, i2[2 * t2], i2[2 * t2 + 1]);
    }
    function O(e2, t2) {
      var i2 = 0;
      do {
        i2 |= 1 & e2, e2 >>>= 1, i2 <<= 1;
      } while (--t2 > 0);
      return i2 >>> 1;
    }
    function D(e2, t2, i2) {
      var r2, n2, a2 = new Array(c + 1), o2 = 0;
      for (r2 = 1;r2 <= c; r2++)
        a2[r2] = o2 = o2 + i2[r2 - 1] << 1;
      for (n2 = 0;n2 <= t2; n2++) {
        var s2 = e2[2 * n2 + 1];
        s2 !== 0 && (e2[2 * n2] = O(a2[s2]++, s2));
      }
    }
    function $(e2) {
      var t2;
      for (t2 = 0;t2 < s; t2++)
        e2.dyn_ltree[2 * t2] = 0;
      for (t2 = 0;t2 < l; t2++)
        e2.dyn_dtree[2 * t2] = 0;
      for (t2 = 0;t2 < u; t2++)
        e2.bl_tree[2 * t2] = 0;
      e2.dyn_ltree[2 * p] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
    }
    function L(e2) {
      e2.bi_valid > 8 ? z(e2, e2.bi_buf) : e2.bi_valid > 0 && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
    }
    function U(e2, t2, i2, r2) {
      var n2 = 2 * t2, a2 = 2 * i2;
      return e2[n2] < e2[a2] || e2[n2] === e2[a2] && r2[t2] <= r2[i2];
    }
    function Z(e2, t2, i2) {
      for (var r2 = e2.heap[i2], n2 = i2 << 1;n2 <= e2.heap_len && (n2 < e2.heap_len && U(t2, e2.heap[n2 + 1], e2.heap[n2], e2.depth) && n2++, !U(t2, r2, e2.heap[n2], e2.depth)); )
        e2.heap[i2] = e2.heap[n2], i2 = n2, n2 <<= 1;
      e2.heap[i2] = r2;
    }
    function j(e2, t2, i2) {
      var r2, n2, a2, s2, l2 = 0;
      if (e2.last_lit !== 0)
        do {
          r2 = e2.pending_buf[e2.d_buf + 2 * l2] << 8 | e2.pending_buf[e2.d_buf + 2 * l2 + 1], n2 = e2.pending_buf[e2.l_buf + l2], l2++, r2 === 0 ? N(e2, n2, t2) : (N(e2, (a2 = S[n2]) + o + 1, t2), (s2 = b[a2]) !== 0 && F(e2, n2 -= A[a2], s2), N(e2, a2 = R(--r2), i2), (s2 = y[a2]) !== 0 && F(e2, r2 -= P[a2], s2));
        } while (l2 < e2.last_lit);
      N(e2, p, t2);
    }
    function G(e2, t2) {
      var i2, r2, n2, a2 = t2.dyn_tree, o2 = t2.stat_desc.static_tree, s2 = t2.stat_desc.has_stree, l2 = t2.stat_desc.elems, u2 = -1;
      for (e2.heap_len = 0, e2.heap_max = h, i2 = 0;i2 < l2; i2++)
        a2[2 * i2] !== 0 ? (e2.heap[++e2.heap_len] = u2 = i2, e2.depth[i2] = 0) : a2[2 * i2 + 1] = 0;
      for (;e2.heap_len < 2; )
        a2[2 * (n2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[n2] = 0, e2.opt_len--, s2 && (e2.static_len -= o2[2 * n2 + 1]);
      for (t2.max_code = u2, i2 = e2.heap_len >> 1;i2 >= 1; i2--)
        Z(e2, a2, i2);
      n2 = l2;
      do {
        i2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], Z(e2, a2, 1), r2 = e2.heap[1], e2.heap[--e2.heap_max] = i2, e2.heap[--e2.heap_max] = r2, a2[2 * n2] = a2[2 * i2] + a2[2 * r2], e2.depth[n2] = (e2.depth[i2] >= e2.depth[r2] ? e2.depth[i2] : e2.depth[r2]) + 1, a2[2 * i2 + 1] = a2[2 * r2 + 1] = n2, e2.heap[1] = n2++, Z(e2, a2, 1);
      } while (e2.heap_len >= 2);
      e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
        var i3, r3, n3, a3, o3, s3, l3 = t3.dyn_tree, u3 = t3.max_code, f2 = t3.stat_desc.static_tree, d2 = t3.stat_desc.has_stree, p2 = t3.stat_desc.extra_bits, m2 = t3.stat_desc.extra_base, _2 = t3.stat_desc.max_length, g2 = 0;
        for (a3 = 0;a3 <= c; a3++)
          e3.bl_count[a3] = 0;
        for (l3[2 * e3.heap[e3.heap_max] + 1] = 0, i3 = e3.heap_max + 1;i3 < h; i3++)
          (a3 = l3[2 * l3[2 * (r3 = e3.heap[i3]) + 1] + 1] + 1) > _2 && (a3 = _2, g2++), l3[2 * r3 + 1] = a3, r3 > u3 || (e3.bl_count[a3]++, o3 = 0, r3 >= m2 && (o3 = p2[r3 - m2]), s3 = l3[2 * r3], e3.opt_len += s3 * (a3 + o3), d2 && (e3.static_len += s3 * (f2[2 * r3 + 1] + o3)));
        if (g2 !== 0) {
          do {
            for (a3 = _2 - 1;e3.bl_count[a3] === 0; )
              a3--;
            e3.bl_count[a3]--, e3.bl_count[a3 + 1] += 2, e3.bl_count[_2]--, g2 -= 2;
          } while (g2 > 0);
          for (a3 = _2;a3 !== 0; a3--)
            for (r3 = e3.bl_count[a3];r3 !== 0; )
              (n3 = e3.heap[--i3]) > u3 || (l3[2 * n3 + 1] !== a3 && (e3.opt_len += (a3 - l3[2 * n3 + 1]) * l3[2 * n3], l3[2 * n3 + 1] = a3), r3--);
        }
      }(e2, t2), D(a2, u2, e2.bl_count);
    }
    function H(e2, t2, i2) {
      var r2, n2, a2 = -1, o2 = t2[1], s2 = 0, l2 = 7, u2 = 4;
      for (o2 === 0 && (l2 = 138, u2 = 3), t2[2 * (i2 + 1) + 1] = 65535, r2 = 0;r2 <= i2; r2++)
        n2 = o2, o2 = t2[2 * (r2 + 1) + 1], ++s2 < l2 && n2 === o2 || (s2 < u2 ? e2.bl_tree[2 * n2] += s2 : n2 !== 0 ? (n2 !== a2 && e2.bl_tree[2 * n2]++, e2.bl_tree[2 * m]++) : s2 <= 10 ? e2.bl_tree[2 * _]++ : e2.bl_tree[2 * g]++, s2 = 0, a2 = n2, o2 === 0 ? (l2 = 138, u2 = 3) : n2 === o2 ? (l2 = 6, u2 = 3) : (l2 = 7, u2 = 4));
    }
    function Q(e2, t2, i2) {
      var r2, n2, a2 = -1, o2 = t2[1], s2 = 0, l2 = 7, u2 = 4;
      for (o2 === 0 && (l2 = 138, u2 = 3), r2 = 0;r2 <= i2; r2++)
        if (n2 = o2, o2 = t2[2 * (r2 + 1) + 1], !(++s2 < l2 && n2 === o2)) {
          if (s2 < u2)
            do {
              N(e2, n2, e2.bl_tree);
            } while (--s2 != 0);
          else
            n2 !== 0 ? (n2 !== a2 && (N(e2, n2, e2.bl_tree), s2--), N(e2, m, e2.bl_tree), F(e2, s2 - 3, 2)) : s2 <= 10 ? (N(e2, _, e2.bl_tree), F(e2, s2 - 3, 3)) : (N(e2, g, e2.bl_tree), F(e2, s2 - 11, 7));
          s2 = 0, a2 = n2, o2 === 0 ? (l2 = 138, u2 = 3) : n2 === o2 ? (l2 = 6, u2 = 3) : (l2 = 7, u2 = 4);
        }
    }
    r(P);
    var W = false;
    function q(t2, i2, r2, a2) {
      F(t2, (n << 1) + (a2 ? 1 : 0), 3), function(t3, i3, r3, n2) {
        L(t3), z(t3, r3), z(t3, ~r3), e.arraySet(t3.pending_buf, t3.window, i3, r3, t3.pending), t3.pending += r3;
      }(t2, i2, r2);
    }
    return trees._tr_init = function(e2) {
      W || (function() {
        var e3, t2, i2, r2, n2, h2 = new Array(c + 1);
        for (i2 = 0, r2 = 0;r2 < a - 1; r2++)
          for (A[r2] = i2, e3 = 0;e3 < 1 << b[r2]; e3++)
            S[i2++] = r2;
        for (S[i2 - 1] = r2, n2 = 0, r2 = 0;r2 < 16; r2++)
          for (P[r2] = n2, e3 = 0;e3 < 1 << y[r2]; e3++)
            k[n2++] = r2;
        for (n2 >>= 7;r2 < l; r2++)
          for (P[r2] = n2 << 7, e3 = 0;e3 < 1 << y[r2] - 7; e3++)
            k[256 + n2++] = r2;
        for (t2 = 0;t2 <= c; t2++)
          h2[t2] = 0;
        for (e3 = 0;e3 <= 143; )
          x[2 * e3 + 1] = 8, e3++, h2[8]++;
        for (;e3 <= 255; )
          x[2 * e3 + 1] = 9, e3++, h2[9]++;
        for (;e3 <= 279; )
          x[2 * e3 + 1] = 7, e3++, h2[7]++;
        for (;e3 <= 287; )
          x[2 * e3 + 1] = 8, e3++, h2[8]++;
        for (D(x, s + 1, h2), e3 = 0;e3 < l; e3++)
          E[2 * e3 + 1] = 5, E[2 * e3] = O(e3, 5);
        I = new B(x, b, o + 1, s, c), M = new B(E, y, 0, l, c), T = new B(new Array(0), w, 0, u, d);
      }(), W = true), e2.l_desc = new C(e2.dyn_ltree, I), e2.d_desc = new C(e2.dyn_dtree, M), e2.bl_desc = new C(e2.bl_tree, T), e2.bi_buf = 0, e2.bi_valid = 0, $(e2);
    }, trees._tr_stored_block = q, trees._tr_flush_block = function(e2, r2, n2, a2) {
      var s2, l2, h2 = 0;
      e2.level > 0 ? (e2.strm.data_type === 2 && (e2.strm.data_type = function(e3) {
        var r3, n3 = 4093624447;
        for (r3 = 0;r3 <= 31; r3++, n3 >>>= 1)
          if (1 & n3 && e3.dyn_ltree[2 * r3] !== 0)
            return t;
        if (e3.dyn_ltree[18] !== 0 || e3.dyn_ltree[20] !== 0 || e3.dyn_ltree[26] !== 0)
          return i;
        for (r3 = 32;r3 < o; r3++)
          if (e3.dyn_ltree[2 * r3] !== 0)
            return i;
        return t;
      }(e2)), G(e2, e2.l_desc), G(e2, e2.d_desc), h2 = function(e3) {
        var t2;
        for (H(e3, e3.dyn_ltree, e3.l_desc.max_code), H(e3, e3.dyn_dtree, e3.d_desc.max_code), G(e3, e3.bl_desc), t2 = u - 1;t2 >= 3 && e3.bl_tree[2 * v[t2] + 1] === 0; t2--)
          ;
        return e3.opt_len += 3 * (t2 + 1) + 5 + 5 + 4, t2;
      }(e2), s2 = e2.opt_len + 3 + 7 >>> 3, (l2 = e2.static_len + 3 + 7 >>> 3) <= s2 && (s2 = l2)) : s2 = l2 = n2 + 5, n2 + 4 <= s2 && r2 !== -1 ? q(e2, r2, n2, a2) : e2.strategy === 4 || l2 === s2 ? (F(e2, 2 + (a2 ? 1 : 0), 3), j(e2, x, E)) : (F(e2, 4 + (a2 ? 1 : 0), 3), function(e3, t2, i2, r3) {
        var n3;
        for (F(e3, t2 - 257, 5), F(e3, i2 - 1, 5), F(e3, r3 - 4, 4), n3 = 0;n3 < r3; n3++)
          F(e3, e3.bl_tree[2 * v[n3] + 1], 3);
        Q(e3, e3.dyn_ltree, t2 - 1), Q(e3, e3.dyn_dtree, i2 - 1);
      }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, h2 + 1), j(e2, e2.dyn_ltree, e2.dyn_dtree)), $(e2), a2 && L(e2);
    }, trees._tr_tally = function(e2, t2, i2) {
      return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & i2, e2.last_lit++, t2 === 0 ? e2.dyn_ltree[2 * i2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (S[i2] + o + 1)]++, e2.dyn_dtree[2 * R(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
    }, trees._tr_align = function(e2) {
      F(e2, 2, 3), N(e2, p, x), function(e3) {
        e3.bi_valid === 16 ? (z(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : e3.bi_valid >= 8 && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
      }(e2);
    }, trees;
  };
  requireAdler32 = function() {
    if (hasRequiredAdler32)
      return adler32_1;
    return hasRequiredAdler32 = 1, adler32_1 = function(e, t, i, r) {
      for (var n = 65535 & e, a = e >>> 16 & 65535, o = 0;i !== 0; ) {
        i -= o = i > 2000 ? 2000 : i;
        do {
          a = a + (n = n + t[r++] | 0) | 0;
        } while (--o);
        n %= 65521, a %= 65521;
      }
      return n | a << 16;
    }, adler32_1;
  };
  requireCrc32 = function() {
    if (hasRequiredCrc32)
      return crc32_1;
    hasRequiredCrc32 = 1;
    var e = function() {
      for (var e2, t = [], i = 0;i < 256; i++) {
        e2 = i;
        for (var r = 0;r < 8; r++)
          e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
        t[i] = e2;
      }
      return t;
    }();
    return crc32_1 = function(t, i, r, n) {
      var a = e, o = n + r;
      t ^= -1;
      for (var s = n;s < o; s++)
        t = t >>> 8 ^ a[255 & (t ^ i[s])];
      return ~t;
    }, crc32_1;
  };
  requireMessages = function() {
    return hasRequiredMessages ? messages : (hasRequiredMessages = 1, messages = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" });
  };
  requireDeflate$1 = function() {
    if (hasRequiredDeflate$1)
      return deflate;
    hasRequiredDeflate$1 = 1;
    var e, t = requireCommon(), i = requireTrees(), r = requireAdler32(), n = requireCrc32(), a = requireMessages(), o = 0, s = 4, l = 0, u = -2, h = -1, c = 4, f = 2, d = 8, p = 9, m = 286, _ = 30, g = 19, b = 2 * m + 1, y = 15, w = 3, v = 258, x = v + w + 1, E = 42, k = 103, S = 113, A = 666, I = 1, M = 2, T = 3, P = 4;
    function B(e2, t2) {
      return e2.msg = a[t2], t2;
    }
    function C(e2) {
      return (e2 << 1) - (e2 > 4 ? 9 : 0);
    }
    function R(e2) {
      for (var t2 = e2.length;--t2 >= 0; )
        e2[t2] = 0;
    }
    function z(e2) {
      var i2 = e2.state, r2 = i2.pending;
      r2 > e2.avail_out && (r2 = e2.avail_out), r2 !== 0 && (t.arraySet(e2.output, i2.pending_buf, i2.pending_out, r2, e2.next_out), e2.next_out += r2, i2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, i2.pending -= r2, i2.pending === 0 && (i2.pending_out = 0));
    }
    function F(e2, t2) {
      i._tr_flush_block(e2, e2.block_start >= 0 ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, z(e2.strm);
    }
    function N(e2, t2) {
      e2.pending_buf[e2.pending++] = t2;
    }
    function O(e2, t2) {
      e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
    }
    function D(e2, t2) {
      var i2, r2, n2 = e2.max_chain_length, a2 = e2.strstart, o2 = e2.prev_length, s2 = e2.nice_match, l2 = e2.strstart > e2.w_size - x ? e2.strstart - (e2.w_size - x) : 0, u2 = e2.window, h2 = e2.w_mask, c2 = e2.prev, f2 = e2.strstart + v, d2 = u2[a2 + o2 - 1], p2 = u2[a2 + o2];
      e2.prev_length >= e2.good_match && (n2 >>= 2), s2 > e2.lookahead && (s2 = e2.lookahead);
      do {
        if (u2[(i2 = t2) + o2] === p2 && u2[i2 + o2 - 1] === d2 && u2[i2] === u2[a2] && u2[++i2] === u2[a2 + 1]) {
          a2 += 2, i2++;
          do {
          } while (u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && a2 < f2);
          if (r2 = v - (f2 - a2), a2 = f2 - v, r2 > o2) {
            if (e2.match_start = t2, o2 = r2, r2 >= s2)
              break;
            d2 = u2[a2 + o2 - 1], p2 = u2[a2 + o2];
          }
        }
      } while ((t2 = c2[t2 & h2]) > l2 && --n2 != 0);
      return o2 <= e2.lookahead ? o2 : e2.lookahead;
    }
    function $(e2) {
      var i2, a2, o2, s2, l2, u2, h2, c2, f2, d2, p2 = e2.w_size;
      do {
        if (s2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= p2 + (p2 - x)) {
          t.arraySet(e2.window, e2.window, p2, p2, 0), e2.match_start -= p2, e2.strstart -= p2, e2.block_start -= p2, i2 = a2 = e2.hash_size;
          do {
            o2 = e2.head[--i2], e2.head[i2] = o2 >= p2 ? o2 - p2 : 0;
          } while (--a2);
          i2 = a2 = p2;
          do {
            o2 = e2.prev[--i2], e2.prev[i2] = o2 >= p2 ? o2 - p2 : 0;
          } while (--a2);
          s2 += p2;
        }
        if (e2.strm.avail_in === 0)
          break;
        if (u2 = e2.strm, h2 = e2.window, c2 = e2.strstart + e2.lookahead, f2 = s2, d2 = undefined, (d2 = u2.avail_in) > f2 && (d2 = f2), a2 = d2 === 0 ? 0 : (u2.avail_in -= d2, t.arraySet(h2, u2.input, u2.next_in, d2, c2), u2.state.wrap === 1 ? u2.adler = r(u2.adler, h2, d2, c2) : u2.state.wrap === 2 && (u2.adler = n(u2.adler, h2, d2, c2)), u2.next_in += d2, u2.total_in += d2, d2), e2.lookahead += a2, e2.lookahead + e2.insert >= w)
          for (l2 = e2.strstart - e2.insert, e2.ins_h = e2.window[l2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[l2 + 1]) & e2.hash_mask;e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[l2 + w - 1]) & e2.hash_mask, e2.prev[l2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = l2, l2++, e2.insert--, !(e2.lookahead + e2.insert < w)); )
            ;
      } while (e2.lookahead < x && e2.strm.avail_in !== 0);
    }
    function L(e2, t2) {
      for (var r2, n2;; ) {
        if (e2.lookahead < x) {
          if ($(e2), e2.lookahead < x && t2 === o)
            return I;
          if (e2.lookahead === 0)
            break;
        }
        if (r2 = 0, e2.lookahead >= w && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + w - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), r2 !== 0 && e2.strstart - r2 <= e2.w_size - x && (e2.match_length = D(e2, r2)), e2.match_length >= w)
          if (n2 = i._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - w), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= w) {
            e2.match_length--;
            do {
              e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + w - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart;
            } while (--e2.match_length != 0);
            e2.strstart++;
          } else
            e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
        else
          n2 = i._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
        if (n2 && (F(e2, false), e2.strm.avail_out === 0))
          return I;
      }
      return e2.insert = e2.strstart < w - 1 ? e2.strstart : w - 1, t2 === s ? (F(e2, true), e2.strm.avail_out === 0 ? T : P) : e2.last_lit && (F(e2, false), e2.strm.avail_out === 0) ? I : M;
    }
    function U(e2, t2) {
      for (var r2, n2, a2;; ) {
        if (e2.lookahead < x) {
          if ($(e2), e2.lookahead < x && t2 === o)
            return I;
          if (e2.lookahead === 0)
            break;
        }
        if (r2 = 0, e2.lookahead >= w && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + w - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = w - 1, r2 !== 0 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - x && (e2.match_length = D(e2, r2), e2.match_length <= 5 && (e2.strategy === 1 || e2.match_length === w && e2.strstart - e2.match_start > 4096) && (e2.match_length = w - 1)), e2.prev_length >= w && e2.match_length <= e2.prev_length) {
          a2 = e2.strstart + e2.lookahead - w, n2 = i._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - w), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2;
          do {
            ++e2.strstart <= a2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + w - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart);
          } while (--e2.prev_length != 0);
          if (e2.match_available = 0, e2.match_length = w - 1, e2.strstart++, n2 && (F(e2, false), e2.strm.avail_out === 0))
            return I;
        } else if (e2.match_available) {
          if ((n2 = i._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && F(e2, false), e2.strstart++, e2.lookahead--, e2.strm.avail_out === 0)
            return I;
        } else
          e2.match_available = 1, e2.strstart++, e2.lookahead--;
      }
      return e2.match_available && (n2 = i._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < w - 1 ? e2.strstart : w - 1, t2 === s ? (F(e2, true), e2.strm.avail_out === 0 ? T : P) : e2.last_lit && (F(e2, false), e2.strm.avail_out === 0) ? I : M;
    }
    function Z(e2, t2, i2, r2, n2) {
      this.good_length = e2, this.max_lazy = t2, this.nice_length = i2, this.max_chain = r2, this.func = n2;
    }
    function j() {
      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = d, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new t.Buf16(2 * b), this.dyn_dtree = new t.Buf16(2 * (2 * _ + 1)), this.bl_tree = new t.Buf16(2 * (2 * g + 1)), R(this.dyn_ltree), R(this.dyn_dtree), R(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new t.Buf16(y + 1), this.heap = new t.Buf16(2 * m + 1), R(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new t.Buf16(2 * m + 1), R(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
    }
    function G(e2) {
      var t2;
      return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = f, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? E : S, e2.adler = t2.wrap === 2 ? 0 : 1, t2.last_flush = o, i._tr_init(t2), l) : B(e2, u);
    }
    function H(t2) {
      var i2 = G(t2);
      return i2 === l && function(t3) {
        t3.window_size = 2 * t3.w_size, R(t3.head), t3.max_lazy_match = e[t3.level].max_lazy, t3.good_match = e[t3.level].good_length, t3.nice_match = e[t3.level].nice_length, t3.max_chain_length = e[t3.level].max_chain, t3.strstart = 0, t3.block_start = 0, t3.lookahead = 0, t3.insert = 0, t3.match_length = t3.prev_length = w - 1, t3.match_available = 0, t3.ins_h = 0;
      }(t2.state), i2;
    }
    function Q(e2, i2, r2, n2, a2, o2) {
      if (!e2)
        return u;
      var s2 = 1;
      if (i2 === h && (i2 = 6), n2 < 0 ? (s2 = 0, n2 = -n2) : n2 > 15 && (s2 = 2, n2 -= 16), a2 < 1 || a2 > p || r2 !== d || n2 < 8 || n2 > 15 || i2 < 0 || i2 > 9 || o2 < 0 || o2 > c)
        return B(e2, u);
      n2 === 8 && (n2 = 9);
      var l2 = new j;
      return e2.state = l2, l2.strm = e2, l2.wrap = s2, l2.gzhead = null, l2.w_bits = n2, l2.w_size = 1 << l2.w_bits, l2.w_mask = l2.w_size - 1, l2.hash_bits = a2 + 7, l2.hash_size = 1 << l2.hash_bits, l2.hash_mask = l2.hash_size - 1, l2.hash_shift = ~~((l2.hash_bits + w - 1) / w), l2.window = new t.Buf8(2 * l2.w_size), l2.head = new t.Buf16(l2.hash_size), l2.prev = new t.Buf16(l2.w_size), l2.lit_bufsize = 1 << a2 + 6, l2.pending_buf_size = 4 * l2.lit_bufsize, l2.pending_buf = new t.Buf8(l2.pending_buf_size), l2.d_buf = 1 * l2.lit_bufsize, l2.l_buf = 3 * l2.lit_bufsize, l2.level = i2, l2.strategy = o2, l2.method = r2, H(e2);
    }
    return e = [new Z(0, 0, 0, 0, function(e2, t2) {
      var i2 = 65535;
      for (i2 > e2.pending_buf_size - 5 && (i2 = e2.pending_buf_size - 5);; ) {
        if (e2.lookahead <= 1) {
          if ($(e2), e2.lookahead === 0 && t2 === o)
            return I;
          if (e2.lookahead === 0)
            break;
        }
        e2.strstart += e2.lookahead, e2.lookahead = 0;
        var r2 = e2.block_start + i2;
        if ((e2.strstart === 0 || e2.strstart >= r2) && (e2.lookahead = e2.strstart - r2, e2.strstart = r2, F(e2, false), e2.strm.avail_out === 0))
          return I;
        if (e2.strstart - e2.block_start >= e2.w_size - x && (F(e2, false), e2.strm.avail_out === 0))
          return I;
      }
      return e2.insert = 0, t2 === s ? (F(e2, true), e2.strm.avail_out === 0 ? T : P) : (e2.strstart > e2.block_start && (F(e2, false), e2.strm.avail_out), I);
    }), new Z(4, 4, 8, 4, L), new Z(4, 5, 16, 8, L), new Z(4, 6, 32, 32, L), new Z(4, 4, 16, 16, U), new Z(8, 16, 32, 32, U), new Z(8, 16, 128, 128, U), new Z(8, 32, 128, 256, U), new Z(32, 128, 258, 1024, U), new Z(32, 258, 258, 4096, U)], deflate.deflateInit = function(e2, t2) {
      return Q(e2, t2, d, 15, 8, 0);
    }, deflate.deflateInit2 = Q, deflate.deflateReset = H, deflate.deflateResetKeep = G, deflate.deflateSetHeader = function(e2, t2) {
      return e2 && e2.state ? e2.state.wrap !== 2 ? u : (e2.state.gzhead = t2, l) : u;
    }, deflate.deflate = function(t2, r2) {
      var a2, h2, c2, f2;
      if (!t2 || !t2.state || r2 > 5 || r2 < 0)
        return t2 ? B(t2, u) : u;
      if (h2 = t2.state, !t2.output || !t2.input && t2.avail_in !== 0 || h2.status === A && r2 !== s)
        return B(t2, t2.avail_out === 0 ? -5 : u);
      if (h2.strm = t2, a2 = h2.last_flush, h2.last_flush = r2, h2.status === E)
        if (h2.wrap === 2)
          t2.adler = 0, N(h2, 31), N(h2, 139), N(h2, 8), h2.gzhead ? (N(h2, (h2.gzhead.text ? 1 : 0) + (h2.gzhead.hcrc ? 2 : 0) + (h2.gzhead.extra ? 4 : 0) + (h2.gzhead.name ? 8 : 0) + (h2.gzhead.comment ? 16 : 0)), N(h2, 255 & h2.gzhead.time), N(h2, h2.gzhead.time >> 8 & 255), N(h2, h2.gzhead.time >> 16 & 255), N(h2, h2.gzhead.time >> 24 & 255), N(h2, h2.level === 9 ? 2 : h2.strategy >= 2 || h2.level < 2 ? 4 : 0), N(h2, 255 & h2.gzhead.os), h2.gzhead.extra && h2.gzhead.extra.length && (N(h2, 255 & h2.gzhead.extra.length), N(h2, h2.gzhead.extra.length >> 8 & 255)), h2.gzhead.hcrc && (t2.adler = n(t2.adler, h2.pending_buf, h2.pending, 0)), h2.gzindex = 0, h2.status = 69) : (N(h2, 0), N(h2, 0), N(h2, 0), N(h2, 0), N(h2, 0), N(h2, h2.level === 9 ? 2 : h2.strategy >= 2 || h2.level < 2 ? 4 : 0), N(h2, 3), h2.status = S);
        else {
          var p2 = d + (h2.w_bits - 8 << 4) << 8;
          p2 |= (h2.strategy >= 2 || h2.level < 2 ? 0 : h2.level < 6 ? 1 : h2.level === 6 ? 2 : 3) << 6, h2.strstart !== 0 && (p2 |= 32), p2 += 31 - p2 % 31, h2.status = S, O(h2, p2), h2.strstart !== 0 && (O(h2, t2.adler >>> 16), O(h2, 65535 & t2.adler)), t2.adler = 1;
        }
      if (h2.status === 69)
        if (h2.gzhead.extra) {
          for (c2 = h2.pending;h2.gzindex < (65535 & h2.gzhead.extra.length) && (h2.pending !== h2.pending_buf_size || (h2.gzhead.hcrc && h2.pending > c2 && (t2.adler = n(t2.adler, h2.pending_buf, h2.pending - c2, c2)), z(t2), c2 = h2.pending, h2.pending !== h2.pending_buf_size)); )
            N(h2, 255 & h2.gzhead.extra[h2.gzindex]), h2.gzindex++;
          h2.gzhead.hcrc && h2.pending > c2 && (t2.adler = n(t2.adler, h2.pending_buf, h2.pending - c2, c2)), h2.gzindex === h2.gzhead.extra.length && (h2.gzindex = 0, h2.status = 73);
        } else
          h2.status = 73;
      if (h2.status === 73)
        if (h2.gzhead.name) {
          c2 = h2.pending;
          do {
            if (h2.pending === h2.pending_buf_size && (h2.gzhead.hcrc && h2.pending > c2 && (t2.adler = n(t2.adler, h2.pending_buf, h2.pending - c2, c2)), z(t2), c2 = h2.pending, h2.pending === h2.pending_buf_size)) {
              f2 = 1;
              break;
            }
            f2 = h2.gzindex < h2.gzhead.name.length ? 255 & h2.gzhead.name.charCodeAt(h2.gzindex++) : 0, N(h2, f2);
          } while (f2 !== 0);
          h2.gzhead.hcrc && h2.pending > c2 && (t2.adler = n(t2.adler, h2.pending_buf, h2.pending - c2, c2)), f2 === 0 && (h2.gzindex = 0, h2.status = 91);
        } else
          h2.status = 91;
      if (h2.status === 91)
        if (h2.gzhead.comment) {
          c2 = h2.pending;
          do {
            if (h2.pending === h2.pending_buf_size && (h2.gzhead.hcrc && h2.pending > c2 && (t2.adler = n(t2.adler, h2.pending_buf, h2.pending - c2, c2)), z(t2), c2 = h2.pending, h2.pending === h2.pending_buf_size)) {
              f2 = 1;
              break;
            }
            f2 = h2.gzindex < h2.gzhead.comment.length ? 255 & h2.gzhead.comment.charCodeAt(h2.gzindex++) : 0, N(h2, f2);
          } while (f2 !== 0);
          h2.gzhead.hcrc && h2.pending > c2 && (t2.adler = n(t2.adler, h2.pending_buf, h2.pending - c2, c2)), f2 === 0 && (h2.status = k);
        } else
          h2.status = k;
      if (h2.status === k && (h2.gzhead.hcrc ? (h2.pending + 2 > h2.pending_buf_size && z(t2), h2.pending + 2 <= h2.pending_buf_size && (N(h2, 255 & t2.adler), N(h2, t2.adler >> 8 & 255), t2.adler = 0, h2.status = S)) : h2.status = S), h2.pending !== 0) {
        if (z(t2), t2.avail_out === 0)
          return h2.last_flush = -1, l;
      } else if (t2.avail_in === 0 && C(r2) <= C(a2) && r2 !== s)
        return B(t2, -5);
      if (h2.status === A && t2.avail_in !== 0)
        return B(t2, -5);
      if (t2.avail_in !== 0 || h2.lookahead !== 0 || r2 !== o && h2.status !== A) {
        var m2 = h2.strategy === 2 ? function(e2, t3) {
          for (var r3;; ) {
            if (e2.lookahead === 0 && ($(e2), e2.lookahead === 0)) {
              if (t3 === o)
                return I;
              break;
            }
            if (e2.match_length = 0, r3 = i._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++, r3 && (F(e2, false), e2.strm.avail_out === 0))
              return I;
          }
          return e2.insert = 0, t3 === s ? (F(e2, true), e2.strm.avail_out === 0 ? T : P) : e2.last_lit && (F(e2, false), e2.strm.avail_out === 0) ? I : M;
        }(h2, r2) : h2.strategy === 3 ? function(e2, t3) {
          for (var r3, n2, a3, l2, u2 = e2.window;; ) {
            if (e2.lookahead <= v) {
              if ($(e2), e2.lookahead <= v && t3 === o)
                return I;
              if (e2.lookahead === 0)
                break;
            }
            if (e2.match_length = 0, e2.lookahead >= w && e2.strstart > 0 && (n2 = u2[a3 = e2.strstart - 1]) === u2[++a3] && n2 === u2[++a3] && n2 === u2[++a3]) {
              l2 = e2.strstart + v;
              do {
              } while (n2 === u2[++a3] && n2 === u2[++a3] && n2 === u2[++a3] && n2 === u2[++a3] && n2 === u2[++a3] && n2 === u2[++a3] && n2 === u2[++a3] && n2 === u2[++a3] && a3 < l2);
              e2.match_length = v - (l2 - a3), e2.match_length > e2.lookahead && (e2.match_length = e2.lookahead);
            }
            if (e2.match_length >= w ? (r3 = i._tr_tally(e2, 1, e2.match_length - w), e2.lookahead -= e2.match_length, e2.strstart += e2.match_length, e2.match_length = 0) : (r3 = i._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++), r3 && (F(e2, false), e2.strm.avail_out === 0))
              return I;
          }
          return e2.insert = 0, t3 === s ? (F(e2, true), e2.strm.avail_out === 0 ? T : P) : e2.last_lit && (F(e2, false), e2.strm.avail_out === 0) ? I : M;
        }(h2, r2) : e[h2.level].func(h2, r2);
        if (m2 !== T && m2 !== P || (h2.status = A), m2 === I || m2 === T)
          return t2.avail_out === 0 && (h2.last_flush = -1), l;
        if (m2 === M && (r2 === 1 ? i._tr_align(h2) : r2 !== 5 && (i._tr_stored_block(h2, 0, 0, false), r2 === 3 && (R(h2.head), h2.lookahead === 0 && (h2.strstart = 0, h2.block_start = 0, h2.insert = 0))), z(t2), t2.avail_out === 0))
          return h2.last_flush = -1, l;
      }
      return r2 !== s ? l : h2.wrap <= 0 ? 1 : (h2.wrap === 2 ? (N(h2, 255 & t2.adler), N(h2, t2.adler >> 8 & 255), N(h2, t2.adler >> 16 & 255), N(h2, t2.adler >> 24 & 255), N(h2, 255 & t2.total_in), N(h2, t2.total_in >> 8 & 255), N(h2, t2.total_in >> 16 & 255), N(h2, t2.total_in >> 24 & 255)) : (O(h2, t2.adler >>> 16), O(h2, 65535 & t2.adler)), z(t2), h2.wrap > 0 && (h2.wrap = -h2.wrap), h2.pending !== 0 ? l : 1);
    }, deflate.deflateEnd = function(e2) {
      var t2;
      return e2 && e2.state ? (t2 = e2.state.status) !== E && t2 !== 69 && t2 !== 73 && t2 !== 91 && t2 !== k && t2 !== S && t2 !== A ? B(e2, u) : (e2.state = null, t2 === S ? B(e2, -3) : l) : u;
    }, deflate.deflateSetDictionary = function(e2, i2) {
      var n2, a2, o2, s2, h2, c2, f2, d2, p2 = i2.length;
      if (!e2 || !e2.state)
        return u;
      if ((s2 = (n2 = e2.state).wrap) === 2 || s2 === 1 && n2.status !== E || n2.lookahead)
        return u;
      for (s2 === 1 && (e2.adler = r(e2.adler, i2, p2, 0)), n2.wrap = 0, p2 >= n2.w_size && (s2 === 0 && (R(n2.head), n2.strstart = 0, n2.block_start = 0, n2.insert = 0), d2 = new t.Buf8(n2.w_size), t.arraySet(d2, i2, p2 - n2.w_size, n2.w_size, 0), i2 = d2, p2 = n2.w_size), h2 = e2.avail_in, c2 = e2.next_in, f2 = e2.input, e2.avail_in = p2, e2.next_in = 0, e2.input = i2, $(n2);n2.lookahead >= w; ) {
        a2 = n2.strstart, o2 = n2.lookahead - (w - 1);
        do {
          n2.ins_h = (n2.ins_h << n2.hash_shift ^ n2.window[a2 + w - 1]) & n2.hash_mask, n2.prev[a2 & n2.w_mask] = n2.head[n2.ins_h], n2.head[n2.ins_h] = a2, a2++;
        } while (--o2);
        n2.strstart = a2, n2.lookahead = w - 1, $(n2);
      }
      return n2.strstart += n2.lookahead, n2.block_start = n2.strstart, n2.insert = n2.lookahead, n2.lookahead = 0, n2.match_length = n2.prev_length = w - 1, n2.match_available = 0, e2.next_in = c2, e2.input = f2, e2.avail_in = h2, n2.wrap = s2, l;
    }, deflate.deflateInfo = "pako deflate (from Nodeca project)", deflate;
  };
  requireStrings = function() {
    if (hasRequiredStrings)
      return strings;
    hasRequiredStrings = 1;
    var e = requireCommon(), t = true, i = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (e2) {
      t = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (e2) {
      i = false;
    }
    for (var r = new e.Buf8(256), n = 0;n < 256; n++)
      r[n] = n >= 252 ? 6 : n >= 248 ? 5 : n >= 240 ? 4 : n >= 224 ? 3 : n >= 192 ? 2 : 1;
    function a(r2, n2) {
      if (n2 < 65534 && (r2.subarray && i || !r2.subarray && t))
        return String.fromCharCode.apply(null, e.shrinkBuf(r2, n2));
      for (var a2 = "", o = 0;o < n2; o++)
        a2 += String.fromCharCode(r2[o]);
      return a2;
    }
    return r[254] = r[254] = 1, strings.string2buf = function(t2) {
      var i2, r2, n2, a2, o, s = t2.length, l = 0;
      for (a2 = 0;a2 < s; a2++)
        (64512 & (r2 = t2.charCodeAt(a2))) == 55296 && a2 + 1 < s && (64512 & (n2 = t2.charCodeAt(a2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), a2++), l += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
      for (i2 = new e.Buf8(l), o = 0, a2 = 0;o < l; a2++)
        (64512 & (r2 = t2.charCodeAt(a2))) == 55296 && a2 + 1 < s && (64512 & (n2 = t2.charCodeAt(a2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), a2++), r2 < 128 ? i2[o++] = r2 : r2 < 2048 ? (i2[o++] = 192 | r2 >>> 6, i2[o++] = 128 | 63 & r2) : r2 < 65536 ? (i2[o++] = 224 | r2 >>> 12, i2[o++] = 128 | r2 >>> 6 & 63, i2[o++] = 128 | 63 & r2) : (i2[o++] = 240 | r2 >>> 18, i2[o++] = 128 | r2 >>> 12 & 63, i2[o++] = 128 | r2 >>> 6 & 63, i2[o++] = 128 | 63 & r2);
      return i2;
    }, strings.buf2binstring = function(e2) {
      return a(e2, e2.length);
    }, strings.binstring2buf = function(t2) {
      for (var i2 = new e.Buf8(t2.length), r2 = 0, n2 = i2.length;r2 < n2; r2++)
        i2[r2] = t2.charCodeAt(r2);
      return i2;
    }, strings.buf2string = function(e2, t2) {
      var i2, n2, o, s, l = t2 || e2.length, u = new Array(2 * l);
      for (n2 = 0, i2 = 0;i2 < l; )
        if ((o = e2[i2++]) < 128)
          u[n2++] = o;
        else if ((s = r[o]) > 4)
          u[n2++] = 65533, i2 += s - 1;
        else {
          for (o &= s === 2 ? 31 : s === 3 ? 15 : 7;s > 1 && i2 < l; )
            o = o << 6 | 63 & e2[i2++], s--;
          s > 1 ? u[n2++] = 65533 : o < 65536 ? u[n2++] = o : (o -= 65536, u[n2++] = 55296 | o >> 10 & 1023, u[n2++] = 56320 | 1023 & o);
        }
      return a(u, n2);
    }, strings.utf8border = function(e2, t2) {
      var i2;
      for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), i2 = t2 - 1;i2 >= 0 && (192 & e2[i2]) == 128; )
        i2--;
      return i2 < 0 || i2 === 0 ? t2 : i2 + r[e2[i2]] > t2 ? i2 : t2;
    }, strings;
  };
  requireZstream = function() {
    if (hasRequiredZstream)
      return zstream;
    return hasRequiredZstream = 1, zstream = function() {
      this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
    };
  };
  requireDeflate = function() {
    if (hasRequiredDeflate)
      return deflate$1;
    hasRequiredDeflate = 1;
    var e = requireDeflate$1(), t = requireCommon(), i = requireStrings(), r = requireMessages(), n = requireZstream(), a = Object.prototype.toString, o = 0, s = -1, l = 0, u = 8;
    function h(c2) {
      if (!(this instanceof h))
        return new h(c2);
      this.options = t.assign({ level: s, method: u, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: l, to: "" }, c2 || {});
      var f = this.options;
      f.raw && f.windowBits > 0 ? f.windowBits = -f.windowBits : f.gzip && f.windowBits > 0 && f.windowBits < 16 && (f.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new n, this.strm.avail_out = 0;
      var d = e.deflateInit2(this.strm, f.level, f.method, f.windowBits, f.memLevel, f.strategy);
      if (d !== o)
        throw new Error(r[d]);
      if (f.header && e.deflateSetHeader(this.strm, f.header), f.dictionary) {
        var p;
        if (p = typeof f.dictionary == "string" ? i.string2buf(f.dictionary) : a.call(f.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(f.dictionary) : f.dictionary, (d = e.deflateSetDictionary(this.strm, p)) !== o)
          throw new Error(r[d]);
        this._dict_set = true;
      }
    }
    function c(e2, t2) {
      var i2 = new h(t2);
      if (i2.push(e2, true), i2.err)
        throw i2.msg || r[i2.err];
      return i2.result;
    }
    return h.prototype.push = function(r2, n2) {
      var s2, l2, u2 = this.strm, h2 = this.options.chunkSize;
      if (this.ended)
        return false;
      l2 = n2 === ~~n2 ? n2 : n2 === true ? 4 : 0, typeof r2 == "string" ? u2.input = i.string2buf(r2) : a.call(r2) === "[object ArrayBuffer]" ? u2.input = new Uint8Array(r2) : u2.input = r2, u2.next_in = 0, u2.avail_in = u2.input.length;
      do {
        if (u2.avail_out === 0 && (u2.output = new t.Buf8(h2), u2.next_out = 0, u2.avail_out = h2), (s2 = e.deflate(u2, l2)) !== 1 && s2 !== o)
          return this.onEnd(s2), this.ended = true, false;
        u2.avail_out !== 0 && (u2.avail_in !== 0 || l2 !== 4 && l2 !== 2) || (this.options.to === "string" ? this.onData(i.buf2binstring(t.shrinkBuf(u2.output, u2.next_out))) : this.onData(t.shrinkBuf(u2.output, u2.next_out)));
      } while ((u2.avail_in > 0 || u2.avail_out === 0) && s2 !== 1);
      return l2 === 4 ? (s2 = e.deflateEnd(this.strm), this.onEnd(s2), this.ended = true, s2 === o) : l2 !== 2 || (this.onEnd(o), u2.avail_out = 0, true);
    }, h.prototype.onData = function(e2) {
      this.chunks.push(e2);
    }, h.prototype.onEnd = function(e2) {
      e2 === o && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = t.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
    }, deflate$1.Deflate = h, deflate$1.deflate = c, deflate$1.deflateRaw = function(e2, t2) {
      return (t2 = t2 || {}).raw = true, c(e2, t2);
    }, deflate$1.gzip = function(e2, t2) {
      return (t2 = t2 || {}).gzip = true, c(e2, t2);
    }, deflate$1;
  };
  requireInffast = function() {
    if (hasRequiredInffast)
      return inffast;
    hasRequiredInffast = 1;
    return inffast = function(e, t) {
      var i, r, n, a, o, s, l, u, h, c, f, d, p, m, _, g, b, y, w, v, x, E, k, S, A;
      i = e.state, r = e.next_in, S = e.input, n = r + (e.avail_in - 5), a = e.next_out, A = e.output, o = a - (t - e.avail_out), s = a + (e.avail_out - 257), l = i.dmax, u = i.wsize, h = i.whave, c = i.wnext, f = i.window, d = i.hold, p = i.bits, m = i.lencode, _ = i.distcode, g = (1 << i.lenbits) - 1, b = (1 << i.distbits) - 1;
      e:
        do {
          p < 15 && (d += S[r++] << p, p += 8, d += S[r++] << p, p += 8), y = m[d & g];
          t:
            for (;; ) {
              if (d >>>= w = y >>> 24, p -= w, (w = y >>> 16 & 255) === 0)
                A[a++] = 65535 & y;
              else {
                if (!(16 & w)) {
                  if (64 & w) {
                    if (32 & w) {
                      i.mode = 12;
                      break e;
                    }
                    e.msg = "invalid literal/length code", i.mode = 30;
                    break e;
                  }
                  y = m[(65535 & y) + (d & (1 << w) - 1)];
                  continue t;
                }
                for (v = 65535 & y, (w &= 15) && (p < w && (d += S[r++] << p, p += 8), v += d & (1 << w) - 1, d >>>= w, p -= w), p < 15 && (d += S[r++] << p, p += 8, d += S[r++] << p, p += 8), y = _[d & b];; ) {
                  if (d >>>= w = y >>> 24, p -= w, 16 & (w = y >>> 16 & 255)) {
                    if (x = 65535 & y, p < (w &= 15) && (d += S[r++] << p, (p += 8) < w && (d += S[r++] << p, p += 8)), (x += d & (1 << w) - 1) > l) {
                      e.msg = "invalid distance too far back", i.mode = 30;
                      break e;
                    }
                    if (d >>>= w, p -= w, x > (w = a - o)) {
                      if ((w = x - w) > h && i.sane) {
                        e.msg = "invalid distance too far back", i.mode = 30;
                        break e;
                      }
                      if (E = 0, k = f, c === 0) {
                        if (E += u - w, w < v) {
                          v -= w;
                          do {
                            A[a++] = f[E++];
                          } while (--w);
                          E = a - x, k = A;
                        }
                      } else if (c < w) {
                        if (E += u + c - w, (w -= c) < v) {
                          v -= w;
                          do {
                            A[a++] = f[E++];
                          } while (--w);
                          if (E = 0, c < v) {
                            v -= w = c;
                            do {
                              A[a++] = f[E++];
                            } while (--w);
                            E = a - x, k = A;
                          }
                        }
                      } else if (E += c - w, w < v) {
                        v -= w;
                        do {
                          A[a++] = f[E++];
                        } while (--w);
                        E = a - x, k = A;
                      }
                      for (;v > 2; )
                        A[a++] = k[E++], A[a++] = k[E++], A[a++] = k[E++], v -= 3;
                      v && (A[a++] = k[E++], v > 1 && (A[a++] = k[E++]));
                    } else {
                      E = a - x;
                      do {
                        A[a++] = A[E++], A[a++] = A[E++], A[a++] = A[E++], v -= 3;
                      } while (v > 2);
                      v && (A[a++] = A[E++], v > 1 && (A[a++] = A[E++]));
                    }
                    break;
                  }
                  if (64 & w) {
                    e.msg = "invalid distance code", i.mode = 30;
                    break e;
                  }
                  y = _[(65535 & y) + (d & (1 << w) - 1)];
                }
              }
              break;
            }
        } while (r < n && a < s);
      r -= v = p >> 3, d &= (1 << (p -= v << 3)) - 1, e.next_in = r, e.next_out = a, e.avail_in = r < n ? n - r + 5 : 5 - (r - n), e.avail_out = a < s ? s - a + 257 : 257 - (a - s), i.hold = d, i.bits = p;
    }, inffast;
  };
  requireInftrees = function() {
    if (hasRequiredInftrees)
      return inftrees;
    hasRequiredInftrees = 1;
    var e = requireCommon(), t = 15, i = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], r = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], n = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], a = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
    return inftrees = function(o, s, l, u, h, c, f, d) {
      var p, m, _, g, b, y, w, v, x, E = d.bits, k = 0, S = 0, A = 0, I = 0, M = 0, T = 0, P = 0, B = 0, C = 0, R = 0, z = null, F = 0, N = new e.Buf16(16), O = new e.Buf16(16), D = null, $ = 0;
      for (k = 0;k <= t; k++)
        N[k] = 0;
      for (S = 0;S < u; S++)
        N[s[l + S]]++;
      for (M = E, I = t;I >= 1 && N[I] === 0; I--)
        ;
      if (M > I && (M = I), I === 0)
        return h[c++] = 20971520, h[c++] = 20971520, d.bits = 1, 0;
      for (A = 1;A < I && N[A] === 0; A++)
        ;
      for (M < A && (M = A), B = 1, k = 1;k <= t; k++)
        if (B <<= 1, (B -= N[k]) < 0)
          return -1;
      if (B > 0 && (o === 0 || I !== 1))
        return -1;
      for (O[1] = 0, k = 1;k < t; k++)
        O[k + 1] = O[k] + N[k];
      for (S = 0;S < u; S++)
        s[l + S] !== 0 && (f[O[s[l + S]]++] = S);
      if (o === 0 ? (z = D = f, y = 19) : o === 1 ? (z = i, F -= 257, D = r, $ -= 257, y = 256) : (z = n, D = a, y = -1), R = 0, S = 0, k = A, b = c, T = M, P = 0, _ = -1, g = (C = 1 << M) - 1, o === 1 && C > 852 || o === 2 && C > 592)
        return 1;
      for (;; ) {
        w = k - P, f[S] < y ? (v = 0, x = f[S]) : f[S] > y ? (v = D[$ + f[S]], x = z[F + f[S]]) : (v = 96, x = 0), p = 1 << k - P, A = m = 1 << T;
        do {
          h[b + (R >> P) + (m -= p)] = w << 24 | v << 16 | x;
        } while (m !== 0);
        for (p = 1 << k - 1;R & p; )
          p >>= 1;
        if (p !== 0 ? (R &= p - 1, R += p) : R = 0, S++, --N[k] == 0) {
          if (k === I)
            break;
          k = s[l + f[S]];
        }
        if (k > M && (R & g) !== _) {
          for (P === 0 && (P = M), b += A, B = 1 << (T = k - P);T + P < I && !((B -= N[T + P]) <= 0); )
            T++, B <<= 1;
          if (C += 1 << T, o === 1 && C > 852 || o === 2 && C > 592)
            return 1;
          h[_ = R & g] = M << 24 | T << 16 | b - c;
        }
      }
      return R !== 0 && (h[b + R] = k - P << 24 | 64 << 16), d.bits = M, 0;
    };
  };
  requireInflate$1 = function() {
    if (hasRequiredInflate$1)
      return inflate;
    hasRequiredInflate$1 = 1;
    var e = requireCommon(), t = requireAdler32(), i = requireCrc32(), r = requireInffast(), n = requireInftrees(), a = 1, o = 2, s = 0, l = -2, u = 1, h = 12, c = 30, f = 852, d = 592;
    function p(e2) {
      return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
    }
    function m() {
      this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new e.Buf16(320), this.work = new e.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
    }
    function _(t2) {
      var i2;
      return t2 && t2.state ? (i2 = t2.state, t2.total_in = t2.total_out = i2.total = 0, t2.msg = "", i2.wrap && (t2.adler = 1 & i2.wrap), i2.mode = u, i2.last = 0, i2.havedict = 0, i2.dmax = 32768, i2.head = null, i2.hold = 0, i2.bits = 0, i2.lencode = i2.lendyn = new e.Buf32(f), i2.distcode = i2.distdyn = new e.Buf32(d), i2.sane = 1, i2.back = -1, s) : l;
    }
    function g(e2) {
      var t2;
      return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, _(e2)) : l;
    }
    function b(e2, t2) {
      var i2, r2;
      return e2 && e2.state ? (r2 = e2.state, t2 < 0 ? (i2 = 0, t2 = -t2) : (i2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || t2 > 15) ? l : (r2.window !== null && r2.wbits !== t2 && (r2.window = null), r2.wrap = i2, r2.wbits = t2, g(e2))) : l;
    }
    function y(e2, t2) {
      var i2, r2;
      return e2 ? (r2 = new m, e2.state = r2, r2.window = null, (i2 = b(e2, t2)) !== s && (e2.state = null), i2) : l;
    }
    var w, v, x = true;
    function E(t2) {
      if (x) {
        var i2;
        for (w = new e.Buf32(512), v = new e.Buf32(32), i2 = 0;i2 < 144; )
          t2.lens[i2++] = 8;
        for (;i2 < 256; )
          t2.lens[i2++] = 9;
        for (;i2 < 280; )
          t2.lens[i2++] = 7;
        for (;i2 < 288; )
          t2.lens[i2++] = 8;
        for (n(a, t2.lens, 0, 288, w, 0, t2.work, { bits: 9 }), i2 = 0;i2 < 32; )
          t2.lens[i2++] = 5;
        n(o, t2.lens, 0, 32, v, 0, t2.work, { bits: 5 }), x = false;
      }
      t2.lencode = w, t2.lenbits = 9, t2.distcode = v, t2.distbits = 5;
    }
    function k(t2, i2, r2, n2) {
      var a2, o2 = t2.state;
      return o2.window === null && (o2.wsize = 1 << o2.wbits, o2.wnext = 0, o2.whave = 0, o2.window = new e.Buf8(o2.wsize)), n2 >= o2.wsize ? (e.arraySet(o2.window, i2, r2 - o2.wsize, o2.wsize, 0), o2.wnext = 0, o2.whave = o2.wsize) : ((a2 = o2.wsize - o2.wnext) > n2 && (a2 = n2), e.arraySet(o2.window, i2, r2 - n2, a2, o2.wnext), (n2 -= a2) ? (e.arraySet(o2.window, i2, r2 - n2, n2, 0), o2.wnext = n2, o2.whave = o2.wsize) : (o2.wnext += a2, o2.wnext === o2.wsize && (o2.wnext = 0), o2.whave < o2.wsize && (o2.whave += a2))), 0;
    }
    return inflate.inflateReset = g, inflate.inflateReset2 = b, inflate.inflateResetKeep = _, inflate.inflateInit = function(e2) {
      return y(e2, 15);
    }, inflate.inflateInit2 = y, inflate.inflate = function(f2, d2) {
      var m2, _2, g2, b2, y2, w2, v2, x2, S, A, I, M, T, P, B, C, R, z, F, N, O, D, $, L, U = 0, Z = new e.Buf8(4), j = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!f2 || !f2.state || !f2.output || !f2.input && f2.avail_in !== 0)
        return l;
      (m2 = f2.state).mode === h && (m2.mode = 13), y2 = f2.next_out, g2 = f2.output, v2 = f2.avail_out, b2 = f2.next_in, _2 = f2.input, w2 = f2.avail_in, x2 = m2.hold, S = m2.bits, A = w2, I = v2, D = s;
      e:
        for (;; )
          switch (m2.mode) {
            case u:
              if (m2.wrap === 0) {
                m2.mode = 13;
                break;
              }
              for (;S < 16; ) {
                if (w2 === 0)
                  break e;
                w2--, x2 += _2[b2++] << S, S += 8;
              }
              if (2 & m2.wrap && x2 === 35615) {
                m2.check = 0, Z[0] = 255 & x2, Z[1] = x2 >>> 8 & 255, m2.check = i(m2.check, Z, 2, 0), x2 = 0, S = 0, m2.mode = 2;
                break;
              }
              if (m2.flags = 0, m2.head && (m2.head.done = false), !(1 & m2.wrap) || (((255 & x2) << 8) + (x2 >> 8)) % 31) {
                f2.msg = "incorrect header check", m2.mode = c;
                break;
              }
              if ((15 & x2) != 8) {
                f2.msg = "unknown compression method", m2.mode = c;
                break;
              }
              if (S -= 4, O = 8 + (15 & (x2 >>>= 4)), m2.wbits === 0)
                m2.wbits = O;
              else if (O > m2.wbits) {
                f2.msg = "invalid window size", m2.mode = c;
                break;
              }
              m2.dmax = 1 << O, f2.adler = m2.check = 1, m2.mode = 512 & x2 ? 10 : h, x2 = 0, S = 0;
              break;
            case 2:
              for (;S < 16; ) {
                if (w2 === 0)
                  break e;
                w2--, x2 += _2[b2++] << S, S += 8;
              }
              if (m2.flags = x2, (255 & m2.flags) != 8) {
                f2.msg = "unknown compression method", m2.mode = c;
                break;
              }
              if (57344 & m2.flags) {
                f2.msg = "unknown header flags set", m2.mode = c;
                break;
              }
              m2.head && (m2.head.text = x2 >> 8 & 1), 512 & m2.flags && (Z[0] = 255 & x2, Z[1] = x2 >>> 8 & 255, m2.check = i(m2.check, Z, 2, 0)), x2 = 0, S = 0, m2.mode = 3;
            case 3:
              for (;S < 32; ) {
                if (w2 === 0)
                  break e;
                w2--, x2 += _2[b2++] << S, S += 8;
              }
              m2.head && (m2.head.time = x2), 512 & m2.flags && (Z[0] = 255 & x2, Z[1] = x2 >>> 8 & 255, Z[2] = x2 >>> 16 & 255, Z[3] = x2 >>> 24 & 255, m2.check = i(m2.check, Z, 4, 0)), x2 = 0, S = 0, m2.mode = 4;
            case 4:
              for (;S < 16; ) {
                if (w2 === 0)
                  break e;
                w2--, x2 += _2[b2++] << S, S += 8;
              }
              m2.head && (m2.head.xflags = 255 & x2, m2.head.os = x2 >> 8), 512 & m2.flags && (Z[0] = 255 & x2, Z[1] = x2 >>> 8 & 255, m2.check = i(m2.check, Z, 2, 0)), x2 = 0, S = 0, m2.mode = 5;
            case 5:
              if (1024 & m2.flags) {
                for (;S < 16; ) {
                  if (w2 === 0)
                    break e;
                  w2--, x2 += _2[b2++] << S, S += 8;
                }
                m2.length = x2, m2.head && (m2.head.extra_len = x2), 512 & m2.flags && (Z[0] = 255 & x2, Z[1] = x2 >>> 8 & 255, m2.check = i(m2.check, Z, 2, 0)), x2 = 0, S = 0;
              } else
                m2.head && (m2.head.extra = null);
              m2.mode = 6;
            case 6:
              if (1024 & m2.flags && ((M = m2.length) > w2 && (M = w2), M && (m2.head && (O = m2.head.extra_len - m2.length, m2.head.extra || (m2.head.extra = new Array(m2.head.extra_len)), e.arraySet(m2.head.extra, _2, b2, M, O)), 512 & m2.flags && (m2.check = i(m2.check, _2, M, b2)), w2 -= M, b2 += M, m2.length -= M), m2.length))
                break e;
              m2.length = 0, m2.mode = 7;
            case 7:
              if (2048 & m2.flags) {
                if (w2 === 0)
                  break e;
                M = 0;
                do {
                  O = _2[b2 + M++], m2.head && O && m2.length < 65536 && (m2.head.name += String.fromCharCode(O));
                } while (O && M < w2);
                if (512 & m2.flags && (m2.check = i(m2.check, _2, M, b2)), w2 -= M, b2 += M, O)
                  break e;
              } else
                m2.head && (m2.head.name = null);
              m2.length = 0, m2.mode = 8;
            case 8:
              if (4096 & m2.flags) {
                if (w2 === 0)
                  break e;
                M = 0;
                do {
                  O = _2[b2 + M++], m2.head && O && m2.length < 65536 && (m2.head.comment += String.fromCharCode(O));
                } while (O && M < w2);
                if (512 & m2.flags && (m2.check = i(m2.check, _2, M, b2)), w2 -= M, b2 += M, O)
                  break e;
              } else
                m2.head && (m2.head.comment = null);
              m2.mode = 9;
            case 9:
              if (512 & m2.flags) {
                for (;S < 16; ) {
                  if (w2 === 0)
                    break e;
                  w2--, x2 += _2[b2++] << S, S += 8;
                }
                if (x2 !== (65535 & m2.check)) {
                  f2.msg = "header crc mismatch", m2.mode = c;
                  break;
                }
                x2 = 0, S = 0;
              }
              m2.head && (m2.head.hcrc = m2.flags >> 9 & 1, m2.head.done = true), f2.adler = m2.check = 0, m2.mode = h;
              break;
            case 10:
              for (;S < 32; ) {
                if (w2 === 0)
                  break e;
                w2--, x2 += _2[b2++] << S, S += 8;
              }
              f2.adler = m2.check = p(x2), x2 = 0, S = 0, m2.mode = 11;
            case 11:
              if (m2.havedict === 0)
                return f2.next_out = y2, f2.avail_out = v2, f2.next_in = b2, f2.avail_in = w2, m2.hold = x2, m2.bits = S, 2;
              f2.adler = m2.check = 1, m2.mode = h;
            case h:
              if (d2 === 5 || d2 === 6)
                break e;
            case 13:
              if (m2.last) {
                x2 >>>= 7 & S, S -= 7 & S, m2.mode = 27;
                break;
              }
              for (;S < 3; ) {
                if (w2 === 0)
                  break e;
                w2--, x2 += _2[b2++] << S, S += 8;
              }
              switch (m2.last = 1 & x2, S -= 1, 3 & (x2 >>>= 1)) {
                case 0:
                  m2.mode = 14;
                  break;
                case 1:
                  if (E(m2), m2.mode = 20, d2 === 6) {
                    x2 >>>= 2, S -= 2;
                    break e;
                  }
                  break;
                case 2:
                  m2.mode = 17;
                  break;
                case 3:
                  f2.msg = "invalid block type", m2.mode = c;
              }
              x2 >>>= 2, S -= 2;
              break;
            case 14:
              for (x2 >>>= 7 & S, S -= 7 & S;S < 32; ) {
                if (w2 === 0)
                  break e;
                w2--, x2 += _2[b2++] << S, S += 8;
              }
              if ((65535 & x2) != (x2 >>> 16 ^ 65535)) {
                f2.msg = "invalid stored block lengths", m2.mode = c;
                break;
              }
              if (m2.length = 65535 & x2, x2 = 0, S = 0, m2.mode = 15, d2 === 6)
                break e;
            case 15:
              m2.mode = 16;
            case 16:
              if (M = m2.length) {
                if (M > w2 && (M = w2), M > v2 && (M = v2), M === 0)
                  break e;
                e.arraySet(g2, _2, b2, M, y2), w2 -= M, b2 += M, v2 -= M, y2 += M, m2.length -= M;
                break;
              }
              m2.mode = h;
              break;
            case 17:
              for (;S < 14; ) {
                if (w2 === 0)
                  break e;
                w2--, x2 += _2[b2++] << S, S += 8;
              }
              if (m2.nlen = 257 + (31 & x2), x2 >>>= 5, S -= 5, m2.ndist = 1 + (31 & x2), x2 >>>= 5, S -= 5, m2.ncode = 4 + (15 & x2), x2 >>>= 4, S -= 4, m2.nlen > 286 || m2.ndist > 30) {
                f2.msg = "too many length or distance symbols", m2.mode = c;
                break;
              }
              m2.have = 0, m2.mode = 18;
            case 18:
              for (;m2.have < m2.ncode; ) {
                for (;S < 3; ) {
                  if (w2 === 0)
                    break e;
                  w2--, x2 += _2[b2++] << S, S += 8;
                }
                m2.lens[j[m2.have++]] = 7 & x2, x2 >>>= 3, S -= 3;
              }
              for (;m2.have < 19; )
                m2.lens[j[m2.have++]] = 0;
              if (m2.lencode = m2.lendyn, m2.lenbits = 7, $ = { bits: m2.lenbits }, D = n(0, m2.lens, 0, 19, m2.lencode, 0, m2.work, $), m2.lenbits = $.bits, D) {
                f2.msg = "invalid code lengths set", m2.mode = c;
                break;
              }
              m2.have = 0, m2.mode = 19;
            case 19:
              for (;m2.have < m2.nlen + m2.ndist; ) {
                for (;C = (U = m2.lencode[x2 & (1 << m2.lenbits) - 1]) >>> 16 & 255, R = 65535 & U, !((B = U >>> 24) <= S); ) {
                  if (w2 === 0)
                    break e;
                  w2--, x2 += _2[b2++] << S, S += 8;
                }
                if (R < 16)
                  x2 >>>= B, S -= B, m2.lens[m2.have++] = R;
                else {
                  if (R === 16) {
                    for (L = B + 2;S < L; ) {
                      if (w2 === 0)
                        break e;
                      w2--, x2 += _2[b2++] << S, S += 8;
                    }
                    if (x2 >>>= B, S -= B, m2.have === 0) {
                      f2.msg = "invalid bit length repeat", m2.mode = c;
                      break;
                    }
                    O = m2.lens[m2.have - 1], M = 3 + (3 & x2), x2 >>>= 2, S -= 2;
                  } else if (R === 17) {
                    for (L = B + 3;S < L; ) {
                      if (w2 === 0)
                        break e;
                      w2--, x2 += _2[b2++] << S, S += 8;
                    }
                    S -= B, O = 0, M = 3 + (7 & (x2 >>>= B)), x2 >>>= 3, S -= 3;
                  } else {
                    for (L = B + 7;S < L; ) {
                      if (w2 === 0)
                        break e;
                      w2--, x2 += _2[b2++] << S, S += 8;
                    }
                    S -= B, O = 0, M = 11 + (127 & (x2 >>>= B)), x2 >>>= 7, S -= 7;
                  }
                  if (m2.have + M > m2.nlen + m2.ndist) {
                    f2.msg = "invalid bit length repeat", m2.mode = c;
                    break;
                  }
                  for (;M--; )
                    m2.lens[m2.have++] = O;
                }
              }
              if (m2.mode === c)
                break;
              if (m2.lens[256] === 0) {
                f2.msg = "invalid code -- missing end-of-block", m2.mode = c;
                break;
              }
              if (m2.lenbits = 9, $ = { bits: m2.lenbits }, D = n(a, m2.lens, 0, m2.nlen, m2.lencode, 0, m2.work, $), m2.lenbits = $.bits, D) {
                f2.msg = "invalid literal/lengths set", m2.mode = c;
                break;
              }
              if (m2.distbits = 6, m2.distcode = m2.distdyn, $ = { bits: m2.distbits }, D = n(o, m2.lens, m2.nlen, m2.ndist, m2.distcode, 0, m2.work, $), m2.distbits = $.bits, D) {
                f2.msg = "invalid distances set", m2.mode = c;
                break;
              }
              if (m2.mode = 20, d2 === 6)
                break e;
            case 20:
              m2.mode = 21;
            case 21:
              if (w2 >= 6 && v2 >= 258) {
                f2.next_out = y2, f2.avail_out = v2, f2.next_in = b2, f2.avail_in = w2, m2.hold = x2, m2.bits = S, r(f2, I), y2 = f2.next_out, g2 = f2.output, v2 = f2.avail_out, b2 = f2.next_in, _2 = f2.input, w2 = f2.avail_in, x2 = m2.hold, S = m2.bits, m2.mode === h && (m2.back = -1);
                break;
              }
              for (m2.back = 0;C = (U = m2.lencode[x2 & (1 << m2.lenbits) - 1]) >>> 16 & 255, R = 65535 & U, !((B = U >>> 24) <= S); ) {
                if (w2 === 0)
                  break e;
                w2--, x2 += _2[b2++] << S, S += 8;
              }
              if (C && !(240 & C)) {
                for (z = B, F = C, N = R;C = (U = m2.lencode[N + ((x2 & (1 << z + F) - 1) >> z)]) >>> 16 & 255, R = 65535 & U, !(z + (B = U >>> 24) <= S); ) {
                  if (w2 === 0)
                    break e;
                  w2--, x2 += _2[b2++] << S, S += 8;
                }
                x2 >>>= z, S -= z, m2.back += z;
              }
              if (x2 >>>= B, S -= B, m2.back += B, m2.length = R, C === 0) {
                m2.mode = 26;
                break;
              }
              if (32 & C) {
                m2.back = -1, m2.mode = h;
                break;
              }
              if (64 & C) {
                f2.msg = "invalid literal/length code", m2.mode = c;
                break;
              }
              m2.extra = 15 & C, m2.mode = 22;
            case 22:
              if (m2.extra) {
                for (L = m2.extra;S < L; ) {
                  if (w2 === 0)
                    break e;
                  w2--, x2 += _2[b2++] << S, S += 8;
                }
                m2.length += x2 & (1 << m2.extra) - 1, x2 >>>= m2.extra, S -= m2.extra, m2.back += m2.extra;
              }
              m2.was = m2.length, m2.mode = 23;
            case 23:
              for (;C = (U = m2.distcode[x2 & (1 << m2.distbits) - 1]) >>> 16 & 255, R = 65535 & U, !((B = U >>> 24) <= S); ) {
                if (w2 === 0)
                  break e;
                w2--, x2 += _2[b2++] << S, S += 8;
              }
              if (!(240 & C)) {
                for (z = B, F = C, N = R;C = (U = m2.distcode[N + ((x2 & (1 << z + F) - 1) >> z)]) >>> 16 & 255, R = 65535 & U, !(z + (B = U >>> 24) <= S); ) {
                  if (w2 === 0)
                    break e;
                  w2--, x2 += _2[b2++] << S, S += 8;
                }
                x2 >>>= z, S -= z, m2.back += z;
              }
              if (x2 >>>= B, S -= B, m2.back += B, 64 & C) {
                f2.msg = "invalid distance code", m2.mode = c;
                break;
              }
              m2.offset = R, m2.extra = 15 & C, m2.mode = 24;
            case 24:
              if (m2.extra) {
                for (L = m2.extra;S < L; ) {
                  if (w2 === 0)
                    break e;
                  w2--, x2 += _2[b2++] << S, S += 8;
                }
                m2.offset += x2 & (1 << m2.extra) - 1, x2 >>>= m2.extra, S -= m2.extra, m2.back += m2.extra;
              }
              if (m2.offset > m2.dmax) {
                f2.msg = "invalid distance too far back", m2.mode = c;
                break;
              }
              m2.mode = 25;
            case 25:
              if (v2 === 0)
                break e;
              if (M = I - v2, m2.offset > M) {
                if ((M = m2.offset - M) > m2.whave && m2.sane) {
                  f2.msg = "invalid distance too far back", m2.mode = c;
                  break;
                }
                M > m2.wnext ? (M -= m2.wnext, T = m2.wsize - M) : T = m2.wnext - M, M > m2.length && (M = m2.length), P = m2.window;
              } else
                P = g2, T = y2 - m2.offset, M = m2.length;
              M > v2 && (M = v2), v2 -= M, m2.length -= M;
              do {
                g2[y2++] = P[T++];
              } while (--M);
              m2.length === 0 && (m2.mode = 21);
              break;
            case 26:
              if (v2 === 0)
                break e;
              g2[y2++] = m2.length, v2--, m2.mode = 21;
              break;
            case 27:
              if (m2.wrap) {
                for (;S < 32; ) {
                  if (w2 === 0)
                    break e;
                  w2--, x2 |= _2[b2++] << S, S += 8;
                }
                if (I -= v2, f2.total_out += I, m2.total += I, I && (f2.adler = m2.check = m2.flags ? i(m2.check, g2, I, y2 - I) : t(m2.check, g2, I, y2 - I)), I = v2, (m2.flags ? x2 : p(x2)) !== m2.check) {
                  f2.msg = "incorrect data check", m2.mode = c;
                  break;
                }
                x2 = 0, S = 0;
              }
              m2.mode = 28;
            case 28:
              if (m2.wrap && m2.flags) {
                for (;S < 32; ) {
                  if (w2 === 0)
                    break e;
                  w2--, x2 += _2[b2++] << S, S += 8;
                }
                if (x2 !== (4294967295 & m2.total)) {
                  f2.msg = "incorrect length check", m2.mode = c;
                  break;
                }
                x2 = 0, S = 0;
              }
              m2.mode = 29;
            case 29:
              D = 1;
              break e;
            case c:
              D = -3;
              break e;
            case 31:
              return -4;
            default:
              return l;
          }
      return f2.next_out = y2, f2.avail_out = v2, f2.next_in = b2, f2.avail_in = w2, m2.hold = x2, m2.bits = S, (m2.wsize || I !== f2.avail_out && m2.mode < c && (m2.mode < 27 || d2 !== 4)) && k(f2, f2.output, f2.next_out, I - f2.avail_out), A -= f2.avail_in, I -= f2.avail_out, f2.total_in += A, f2.total_out += I, m2.total += I, m2.wrap && I && (f2.adler = m2.check = m2.flags ? i(m2.check, g2, I, f2.next_out - I) : t(m2.check, g2, I, f2.next_out - I)), f2.data_type = m2.bits + (m2.last ? 64 : 0) + (m2.mode === h ? 128 : 0) + (m2.mode === 20 || m2.mode === 15 ? 256 : 0), (A === 0 && I === 0 || d2 === 4) && D === s && (D = -5), D;
    }, inflate.inflateEnd = function(e2) {
      if (!e2 || !e2.state)
        return l;
      var t2 = e2.state;
      return t2.window && (t2.window = null), e2.state = null, s;
    }, inflate.inflateGetHeader = function(e2, t2) {
      var i2;
      return e2 && e2.state && 2 & (i2 = e2.state).wrap ? (i2.head = t2, t2.done = false, s) : l;
    }, inflate.inflateSetDictionary = function(e2, i2) {
      var r2, n2 = i2.length;
      return e2 && e2.state ? (r2 = e2.state).wrap !== 0 && r2.mode !== 11 ? l : r2.mode === 11 && t(1, i2, n2, 0) !== r2.check ? -3 : k(e2, i2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, s) : l;
    }, inflate.inflateInfo = "pako inflate (from Nodeca project)", inflate;
  };
  requireConstants = function() {
    return hasRequiredConstants ? constants : (hasRequiredConstants = 1, constants = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 });
  };
  requireGzheader = function() {
    if (hasRequiredGzheader)
      return gzheader;
    return hasRequiredGzheader = 1, gzheader = function() {
      this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
    };
  };
  requireInflate = function() {
    if (hasRequiredInflate)
      return inflate$1;
    hasRequiredInflate = 1;
    var e = requireInflate$1(), t = requireCommon(), i = requireStrings(), r = requireConstants(), n = requireMessages(), a = requireZstream(), o = requireGzheader(), s = Object.prototype.toString;
    function l(u2) {
      if (!(this instanceof l))
        return new l(u2);
      this.options = t.assign({ chunkSize: 16384, windowBits: 0, to: "" }, u2 || {});
      var h = this.options;
      h.raw && h.windowBits >= 0 && h.windowBits < 16 && (h.windowBits = -h.windowBits, h.windowBits === 0 && (h.windowBits = -15)), !(h.windowBits >= 0 && h.windowBits < 16) || u2 && u2.windowBits || (h.windowBits += 32), h.windowBits > 15 && h.windowBits < 48 && (15 & h.windowBits || (h.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new a, this.strm.avail_out = 0;
      var c = e.inflateInit2(this.strm, h.windowBits);
      if (c !== r.Z_OK)
        throw new Error(n[c]);
      if (this.header = new o, e.inflateGetHeader(this.strm, this.header), h.dictionary && (typeof h.dictionary == "string" ? h.dictionary = i.string2buf(h.dictionary) : s.call(h.dictionary) === "[object ArrayBuffer]" && (h.dictionary = new Uint8Array(h.dictionary)), h.raw && (c = e.inflateSetDictionary(this.strm, h.dictionary)) !== r.Z_OK))
        throw new Error(n[c]);
    }
    function u(e2, t2) {
      var i2 = new l(t2);
      if (i2.push(e2, true), i2.err)
        throw i2.msg || n[i2.err];
      return i2.result;
    }
    return l.prototype.push = function(n2, a2) {
      var o2, l2, u2, h, c, f = this.strm, d = this.options.chunkSize, p = this.options.dictionary, m = false;
      if (this.ended)
        return false;
      l2 = a2 === ~~a2 ? a2 : a2 === true ? r.Z_FINISH : r.Z_NO_FLUSH, typeof n2 == "string" ? f.input = i.binstring2buf(n2) : s.call(n2) === "[object ArrayBuffer]" ? f.input = new Uint8Array(n2) : f.input = n2, f.next_in = 0, f.avail_in = f.input.length;
      do {
        if (f.avail_out === 0 && (f.output = new t.Buf8(d), f.next_out = 0, f.avail_out = d), (o2 = e.inflate(f, r.Z_NO_FLUSH)) === r.Z_NEED_DICT && p && (o2 = e.inflateSetDictionary(this.strm, p)), o2 === r.Z_BUF_ERROR && m === true && (o2 = r.Z_OK, m = false), o2 !== r.Z_STREAM_END && o2 !== r.Z_OK)
          return this.onEnd(o2), this.ended = true, false;
        f.next_out && (f.avail_out !== 0 && o2 !== r.Z_STREAM_END && (f.avail_in !== 0 || l2 !== r.Z_FINISH && l2 !== r.Z_SYNC_FLUSH) || (this.options.to === "string" ? (u2 = i.utf8border(f.output, f.next_out), h = f.next_out - u2, c = i.buf2string(f.output, u2), f.next_out = h, f.avail_out = d - h, h && t.arraySet(f.output, f.output, u2, h, 0), this.onData(c)) : this.onData(t.shrinkBuf(f.output, f.next_out)))), f.avail_in === 0 && f.avail_out === 0 && (m = true);
      } while ((f.avail_in > 0 || f.avail_out === 0) && o2 !== r.Z_STREAM_END);
      return o2 === r.Z_STREAM_END && (l2 = r.Z_FINISH), l2 === r.Z_FINISH ? (o2 = e.inflateEnd(this.strm), this.onEnd(o2), this.ended = true, o2 === r.Z_OK) : l2 !== r.Z_SYNC_FLUSH || (this.onEnd(r.Z_OK), f.avail_out = 0, true);
    }, l.prototype.onData = function(e2) {
      this.chunks.push(e2);
    }, l.prototype.onEnd = function(e2) {
      e2 === r.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = t.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
    }, inflate$1.Inflate = l, inflate$1.inflate = u, inflate$1.inflateRaw = function(e2, t2) {
      return (t2 = t2 || {}).raw = true, u(e2, t2);
    }, inflate$1.ungzip = u, inflate$1;
  };
  requirePako = function() {
    if (hasRequiredPako)
      return pako_1;
    hasRequiredPako = 1;
    var e = {};
    return (0, requireCommon().assign)(e, requireDeflate(), requireInflate(), requireConstants()), pako_1 = e;
  };
  getDimensionValue = function(e) {
    return typeof e == "number" ? e : e instanceof Uint8Array ? e[0] : typeof e[0] == "string" ? parseInt(e[0]) : e[0];
  };
  tiff = function() {
    return { mime: "image/tiff", encode: (e) => {
      const t = utif.encodeImage(e.data, e.width, e.height);
      return Buffer2.from(t);
    }, decode: (e) => {
      const t = utif.decode(e), i = t[0];
      if (!i)
        throw new Error("No page found in TIFF");
      if (!i.t256)
        throw new Error("No image width found in TIFF");
      if (!i.t257)
        throw new Error("No image height found in TIFF");
      t.forEach((t2) => {
        utif.decodeImage(e, t2);
      });
      const r = utif.toRGBA8(i);
      return { data: Buffer2.from(r), width: getDimensionValue(i.t256), height: getDimensionValue(i.t257) };
    } };
  };
  setErrorMap = function(e) {
    overrideErrorMap = e;
  };
  getErrorMap = function() {
    return overrideErrorMap;
  };
  addIssueToContext = function(e, t) {
    const i = getErrorMap(), r = makeIssue({ issueData: t, data: e.data, path: e.path, errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, i, i === errorMap ? undefined : errorMap].filter((e2) => !!e2) });
    e.common.issues.push(r);
  };
  __classPrivateFieldGet = function(e, t, i, r) {
    if (typeof t == "function" ? e !== t || !r : !t.has(e))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t.get(e);
  };
  __classPrivateFieldSet = function(e, t, i, r, n) {
    if (typeof t == "function" ? e !== t || !n : !t.has(e))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return t.set(e, i), i;
  };
  processCreateParams = function(e) {
    if (!e)
      return {};
    const { errorMap: t, invalid_type_error: i, required_error: r, description: n } = e;
    if (t && (i || r))
      throw new Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.');
    if (t)
      return { errorMap: t, description: n };
    return { errorMap: (t2, n2) => {
      var a, o;
      const { message: s } = e;
      return t2.code === "invalid_enum_value" ? { message: s != null ? s : n2.defaultError } : n2.data === undefined ? { message: (a = s != null ? s : r) !== null && a !== undefined ? a : n2.defaultError } : t2.code !== "invalid_type" ? { message: n2.defaultError } : { message: (o = s != null ? s : i) !== null && o !== undefined ? o : n2.defaultError };
    }, description: n };
  };
  timeRegexSource = function(e) {
    let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t;
  };
  timeRegex = function(e) {
    return new RegExp(`^${timeRegexSource(e)}\$`);
  };
  datetimeRegex = function(e) {
    let t = `${dateRegexSource}T${timeRegexSource(e)}`;
    const i = [];
    return i.push(e.local ? "Z?" : "Z"), e.offset && i.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${i.join("|")})`, new RegExp(`^${t}\$`);
  };
  isValidIP = function(e, t) {
    return !(t !== "v4" && t || !ipv4Regex.test(e)) || !(t !== "v6" && t || !ipv6Regex.test(e));
  };
  floatSafeRemainder = function(e, t) {
    const i = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, n = i > r ? i : r;
    return parseInt(e.toFixed(n).replace(".", "")) % parseInt(t.toFixed(n).replace(".", "")) / Math.pow(10, n);
  };
  deepPartialify = function(e) {
    if (e instanceof ZodObject) {
      const t = {};
      for (const i in e.shape) {
        const r = e.shape[i];
        t[i] = ZodOptional.create(deepPartialify(r));
      }
      return new ZodObject({ ...e._def, shape: () => t });
    }
    return e instanceof ZodArray ? new ZodArray({ ...e._def, type: deepPartialify(e.element) }) : e instanceof ZodOptional ? ZodOptional.create(deepPartialify(e.unwrap())) : e instanceof ZodNullable ? ZodNullable.create(deepPartialify(e.unwrap())) : e instanceof ZodTuple ? ZodTuple.create(e.items.map((e2) => deepPartialify(e2))) : e;
  };
  mergeValues = function(e, t) {
    const i = getParsedType(e), r = getParsedType(t);
    if (e === t)
      return { valid: true, data: e };
    if (i === ZodParsedType.object && r === ZodParsedType.object) {
      const i2 = util$1.objectKeys(t), r2 = util$1.objectKeys(e).filter((e2) => i2.indexOf(e2) !== -1), n = { ...e, ...t };
      for (const i3 of r2) {
        const r3 = mergeValues(e[i3], t[i3]);
        if (!r3.valid)
          return { valid: false };
        n[i3] = r3.data;
      }
      return { valid: true, data: n };
    }
    if (i === ZodParsedType.array && r === ZodParsedType.array) {
      if (e.length !== t.length)
        return { valid: false };
      const i2 = [];
      for (let r2 = 0;r2 < e.length; r2++) {
        const n = mergeValues(e[r2], t[r2]);
        if (!n.valid)
          return { valid: false };
        i2.push(n.data);
      }
      return { valid: true, data: i2 };
    }
    return i === ZodParsedType.date && r === ZodParsedType.date && +e == +t ? { valid: true, data: e } : { valid: false };
  };
  createZodEnum = function(e, t) {
    return new ZodEnum({ values: e, typeName: ZodFirstPartyTypeKind.ZodEnum, ...processCreateParams(t) });
  };
  custom = function(e, t = {}, i) {
    return e ? ZodAny.create().superRefine((r, n) => {
      var a, o;
      if (!e(r)) {
        const e2 = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t, s = (o = (a = e2.fatal) !== null && a !== undefined ? a : i) === null || o === undefined || o, l = typeof e2 == "string" ? { message: e2 } : e2;
        n.addIssue({ code: "custom", ...l, fatal: s });
      }
    }) : ZodAny.create();
  };
  applyKernel = function(e, t, i, r) {
    const n = [0, 0, 0, 0], a = (t.length - 1) / 2;
    for (let o = 0;o < t.length; o += 1)
      for (let s = 0;s < t[o].length; s += 1) {
        const l = e.getPixelIndex(i + o - a, r + s - a);
        n[0] += e.bitmap.data[l] * t[o][s], n[1] += e.bitmap.data[l + 1] * t[o][s], n[2] += e.bitmap.data[l + 2] * t[o][s], n[3] += e.bitmap.data[l + 3] * t[o][s];
      }
    return n;
  };
  mix = function(e, t, i = 50) {
    return { r: (t.r - e.r) * (i / 100) + e.r, g: (t.g - e.g) * (i / 100) + e.g, b: (t.b - e.b) * (i / 100) + e.b };
  };
  histogram = function(e) {
    const t = { r: new Array(256).fill(0), g: new Array(256).fill(0), b: new Array(256).fill(0) };
    return e.scan((i, r, n) => {
      t.r[e.bitmap.data[n + 0]]++, t.g[e.bitmap.data[n + 1]]++, t.b[e.bitmap.data[n + 2]]++;
    }), t;
  };
  _check = function(e, t, i) {
    i = { offset: 0, ...i };
    for (const [r, n] of t.entries())
      if (i.mask) {
        if (n !== (i.mask[r] & e[r + i.offset]))
          return false;
      } else if (n !== e[r + i.offset])
        return false;
    return true;
  };
  commonjsGlobal = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
  typeof self == "undefined" && typeof commonjsGlobal == "object" && (commonjsGlobal.self = commonjsGlobal);
  global$1 = typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
  lookup = [];
  revLookup = [];
  Arr = typeof Uint8Array != "undefined" ? Uint8Array : Array;
  inited = false;
  toString = {}.toString;
  isArray = Array.isArray || function(e2) {
    return toString.call(e2) == "[object Array]";
  };
  INSPECT_MAX_BYTES = 50;
  Buffer2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT === undefined || global$1.TYPED_ARRAY_SUPPORT, kMaxLength(), Buffer2.poolSize = 8192, Buffer2._augment = function(e2) {
    return e2.__proto__ = Buffer2.prototype, e2;
  }, Buffer2.from = function(e2, t, i) {
    return from(null, e2, t, i);
  }, Buffer2.TYPED_ARRAY_SUPPORT && (Buffer2.prototype.__proto__ = Uint8Array.prototype, Buffer2.__proto__ = Uint8Array, typeof Symbol != "undefined" && Symbol.species && Buffer2[Symbol.species]), Buffer2.alloc = function(e2, t, i) {
    return alloc(null, e2, t, i);
  }, Buffer2.allocUnsafe = function(e2) {
    return allocUnsafe(null, e2);
  }, Buffer2.allocUnsafeSlow = function(e2) {
    return allocUnsafe(null, e2);
  }, Buffer2.isBuffer = isBuffer, Buffer2.compare = function(e2, t) {
    if (!internalIsBuffer(e2) || !internalIsBuffer(t))
      throw new TypeError("Arguments must be Buffers");
    if (e2 === t)
      return 0;
    for (var i = e2.length, r = t.length, n = 0, a = Math.min(i, r);n < a; ++n)
      if (e2[n] !== t[n]) {
        i = e2[n], r = t[n];
        break;
      }
    return i < r ? -1 : r < i ? 1 : 0;
  }, Buffer2.isEncoding = function(e2) {
    switch (String(e2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, Buffer2.concat = function(e2, t) {
    if (!isArray(e2))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e2.length === 0)
      return Buffer2.alloc(0);
    var i;
    if (t === undefined)
      for (t = 0, i = 0;i < e2.length; ++i)
        t += e2[i].length;
    var r = Buffer2.allocUnsafe(t), n = 0;
    for (i = 0;i < e2.length; ++i) {
      var a = e2[i];
      if (!internalIsBuffer(a))
        throw new TypeError('"list" argument must be an Array of Buffers');
      a.copy(r, n), n += a.length;
    }
    return r;
  }, Buffer2.byteLength = byteLength, Buffer2.prototype._isBuffer = true, Buffer2.prototype.swap16 = function() {
    var e2 = this.length;
    if (e2 % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var t = 0;t < e2; t += 2)
      swap(this, t, t + 1);
    return this;
  }, Buffer2.prototype.swap32 = function() {
    var e2 = this.length;
    if (e2 % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var t = 0;t < e2; t += 4)
      swap(this, t, t + 3), swap(this, t + 1, t + 2);
    return this;
  }, Buffer2.prototype.swap64 = function() {
    var e2 = this.length;
    if (e2 % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var t = 0;t < e2; t += 8)
      swap(this, t, t + 7), swap(this, t + 1, t + 6), swap(this, t + 2, t + 5), swap(this, t + 3, t + 4);
    return this;
  }, Buffer2.prototype.toString = function() {
    var e2 = 0 | this.length;
    return e2 === 0 ? "" : arguments.length === 0 ? utf8Slice(this, 0, e2) : slowToString.apply(this, arguments);
  }, Buffer2.prototype.equals = function(e2) {
    if (!internalIsBuffer(e2))
      throw new TypeError("Argument must be a Buffer");
    return this === e2 || Buffer2.compare(this, e2) === 0;
  }, Buffer2.prototype.inspect = function() {
    var e2 = "", t = INSPECT_MAX_BYTES;
    return this.length > 0 && (e2 = this.toString("hex", 0, t).match(/.{2}/g).join(" "), this.length > t && (e2 += " ... ")), "<Buffer " + e2 + ">";
  }, Buffer2.prototype.compare = function(e2, t, i, r, n) {
    if (!internalIsBuffer(e2))
      throw new TypeError("Argument must be a Buffer");
    if (t === undefined && (t = 0), i === undefined && (i = e2 ? e2.length : 0), r === undefined && (r = 0), n === undefined && (n = this.length), t < 0 || i > e2.length || r < 0 || n > this.length)
      throw new RangeError("out of range index");
    if (r >= n && t >= i)
      return 0;
    if (r >= n)
      return -1;
    if (t >= i)
      return 1;
    if (this === e2)
      return 0;
    for (var a = (n >>>= 0) - (r >>>= 0), o = (i >>>= 0) - (t >>>= 0), s = Math.min(a, o), l = this.slice(r, n), u = e2.slice(t, i), h = 0;h < s; ++h)
      if (l[h] !== u[h]) {
        a = l[h], o = u[h];
        break;
      }
    return a < o ? -1 : o < a ? 1 : 0;
  }, Buffer2.prototype.includes = function(e2, t, i) {
    return this.indexOf(e2, t, i) !== -1;
  }, Buffer2.prototype.indexOf = function(e2, t, i) {
    return bidirectionalIndexOf(this, e2, t, i, true);
  }, Buffer2.prototype.lastIndexOf = function(e2, t, i) {
    return bidirectionalIndexOf(this, e2, t, i, false);
  }, Buffer2.prototype.write = function(e2, t, i, r) {
    if (t === undefined)
      r = "utf8", i = this.length, t = 0;
    else if (i === undefined && typeof t == "string")
      r = t, i = this.length, t = 0;
    else {
      if (!isFinite(t))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      t |= 0, isFinite(i) ? (i |= 0, r === undefined && (r = "utf8")) : (r = i, i = undefined);
    }
    var n = this.length - t;
    if ((i === undefined || i > n) && (i = n), e2.length > 0 && (i < 0 || t < 0) || t > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    r || (r = "utf8");
    for (var a = false;; )
      switch (r) {
        case "hex":
          return hexWrite(this, e2, t, i);
        case "utf8":
        case "utf-8":
          return utf8Write(this, e2, t, i);
        case "ascii":
          return asciiWrite(this, e2, t, i);
        case "latin1":
        case "binary":
          return latin1Write(this, e2, t, i);
        case "base64":
          return base64Write(this, e2, t, i);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, e2, t, i);
        default:
          if (a)
            throw new TypeError("Unknown encoding: " + r);
          r = ("" + r).toLowerCase(), a = true;
      }
  }, Buffer2.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  MAX_ARGUMENTS_LENGTH = 4096;
  Buffer2.prototype.slice = function(e2, t) {
    var i, r = this.length;
    if ((e2 = ~~e2) < 0 ? (e2 += r) < 0 && (e2 = 0) : e2 > r && (e2 = r), (t = t === undefined ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e2 && (t = e2), Buffer2.TYPED_ARRAY_SUPPORT)
      (i = this.subarray(e2, t)).__proto__ = Buffer2.prototype;
    else {
      var n = t - e2;
      i = new Buffer2(n, undefined);
      for (var a = 0;a < n; ++a)
        i[a] = this[a + e2];
    }
    return i;
  }, Buffer2.prototype.readUIntLE = function(e2, t, i) {
    e2 |= 0, t |= 0, i || checkOffset(e2, t, this.length);
    for (var r = this[e2], n = 1, a = 0;++a < t && (n *= 256); )
      r += this[e2 + a] * n;
    return r;
  }, Buffer2.prototype.readUIntBE = function(e2, t, i) {
    e2 |= 0, t |= 0, i || checkOffset(e2, t, this.length);
    for (var r = this[e2 + --t], n = 1;t > 0 && (n *= 256); )
      r += this[e2 + --t] * n;
    return r;
  }, Buffer2.prototype.readUInt8 = function(e2, t) {
    return t || checkOffset(e2, 1, this.length), this[e2];
  }, Buffer2.prototype.readUInt16LE = function(e2, t) {
    return t || checkOffset(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
  }, Buffer2.prototype.readUInt16BE = function(e2, t) {
    return t || checkOffset(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
  }, Buffer2.prototype.readUInt32LE = function(e2, t) {
    return t || checkOffset(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
  }, Buffer2.prototype.readUInt32BE = function(e2, t) {
    return t || checkOffset(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
  }, Buffer2.prototype.readIntLE = function(e2, t, i) {
    e2 |= 0, t |= 0, i || checkOffset(e2, t, this.length);
    for (var r = this[e2], n = 1, a = 0;++a < t && (n *= 256); )
      r += this[e2 + a] * n;
    return r >= (n *= 128) && (r -= Math.pow(2, 8 * t)), r;
  }, Buffer2.prototype.readIntBE = function(e2, t, i) {
    e2 |= 0, t |= 0, i || checkOffset(e2, t, this.length);
    for (var r = t, n = 1, a = this[e2 + --r];r > 0 && (n *= 256); )
      a += this[e2 + --r] * n;
    return a >= (n *= 128) && (a -= Math.pow(2, 8 * t)), a;
  }, Buffer2.prototype.readInt8 = function(e2, t) {
    return t || checkOffset(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
  }, Buffer2.prototype.readInt16LE = function(e2, t) {
    t || checkOffset(e2, 2, this.length);
    var i = this[e2] | this[e2 + 1] << 8;
    return 32768 & i ? 4294901760 | i : i;
  }, Buffer2.prototype.readInt16BE = function(e2, t) {
    t || checkOffset(e2, 2, this.length);
    var i = this[e2 + 1] | this[e2] << 8;
    return 32768 & i ? 4294901760 | i : i;
  }, Buffer2.prototype.readInt32LE = function(e2, t) {
    return t || checkOffset(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
  }, Buffer2.prototype.readInt32BE = function(e2, t) {
    return t || checkOffset(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
  }, Buffer2.prototype.readFloatLE = function(e2, t) {
    return t || checkOffset(e2, 4, this.length), read(this, e2, true, 23, 4);
  }, Buffer2.prototype.readFloatBE = function(e2, t) {
    return t || checkOffset(e2, 4, this.length), read(this, e2, false, 23, 4);
  }, Buffer2.prototype.readDoubleLE = function(e2, t) {
    return t || checkOffset(e2, 8, this.length), read(this, e2, true, 52, 8);
  }, Buffer2.prototype.readDoubleBE = function(e2, t) {
    return t || checkOffset(e2, 8, this.length), read(this, e2, false, 52, 8);
  }, Buffer2.prototype.writeUIntLE = function(e2, t, i, r) {
    (e2 = +e2, t |= 0, i |= 0, r) || checkInt(this, e2, t, i, Math.pow(2, 8 * i) - 1, 0);
    var n = 1, a = 0;
    for (this[t] = 255 & e2;++a < i && (n *= 256); )
      this[t + a] = e2 / n & 255;
    return t + i;
  }, Buffer2.prototype.writeUIntBE = function(e2, t, i, r) {
    (e2 = +e2, t |= 0, i |= 0, r) || checkInt(this, e2, t, i, Math.pow(2, 8 * i) - 1, 0);
    var n = i - 1, a = 1;
    for (this[t + n] = 255 & e2;--n >= 0 && (a *= 256); )
      this[t + n] = e2 / a & 255;
    return t + i;
  }, Buffer2.prototype.writeUInt8 = function(e2, t, i) {
    return e2 = +e2, t |= 0, i || checkInt(this, e2, t, 1, 255, 0), Buffer2.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), this[t] = 255 & e2, t + 1;
  }, Buffer2.prototype.writeUInt16LE = function(e2, t, i) {
    return e2 = +e2, t |= 0, i || checkInt(this, e2, t, 2, 65535, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e2, this[t + 1] = e2 >>> 8) : objectWriteUInt16(this, e2, t, true), t + 2;
  }, Buffer2.prototype.writeUInt16BE = function(e2, t, i) {
    return e2 = +e2, t |= 0, i || checkInt(this, e2, t, 2, 65535, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t] = e2 >>> 8, this[t + 1] = 255 & e2) : objectWriteUInt16(this, e2, t, false), t + 2;
  }, Buffer2.prototype.writeUInt32LE = function(e2, t, i) {
    return e2 = +e2, t |= 0, i || checkInt(this, e2, t, 4, 4294967295, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e2 >>> 24, this[t + 2] = e2 >>> 16, this[t + 1] = e2 >>> 8, this[t] = 255 & e2) : objectWriteUInt32(this, e2, t, true), t + 4;
  }, Buffer2.prototype.writeUInt32BE = function(e2, t, i) {
    return e2 = +e2, t |= 0, i || checkInt(this, e2, t, 4, 4294967295, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t] = e2 >>> 24, this[t + 1] = e2 >>> 16, this[t + 2] = e2 >>> 8, this[t + 3] = 255 & e2) : objectWriteUInt32(this, e2, t, false), t + 4;
  }, Buffer2.prototype.writeIntLE = function(e2, t, i, r) {
    if (e2 = +e2, t |= 0, !r) {
      var n = Math.pow(2, 8 * i - 1);
      checkInt(this, e2, t, i, n - 1, -n);
    }
    var a = 0, o = 1, s = 0;
    for (this[t] = 255 & e2;++a < i && (o *= 256); )
      e2 < 0 && s === 0 && this[t + a - 1] !== 0 && (s = 1), this[t + a] = (e2 / o | 0) - s & 255;
    return t + i;
  }, Buffer2.prototype.writeIntBE = function(e2, t, i, r) {
    if (e2 = +e2, t |= 0, !r) {
      var n = Math.pow(2, 8 * i - 1);
      checkInt(this, e2, t, i, n - 1, -n);
    }
    var a = i - 1, o = 1, s = 0;
    for (this[t + a] = 255 & e2;--a >= 0 && (o *= 256); )
      e2 < 0 && s === 0 && this[t + a + 1] !== 0 && (s = 1), this[t + a] = (e2 / o | 0) - s & 255;
    return t + i;
  }, Buffer2.prototype.writeInt8 = function(e2, t, i) {
    return e2 = +e2, t |= 0, i || checkInt(this, e2, t, 1, 127, -128), Buffer2.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), e2 < 0 && (e2 = 255 + e2 + 1), this[t] = 255 & e2, t + 1;
  }, Buffer2.prototype.writeInt16LE = function(e2, t, i) {
    return e2 = +e2, t |= 0, i || checkInt(this, e2, t, 2, 32767, -32768), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e2, this[t + 1] = e2 >>> 8) : objectWriteUInt16(this, e2, t, true), t + 2;
  }, Buffer2.prototype.writeInt16BE = function(e2, t, i) {
    return e2 = +e2, t |= 0, i || checkInt(this, e2, t, 2, 32767, -32768), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t] = e2 >>> 8, this[t + 1] = 255 & e2) : objectWriteUInt16(this, e2, t, false), t + 2;
  }, Buffer2.prototype.writeInt32LE = function(e2, t, i) {
    return e2 = +e2, t |= 0, i || checkInt(this, e2, t, 4, 2147483647, -2147483648), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e2, this[t + 1] = e2 >>> 8, this[t + 2] = e2 >>> 16, this[t + 3] = e2 >>> 24) : objectWriteUInt32(this, e2, t, true), t + 4;
  }, Buffer2.prototype.writeInt32BE = function(e2, t, i) {
    return e2 = +e2, t |= 0, i || checkInt(this, e2, t, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t] = e2 >>> 24, this[t + 1] = e2 >>> 16, this[t + 2] = e2 >>> 8, this[t + 3] = 255 & e2) : objectWriteUInt32(this, e2, t, false), t + 4;
  }, Buffer2.prototype.writeFloatLE = function(e2, t, i) {
    return writeFloat(this, e2, t, true, i);
  }, Buffer2.prototype.writeFloatBE = function(e2, t, i) {
    return writeFloat(this, e2, t, false, i);
  }, Buffer2.prototype.writeDoubleLE = function(e2, t, i) {
    return writeDouble(this, e2, t, true, i);
  }, Buffer2.prototype.writeDoubleBE = function(e2, t, i) {
    return writeDouble(this, e2, t, false, i);
  }, Buffer2.prototype.copy = function(e2, t, i, r) {
    if (i || (i = 0), r || r === 0 || (r = this.length), t >= e2.length && (t = e2.length), t || (t = 0), r > 0 && r < i && (r = i), r === i)
      return 0;
    if (e2.length === 0 || this.length === 0)
      return 0;
    if (t < 0)
      throw new RangeError("targetStart out of bounds");
    if (i < 0 || i >= this.length)
      throw new RangeError("sourceStart out of bounds");
    if (r < 0)
      throw new RangeError("sourceEnd out of bounds");
    r > this.length && (r = this.length), e2.length - t < r - i && (r = e2.length - t + i);
    var n, a = r - i;
    if (this === e2 && i < t && t < r)
      for (n = a - 1;n >= 0; --n)
        e2[n + t] = this[n + i];
    else if (a < 1000 || !Buffer2.TYPED_ARRAY_SUPPORT)
      for (n = 0;n < a; ++n)
        e2[n + t] = this[n + i];
    else
      Uint8Array.prototype.set.call(e2, this.subarray(i, i + a), t);
    return a;
  }, Buffer2.prototype.fill = function(e2, t, i, r) {
    if (typeof e2 == "string") {
      if (typeof t == "string" ? (r = t, t = 0, i = this.length) : typeof i == "string" && (r = i, i = this.length), e2.length === 1) {
        var n = e2.charCodeAt(0);
        n < 256 && (e2 = n);
      }
      if (r !== undefined && typeof r != "string")
        throw new TypeError("encoding must be a string");
      if (typeof r == "string" && !Buffer2.isEncoding(r))
        throw new TypeError("Unknown encoding: " + r);
    } else
      typeof e2 == "number" && (e2 &= 255);
    if (t < 0 || this.length < t || this.length < i)
      throw new RangeError("Out of range index");
    if (i <= t)
      return this;
    var a;
    if (t >>>= 0, i = i === undefined ? this.length : i >>> 0, e2 || (e2 = 0), typeof e2 == "number")
      for (a = t;a < i; ++a)
        this[a] = e2;
    else {
      var o = internalIsBuffer(e2) ? e2 : utf8ToBytes(new Buffer2(e2, r).toString()), s = o.length;
      for (a = 0;a < i - t; ++a)
        this[a + t] = o[a % s];
    }
    return this;
  };
  INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  (function(e2) {
    e2[e2.BITMAP_INFO_HEADER = 40] = "BITMAP_INFO_HEADER", e2[e2.BITMAP_V2_INFO_HEADER = 52] = "BITMAP_V2_INFO_HEADER", e2[e2.BITMAP_V3_INFO_HEADER = 56] = "BITMAP_V3_INFO_HEADER", e2[e2.BITMAP_V4_HEADER = 108] = "BITMAP_V4_HEADER", e2[e2.BITMAP_V5_HEADER = 124] = "BITMAP_V5_HEADER";
  })(HeaderTypes || (HeaderTypes = {}));
  HeaderTypes$1 = HeaderTypes;
  (function(e2) {
    e2[e2.NONE = 0] = "NONE", e2[e2.BI_RLE8 = 1] = "BI_RLE8", e2[e2.BI_RLE4 = 2] = "BI_RLE4", e2[e2.BI_BIT_FIELDS = 3] = "BI_BIT_FIELDS", e2[e2.BI_ALPHA_BIT_FIELDS = 6] = "BI_ALPHA_BIT_FIELDS";
  })(BmpCompression || (BmpCompression = {}));
  trimLeft = /^\s+/;
  trimRight = /\s+$/;
  tinycolor.prototype = { isDark: function() {
    return this.getBrightness() < 128;
  }, isLight: function() {
    return !this.isDark();
  }, isValid: function() {
    return this._ok;
  }, getOriginalInput: function() {
    return this._originalInput;
  }, getFormat: function() {
    return this._format;
  }, getAlpha: function() {
    return this._a;
  }, getBrightness: function() {
    var e2 = this.toRgb();
    return (299 * e2.r + 587 * e2.g + 114 * e2.b) / 1000;
  }, getLuminance: function() {
    var e2, t, i, r = this.toRgb();
    return e2 = r.r / 255, t = r.g / 255, i = r.b / 255, 0.2126 * (e2 <= 0.03928 ? e2 / 12.92 : Math.pow((e2 + 0.055) / 1.055, 2.4)) + 0.7152 * (t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4)) + 0.0722 * (i <= 0.03928 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4));
  }, setAlpha: function(e2) {
    return this._a = boundAlpha(e2), this._roundA = Math.round(100 * this._a) / 100, this;
  }, toHsv: function() {
    var e2 = rgbToHsv(this._r, this._g, this._b);
    return { h: 360 * e2.h, s: e2.s, v: e2.v, a: this._a };
  }, toHsvString: function() {
    var e2 = rgbToHsv(this._r, this._g, this._b), t = Math.round(360 * e2.h), i = Math.round(100 * e2.s), r = Math.round(100 * e2.v);
    return this._a == 1 ? "hsv(" + t + ", " + i + "%, " + r + "%)" : "hsva(" + t + ", " + i + "%, " + r + "%, " + this._roundA + ")";
  }, toHsl: function() {
    var e2 = rgbToHsl(this._r, this._g, this._b);
    return { h: 360 * e2.h, s: e2.s, l: e2.l, a: this._a };
  }, toHslString: function() {
    var e2 = rgbToHsl(this._r, this._g, this._b), t = Math.round(360 * e2.h), i = Math.round(100 * e2.s), r = Math.round(100 * e2.l);
    return this._a == 1 ? "hsl(" + t + ", " + i + "%, " + r + "%)" : "hsla(" + t + ", " + i + "%, " + r + "%, " + this._roundA + ")";
  }, toHex: function(e2) {
    return rgbToHex(this._r, this._g, this._b, e2);
  }, toHexString: function(e2) {
    return "#" + this.toHex(e2);
  }, toHex8: function(e2) {
    return rgbaToHex(this._r, this._g, this._b, this._a, e2);
  }, toHex8String: function(e2) {
    return "#" + this.toHex8(e2);
  }, toRgb: function() {
    return { r: Math.round(this._r), g: Math.round(this._g), b: Math.round(this._b), a: this._a };
  }, toRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  }, toPercentageRgb: function() {
    return { r: Math.round(100 * bound01(this._r, 255)) + "%", g: Math.round(100 * bound01(this._g, 255)) + "%", b: Math.round(100 * bound01(this._b, 255)) + "%", a: this._a };
  }, toPercentageRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(100 * bound01(this._r, 255)) + "%, " + Math.round(100 * bound01(this._g, 255)) + "%, " + Math.round(100 * bound01(this._b, 255)) + "%)" : "rgba(" + Math.round(100 * bound01(this._r, 255)) + "%, " + Math.round(100 * bound01(this._g, 255)) + "%, " + Math.round(100 * bound01(this._b, 255)) + "%, " + this._roundA + ")";
  }, toName: function() {
    return this._a === 0 ? "transparent" : !(this._a < 1) && (hexNames[rgbToHex(this._r, this._g, this._b, true)] || false);
  }, toFilter: function(e2) {
    var t = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a), i = t, r = this._gradientType ? "GradientType = 1, " : "";
    if (e2) {
      var n = tinycolor(e2);
      i = "#" + rgbaToArgbHex(n._r, n._g, n._b, n._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + r + "startColorstr=" + t + ",endColorstr=" + i + ")";
  }, toString: function(e2) {
    var t = !!e2;
    e2 = e2 || this._format;
    var i = false, r = this._a < 1 && this._a >= 0;
    return t || !r || e2 !== "hex" && e2 !== "hex6" && e2 !== "hex3" && e2 !== "hex4" && e2 !== "hex8" && e2 !== "name" ? (e2 === "rgb" && (i = this.toRgbString()), e2 === "prgb" && (i = this.toPercentageRgbString()), e2 !== "hex" && e2 !== "hex6" || (i = this.toHexString()), e2 === "hex3" && (i = this.toHexString(true)), e2 === "hex4" && (i = this.toHex8String(true)), e2 === "hex8" && (i = this.toHex8String()), e2 === "name" && (i = this.toName()), e2 === "hsl" && (i = this.toHslString()), e2 === "hsv" && (i = this.toHsvString()), i || this.toHexString()) : e2 === "name" && this._a === 0 ? this.toName() : this.toRgbString();
  }, clone: function() {
    return tinycolor(this.toString());
  }, _applyModification: function(e2, t) {
    var i = e2.apply(null, [this].concat([].slice.call(t)));
    return this._r = i._r, this._g = i._g, this._b = i._b, this.setAlpha(i._a), this;
  }, lighten: function() {
    return this._applyModification(_lighten, arguments);
  }, brighten: function() {
    return this._applyModification(_brighten, arguments);
  }, darken: function() {
    return this._applyModification(_darken, arguments);
  }, desaturate: function() {
    return this._applyModification(_desaturate, arguments);
  }, saturate: function() {
    return this._applyModification(_saturate, arguments);
  }, greyscale: function() {
    return this._applyModification(_greyscale, arguments);
  }, spin: function() {
    return this._applyModification(_spin, arguments);
  }, _applyCombination: function(e2, t) {
    return e2.apply(null, [this].concat([].slice.call(t)));
  }, analogous: function() {
    return this._applyCombination(_analogous, arguments);
  }, complement: function() {
    return this._applyCombination(_complement, arguments);
  }, monochromatic: function() {
    return this._applyCombination(_monochromatic, arguments);
  }, splitcomplement: function() {
    return this._applyCombination(_splitcomplement, arguments);
  }, triad: function() {
    return this._applyCombination(polyad, [3]);
  }, tetrad: function() {
    return this._applyCombination(polyad, [4]);
  } }, tinycolor.fromRatio = function(e2, t) {
    if (_typeof(e2) == "object") {
      var i = {};
      for (var r in e2)
        e2.hasOwnProperty(r) && (i[r] = r === "a" ? e2[r] : convertToPercentage(e2[r]));
      e2 = i;
    }
    return tinycolor(e2, t);
  }, tinycolor.equals = function(e2, t) {
    return !(!e2 || !t) && tinycolor(e2).toRgbString() == tinycolor(t).toRgbString();
  }, tinycolor.random = function() {
    return tinycolor.fromRatio({ r: Math.random(), g: Math.random(), b: Math.random() });
  }, tinycolor.mix = function(e2, t, i) {
    i = i === 0 ? 0 : i || 50;
    var r = tinycolor(e2).toRgb(), n = tinycolor(t).toRgb(), a = i / 100;
    return tinycolor({ r: (n.r - r.r) * a + r.r, g: (n.g - r.g) * a + r.g, b: (n.b - r.b) * a + r.b, a: (n.a - r.a) * a + r.a });
  }, tinycolor.readability = function(e2, t) {
    var i = tinycolor(e2), r = tinycolor(t);
    return (Math.max(i.getLuminance(), r.getLuminance()) + 0.05) / (Math.min(i.getLuminance(), r.getLuminance()) + 0.05);
  }, tinycolor.isReadable = function(e2, t, i) {
    var r, n, a = tinycolor.readability(e2, t);
    switch (n = false, (r = validateWCAG2Parms(i)).level + r.size) {
      case "AAsmall":
      case "AAAlarge":
        n = a >= 4.5;
        break;
      case "AAlarge":
        n = a >= 3;
        break;
      case "AAAsmall":
        n = a >= 7;
    }
    return n;
  }, tinycolor.mostReadable = function(e2, t, i) {
    var r, n, a, o, s = null, l = 0;
    n = (i = i || {}).includeFallbackColors, a = i.level, o = i.size;
    for (var u = 0;u < t.length; u++)
      (r = tinycolor.readability(e2, t[u])) > l && (l = r, s = tinycolor(t[u]));
    return tinycolor.isReadable(e2, s, { level: a, size: o }) || !n ? s : (i.includeFallbackColors = false, tinycolor.mostReadable(e2, ["#fff", "#000"], i));
  };
  names$1 = tinycolor.names = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" };
  hexNames = tinycolor.hexNames = flip(names$1);
  matchers = (CSS_UNIT = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)", PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", { CSS_UNIT: new RegExp(CSS_UNIT), rgb: new RegExp("rgb" + PERMISSIVE_MATCH3), rgba: new RegExp("rgba" + PERMISSIVE_MATCH4), hsl: new RegExp("hsl" + PERMISSIVE_MATCH3), hsla: new RegExp("hsla" + PERMISSIVE_MATCH4), hsv: new RegExp("hsv" + PERMISSIVE_MATCH3), hsva: new RegExp("hsva" + PERMISSIVE_MATCH4), hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ });
  omggif = {};
  try {
    GifWriter_1 = omggif.GifWriter = GifWriter, GifReader_1 = omggif.GifReader = GifReader;
  } catch (e2) {
  }
  BitmapImage$2 = class e2 {
    constructor(...t) {
      if (t.length === 0)
        throw new Error("constructor requires parameters");
      const i = t[0];
      if (i !== null && typeof i == "object")
        if (i instanceof e2) {
          const e3 = i.bitmap;
          this.bitmap = { width: e3.width, height: e3.height, data: new Buffer2(e3.width * e3.height * 4) }, e3.data.copy(this.bitmap.data);
        } else {
          if (!(i.width && i.height && i.data))
            throw new Error("unrecognized constructor parameters");
          this.bitmap = i;
        }
      else {
        if (typeof i != "number" || typeof t[1] != "number")
          throw new Error("unrecognized constructor parameters");
        {
          const e3 = i, r = t[1], n = t[2];
          this.bitmap = { width: e3, height: r }, Buffer2.isBuffer(n) ? this.bitmap.data = n : (this.bitmap.data = new Buffer2(e3 * r * 4), typeof n == "number" && this.fillRGBA(n));
        }
      }
    }
    blit(e3, t, i, r, n, a, o) {
      if (r + a > this.bitmap.width)
        throw new Error("copy exceeds width of source bitmap");
      if (t + a > e3.bitmap.width)
        throw new Error("copy exceeds width of target bitmap");
      if (n + o > this.bitmap.height)
        throw new Error("copy exceeds height of source bitmap");
      if (i + o > e3.bitmap.height)
        throw new Erro("copy exceeds height of target bitmap");
      const s = this.bitmap.data, l = e3.bitmap.data, u = 4 * this.bitmap.width, h = 4 * e3.bitmap.width, c = 4 * a;
      let f = n * u + 4 * r, d = i * h + 4 * t;
      for (;--o >= 0; )
        s.copy(l, d, f, f + c), f += u, d += h;
      return this;
    }
    fillRGBA(e3) {
      const t = this.bitmap.data, i = 4 * this.bitmap.height;
      let r = 0;
      for (;r < i; )
        t.writeUInt32BE(e3, r), r += 4;
      for (;r < t.length; )
        t.copy(t, r, 0, i), r += i;
      return this;
    }
    getRGBA(e3, t) {
      const i = 4 * (t * this.bitmap.width + e3);
      return this.bitmap.data.readUInt32BE(i);
    }
    getRGBASet() {
      const e3 = new Set, t = this.bitmap.data;
      for (let i = 0;i < t.length; i += 4)
        e3.add(t.readUInt32BE(i, true));
      return e3;
    }
    greyscale() {
      const e3 = this.bitmap.data;
      return this.scan(0, 0, this.bitmap.width, this.bitmap.height, (t, i, r) => {
        const n = Math.round(0.299 * e3[r] + 0.587 * e3[r + 1] + 0.114 * e3[r + 2]);
        e3[r] = n, e3[r + 1] = n, e3[r + 2] = n;
      }), this;
    }
    reframe(t, i, r, n, a) {
      const o = t < 0 ? 0 : t, s = i < 0 ? 0 : i, l = r + o > this.bitmap.width ? this.bitmap.width - o : r, u = n + s > this.bitmap.height ? this.bitmap.height - s : n, h = t < 0 ? -t : 0, c = i < 0 ? -i : 0;
      let f;
      if (a === undefined) {
        if (o !== t || s != i || l !== r || u !== n)
          throw new GifError("fillRGBA required for this reframing");
        f = new e2(r, n);
      } else
        f = new e2(r, n, a);
      return this.blit(f, h, c, o, s, l, u), this.bitmap = f.bitmap, this;
    }
    scale(e3) {
      if (e3 === 1)
        return;
      if (!Number.isInteger(e3) || e3 < 1)
        throw new Error("the scale must be an integer >= 1");
      const t = this.bitmap.width, i = this.bitmap.height, r = t * e3 * 4, n = this.bitmap.data, a = new Buffer2(i * r * e3);
      let o, s = 0, l = 0;
      for (let u = 0;u < i; ++u) {
        o = l;
        for (let i2 = 0;i2 < t; ++i2) {
          const t2 = n.readUInt32BE(s, true);
          for (let i3 = 0;i3 < e3; ++i3)
            a.writeUInt32BE(t2, l), l += 4;
          s += 4;
        }
        for (let t2 = 1;t2 < e3; ++t2)
          a.copy(a, l, o, l), l += r, o += r;
      }
      return this.bitmap = { width: t * e3, height: i * e3, data: a }, this;
    }
    scanAllCoords(e3) {
      const t = this.bitmap.width, i = this.bitmap.data.length;
      let r = 0, n = 0;
      for (let a = 0;a < i; a += 4)
        e3(r, n, a), ++r === t && (r = 0, ++n);
    }
    scanAllIndexes(e3) {
      const t = this.bitmap.data.length;
      for (let i = 0;i < t; i += 4)
        e3(i);
    }
  };
  bitmapimage = BitmapImage$2;
  gif$1 = {};
  Gif$1 = class {
    constructor(e3, t, i) {
      this.width = i.width, this.height = i.height, this.loops = i.loops, this.usesTransparency = i.usesTransparency, this.colorScope = i.colorScope, this.frames = t, this.buffer = e3;
    }
  };
  Gif$1.GlobalColorsPreferred = 0, Gif$1.GlobalColorsOnly = 1, Gif$1.LocalColorsOnly = 2;
  GifError$2 = class extends Error {
    constructor(e3) {
      super(e3), e3 instanceof Error && (this.stack = "Gif" + e3.stack);
    }
  };
  gif$1.Gif = Gif$1, gif$1.GifError = GifError$2;
  gifcodec = {};
  gifutil = {};
  _polyfillNode_fs = {};
  _polyfillNode_fs$1 = Object.freeze({ __proto__: null, default: _polyfillNode_fs });
  require$$0 = getAugmentedNamespace(_polyfillNode_fs$1);
  __defProp$3 = Object.defineProperty;
  __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  __getOwnPropNames2 = Object.getOwnPropertyNames;
  __hasOwnProp2 = Object.prototype.hasOwnProperty;
  __defNormalProp$3 = (e3, t, i) => (t in e3) ? __defProp$3(e3, t, { enumerable: true, configurable: true, writable: true, value: i }) : e3[t] = i;
  __markAsModule = (e3) => __defProp$3(e3, "__esModule", { value: true });
  __export$1 = (e3, t) => {
    for (var i in t)
      __defProp$3(e3, i, { get: t[i], enumerable: true });
  };
  __reExport = (e3, t, i, r) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let n of __getOwnPropNames2(t))
        !__hasOwnProp2.call(e3, n) && i && __defProp$3(e3, n, { get: () => t[n], enumerable: !(r = __getOwnPropDesc2(t, n)) || r.enumerable });
    return e3;
  };
  __toCommonJS2 = ((e3) => (t, i) => e3 && e3.get(t) || (i = __reExport(__markAsModule({}), t, 1), e3 && e3.set(t, i), i))(typeof WeakMap != "undefined" ? new WeakMap : 0);
  __publicField$3 = (e3, t, i) => (__defNormalProp$3(e3, typeof t != "symbol" ? t + "" : t, i), i);
  src_exports = {};
  __export$1(src_exports, { applyPalette: () => applyPalette, applyPaletteSync: () => applyPaletteSync$1, buildPalette: () => buildPalette, buildPaletteSync: () => buildPaletteSync$1, constants: () => constants_exports$1, conversion: () => conversion_exports$1, distance: () => distance_exports$1, image: () => image_exports$1, palette: () => palette_exports$1, quality: () => quality_exports$1, utils: () => utils_exports$1 });
  constants_exports$1 = {};
  __export$1(constants_exports$1, { bt709: () => bt709_exports$1 });
  bt709_exports$1 = {};
  __export$1(bt709_exports$1, { Y: () => Y$1, x: () => x$2, y: () => y$2 });
  Y$1 = ((e3) => (e3[e3.RED = 0.2126] = "RED", e3[e3.GREEN = 0.7152] = "GREEN", e3[e3.BLUE = 0.0722] = "BLUE", e3[e3.WHITE = 1] = "WHITE", e3))(Y$1 || {});
  x$2 = ((e3) => (e3[e3.RED = 0.64] = "RED", e3[e3.GREEN = 0.3] = "GREEN", e3[e3.BLUE = 0.15] = "BLUE", e3[e3.WHITE = 0.3127] = "WHITE", e3))(x$2 || {});
  y$2 = ((e3) => (e3[e3.RED = 0.33] = "RED", e3[e3.GREEN = 0.6] = "GREEN", e3[e3.BLUE = 0.06] = "BLUE", e3[e3.WHITE = 0.329] = "WHITE", e3))(y$2 || {});
  conversion_exports$1 = {};
  __export$1(conversion_exports$1, { lab2rgb: () => lab2rgb$1, lab2xyz: () => lab2xyz$1, rgb2hsl: () => rgb2hsl$1, rgb2lab: () => rgb2lab$1, rgb2xyz: () => rgb2xyz$1, xyz2lab: () => xyz2lab$1, xyz2rgb: () => xyz2rgb$1 });
  arithmetic_exports$1 = {};
  __export$1(arithmetic_exports$1, { degrees2radians: () => degrees2radians$1, inRange0to255: () => inRange0to255$1, inRange0to255Rounded: () => inRange0to255Rounded$1, intInRange: () => intInRange$1, max3: () => max3$1, min3: () => min3$1, stableSort: () => stableSort$1 });
  refX$1 = 0.95047;
  refY$1 = 1;
  refZ$1 = 1.08883;
  refX2$1 = 0.95047;
  refY2$1 = 1;
  refZ2$1 = 1.08883;
  distance_exports$1 = {};
  __export$1(distance_exports$1, { AbstractDistanceCalculator: () => AbstractDistanceCalculator$1, AbstractEuclidean: () => AbstractEuclidean$1, AbstractManhattan: () => AbstractManhattan$1, CIE94GraphicArts: () => CIE94GraphicArts$1, CIE94Textiles: () => CIE94Textiles$1, CIEDE2000: () => CIEDE2000$1, CMetric: () => CMetric$1, Euclidean: () => Euclidean$1, EuclideanBT709: () => EuclideanBT709$1, EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha$1, Manhattan: () => Manhattan$1, ManhattanBT709: () => ManhattanBT709$1, ManhattanNommyde: () => ManhattanNommyde$1, PNGQuant: () => PNGQuant$1 });
  AbstractDistanceCalculator$1 = class {
    constructor() {
      __publicField$3(this, "_maxDistance"), __publicField$3(this, "_whitePoint"), this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
    }
    setWhitePoint(e3, t, i, r) {
      this._whitePoint = { r: e3 > 0 ? 255 / e3 : 0, g: t > 0 ? 255 / t : 0, b: i > 0 ? 255 / i : 0, a: r > 0 ? 255 / r : 0 }, this._maxDistance = this.calculateRaw(e3, t, i, r, 0, 0, 0, 0);
    }
    calculateNormalized(e3, t) {
      return this.calculateRaw(e3.r, e3.g, e3.b, e3.a, t.r, t.g, t.b, t.a) / this._maxDistance;
    }
  };
  AbstractCIE94$1 = class extends AbstractDistanceCalculator$1 {
    calculateRaw(e3, t, i, r, n, a, o, s) {
      const l = rgb2lab$1(inRange0to255$1(e3 * this._whitePoint.r), inRange0to255$1(t * this._whitePoint.g), inRange0to255$1(i * this._whitePoint.b)), u = rgb2lab$1(inRange0to255$1(n * this._whitePoint.r), inRange0to255$1(a * this._whitePoint.g), inRange0to255$1(o * this._whitePoint.b)), h = l.L - u.L, c = l.a - u.a, f = l.b - u.b, d = Math.sqrt(l.a * l.a + l.b * l.b), p = d - Math.sqrt(u.a * u.a + u.b * u.b);
      let m = c * c + f * f - p * p;
      m = m < 0 ? 0 : Math.sqrt(m);
      const _ = (s - r) * this._whitePoint.a * this._kA;
      return Math.sqrt((h / this._Kl) ** 2 + (p / (1 + this._K1 * d)) ** 2 + (m / (1 + this._K2 * d)) ** 2 + _ ** 2);
    }
  };
  CIE94Textiles$1 = class extends AbstractCIE94$1 {
    _setDefaults() {
      this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 12.5 / 255;
    }
  };
  CIE94GraphicArts$1 = class extends AbstractCIE94$1 {
    _setDefaults() {
      this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 25 / 255;
    }
  };
  _CIEDE2000$1 = class extends AbstractDistanceCalculator$1 {
    _setDefaults() {
    }
    static _calculatehp(e3, t) {
      const i = Math.atan2(e3, t);
      return i >= 0 ? i : i + _CIEDE2000$1._deg360InRad;
    }
    static _calculateRT(e3, t) {
      const i = t ** 7, r = 2 * Math.sqrt(i / (i + _CIEDE2000$1._pow25to7)), n = _CIEDE2000$1._deg30InRad * Math.exp(-(((e3 - _CIEDE2000$1._deg275InRad) / _CIEDE2000$1._deg25InRad) ** 2));
      return -Math.sin(2 * n) * r;
    }
    static _calculateT(e3) {
      return 1 - 0.17 * Math.cos(e3 - _CIEDE2000$1._deg30InRad) + 0.24 * Math.cos(2 * e3) + 0.32 * Math.cos(3 * e3 + _CIEDE2000$1._deg6InRad) - 0.2 * Math.cos(4 * e3 - _CIEDE2000$1._deg63InRad);
    }
    static _calculate_ahp(e3, t, i, r) {
      const n = i + r;
      return e3 === 0 ? n : t <= _CIEDE2000$1._deg180InRad ? n / 2 : n < _CIEDE2000$1._deg360InRad ? (n + _CIEDE2000$1._deg360InRad) / 2 : (n - _CIEDE2000$1._deg360InRad) / 2;
    }
    static _calculate_dHp(e3, t, i, r) {
      let n;
      return n = e3 === 0 ? 0 : t <= _CIEDE2000$1._deg180InRad ? i - r : i <= r ? i - r + _CIEDE2000$1._deg360InRad : i - r - _CIEDE2000$1._deg360InRad, 2 * Math.sqrt(e3) * Math.sin(n / 2);
    }
    calculateRaw(e3, t, i, r, n, a, o, s) {
      const l = rgb2lab$1(inRange0to255$1(e3 * this._whitePoint.r), inRange0to255$1(t * this._whitePoint.g), inRange0to255$1(i * this._whitePoint.b)), u = rgb2lab$1(inRange0to255$1(n * this._whitePoint.r), inRange0to255$1(a * this._whitePoint.g), inRange0to255$1(o * this._whitePoint.b)), h = (s - r) * this._whitePoint.a * _CIEDE2000$1._kA, c = this.calculateRawInLab(l, u);
      return Math.sqrt(c + h * h);
    }
    calculateRawInLab(e3, t) {
      const { L: i, a: r, b: n } = e3, a = t.L, o = t.a, s = t.b, l = ((Math.sqrt(r * r + n * n) + Math.sqrt(o * o + s * s)) / 2) ** 7, u = 0.5 * (1 - Math.sqrt(l / (l + _CIEDE2000$1._pow25to7))), h = (1 + u) * r, c = (1 + u) * o, f = Math.sqrt(h * h + n * n), d = Math.sqrt(c * c + s * s), p = f * d, m = _CIEDE2000$1._calculatehp(n, h), _ = _CIEDE2000$1._calculatehp(s, c), g = Math.abs(m - _), b2 = a - i, y = d - f, w = _CIEDE2000$1._calculate_dHp(p, g, _, m), v = _CIEDE2000$1._calculate_ahp(p, g, m, _), x = (f + d) / 2, E = ((i + a) / 2 - 50) ** 2, k = y / (1 + 0.045 * x), S = w / (1 + 0.015 * _CIEDE2000$1._calculateT(v) * x);
      return (b2 / (1 + 0.015 * E / Math.sqrt(20 + E))) ** 2 + k ** 2 + S ** 2 + _CIEDE2000$1._calculateRT(v, x) * k * S;
    }
  };
  CIEDE2000$1 = _CIEDE2000$1;
  __publicField$3(CIEDE2000$1, "_kA", 25 / 255), __publicField$3(CIEDE2000$1, "_pow25to7", 25 ** 7), __publicField$3(CIEDE2000$1, "_deg360InRad", degrees2radians$1(360)), __publicField$3(CIEDE2000$1, "_deg180InRad", degrees2radians$1(180)), __publicField$3(CIEDE2000$1, "_deg30InRad", degrees2radians$1(30)), __publicField$3(CIEDE2000$1, "_deg6InRad", degrees2radians$1(6)), __publicField$3(CIEDE2000$1, "_deg63InRad", degrees2radians$1(63)), __publicField$3(CIEDE2000$1, "_deg275InRad", degrees2radians$1(275)), __publicField$3(CIEDE2000$1, "_deg25InRad", degrees2radians$1(25));
  CMetric$1 = class extends AbstractDistanceCalculator$1 {
    calculateRaw(e3, t, i, r, n, a, o, s) {
      const l = (e3 + n) / 2 * this._whitePoint.r, u = (e3 - n) * this._whitePoint.r, h = (t - a) * this._whitePoint.g, c = (i - o) * this._whitePoint.b, f = ((512 + l) * u * u >> 8) + 4 * h * h + ((767 - l) * c * c >> 8), d = (s - r) * this._whitePoint.a;
      return Math.sqrt(f + d * d);
    }
    _setDefaults() {
    }
  };
  AbstractEuclidean$1 = class extends AbstractDistanceCalculator$1 {
    calculateRaw(e3, t, i, r, n, a, o, s) {
      const l = n - e3, u = a - t, h = o - i, c = s - r;
      return Math.sqrt(this._kR * l * l + this._kG * u * u + this._kB * h * h + this._kA * c * c);
    }
  };
  Euclidean$1 = class extends AbstractEuclidean$1 {
    _setDefaults() {
      this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
    }
  };
  EuclideanBT709$1 = class extends AbstractEuclidean$1 {
    _setDefaults() {
      this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
    }
  };
  EuclideanBT709NoAlpha$1 = class extends AbstractEuclidean$1 {
    _setDefaults() {
      this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 0;
    }
  };
  AbstractManhattan$1 = class extends AbstractDistanceCalculator$1 {
    calculateRaw(e3, t, i, r, n, a, o, s) {
      let l = n - e3, u = a - t, h = o - i, c = s - r;
      return l < 0 && (l = 0 - l), u < 0 && (u = 0 - u), h < 0 && (h = 0 - h), c < 0 && (c = 0 - c), this._kR * l + this._kG * u + this._kB * h + this._kA * c;
    }
  };
  Manhattan$1 = class extends AbstractManhattan$1 {
    _setDefaults() {
      this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
    }
  };
  ManhattanNommyde$1 = class extends AbstractManhattan$1 {
    _setDefaults() {
      this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
    }
  };
  ManhattanBT709$1 = class extends AbstractManhattan$1 {
    _setDefaults() {
      this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
    }
  };
  PNGQuant$1 = class extends AbstractDistanceCalculator$1 {
    calculateRaw(e3, t, i, r, n, a, o, s) {
      const l = (s - r) * this._whitePoint.a;
      return this._colordifferenceCh(e3 * this._whitePoint.r, n * this._whitePoint.r, l) + this._colordifferenceCh(t * this._whitePoint.g, a * this._whitePoint.g, l) + this._colordifferenceCh(i * this._whitePoint.b, o * this._whitePoint.b, l);
    }
    _colordifferenceCh(e3, t, i) {
      const r = e3 - t, n = r + i;
      return r * r + n * n;
    }
    _setDefaults() {
    }
  };
  palette_exports$1 = {};
  __export$1(palette_exports$1, { AbstractPaletteQuantizer: () => AbstractPaletteQuantizer$1, ColorHistogram: () => ColorHistogram$1, NeuQuant: () => NeuQuant$1, NeuQuantFloat: () => NeuQuantFloat$1, RGBQuant: () => RGBQuant$1, WuColorCube: () => WuColorCube$1, WuQuant: () => WuQuant$1 });
  AbstractPaletteQuantizer$1 = class {
    quantizeSync() {
      for (const e3 of this.quantize())
        if (e3.palette)
          return e3.palette;
      throw new Error("unreachable");
    }
  };
  Point$1 = class {
    constructor() {
      __publicField$3(this, "r"), __publicField$3(this, "g"), __publicField$3(this, "b"), __publicField$3(this, "a"), __publicField$3(this, "uint32"), __publicField$3(this, "rgba"), this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
    }
    static createByQuadruplet(e3) {
      const t = new Point$1;
      return t.r = 0 | e3[0], t.g = 0 | e3[1], t.b = 0 | e3[2], t.a = 0 | e3[3], t._loadUINT32(), t._loadQuadruplet(), t;
    }
    static createByRGBA(e3, t, i, r) {
      const n = new Point$1;
      return n.r = 0 | e3, n.g = 0 | t, n.b = 0 | i, n.a = 0 | r, n._loadUINT32(), n._loadQuadruplet(), n;
    }
    static createByUint32(e3) {
      const t = new Point$1;
      return t.uint32 = e3 >>> 0, t._loadRGBA(), t._loadQuadruplet(), t;
    }
    from(e3) {
      this.r = e3.r, this.g = e3.g, this.b = e3.b, this.a = e3.a, this.uint32 = e3.uint32, this.rgba[0] = e3.r, this.rgba[1] = e3.g, this.rgba[2] = e3.b, this.rgba[3] = e3.a;
    }
    getLuminosity(e3) {
      let t = this.r, i = this.g, r = this.b;
      return e3 && (t = Math.min(255, 255 - this.a + this.a * t / 255), i = Math.min(255, 255 - this.a + this.a * i / 255), r = Math.min(255, 255 - this.a + this.a * r / 255)), 0.2126 * t + 0.7152 * i + 0.0722 * r;
    }
    _loadUINT32() {
      this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
    }
    _loadRGBA() {
      this.r = 255 & this.uint32, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
    }
    _loadQuadruplet() {
      this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
    }
  };
  PointContainer$1 = class {
    constructor() {
      __publicField$3(this, "_pointArray"), __publicField$3(this, "_width"), __publicField$3(this, "_height"), this._width = 0, this._height = 0, this._pointArray = [];
    }
    getWidth() {
      return this._width;
    }
    getHeight() {
      return this._height;
    }
    setWidth(e3) {
      this._width = e3;
    }
    setHeight(e3) {
      this._height = e3;
    }
    getPointArray() {
      return this._pointArray;
    }
    clone() {
      const e3 = new PointContainer$1;
      e3._width = this._width, e3._height = this._height;
      for (let t = 0, i = this._pointArray.length;t < i; t++)
        e3._pointArray[t] = Point$1.createByUint32(0 | this._pointArray[t].uint32);
      return e3;
    }
    toUint32Array() {
      const e3 = this._pointArray.length, t = new Uint32Array(e3);
      for (let i = 0;i < e3; i++)
        t[i] = this._pointArray[i].uint32;
      return t;
    }
    toUint8Array() {
      return new Uint8Array(this.toUint32Array().buffer);
    }
    static fromHTMLImageElement(e3) {
      const { naturalWidth: t, naturalHeight: i } = e3, r = document.createElement("canvas");
      r.width = t, r.height = i;
      return r.getContext("2d").drawImage(e3, 0, 0, t, i, 0, 0, t, i), PointContainer$1.fromHTMLCanvasElement(r);
    }
    static fromHTMLCanvasElement(e3) {
      const { width: t, height: i } = e3, r = e3.getContext("2d").getImageData(0, 0, t, i);
      return PointContainer$1.fromImageData(r);
    }
    static fromImageData(e3) {
      const { width: t, height: i } = e3;
      return PointContainer$1.fromUint8Array(e3.data, t, i);
    }
    static fromUint8Array(e3, t, i) {
      switch (Object.prototype.toString.call(e3)) {
        case "[object Uint8ClampedArray]":
        case "[object Uint8Array]":
          break;
        default:
          e3 = new Uint8Array(e3);
      }
      const r = new Uint32Array(e3.buffer);
      return PointContainer$1.fromUint32Array(r, t, i);
    }
    static fromUint32Array(e3, t, i) {
      const r = new PointContainer$1;
      r._width = t, r._height = i;
      for (let t2 = 0, i2 = e3.length;t2 < i2; t2++)
        r._pointArray[t2] = Point$1.createByUint32(0 | e3[t2]);
      return r;
    }
    static fromBuffer(e3, t, i) {
      const r = new Uint32Array(e3.buffer, e3.byteOffset, e3.byteLength / Uint32Array.BYTES_PER_ELEMENT);
      return PointContainer$1.fromUint32Array(r, t, i);
    }
  };
  hueGroups$1 = 10;
  Palette$1 = class {
    constructor() {
      __publicField$3(this, "_pointContainer"), __publicField$3(this, "_pointArray", []), __publicField$3(this, "_i32idx", {}), this._pointContainer = new PointContainer$1, this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
    }
    add(e3) {
      this._pointArray.push(e3), this._pointContainer.setWidth(this._pointArray.length);
    }
    has(e3) {
      for (let t = this._pointArray.length - 1;t >= 0; t--)
        if (e3.uint32 === this._pointArray[t].uint32)
          return true;
      return false;
    }
    getNearestColor(e3, t) {
      return this._pointArray[0 | this._getNearestIndex(e3, t)];
    }
    getPointContainer() {
      return this._pointContainer;
    }
    _nearestPointFromCache(e3) {
      return typeof this._i32idx[e3] == "number" ? this._i32idx[e3] : -1;
    }
    _getNearestIndex(e3, t) {
      let i = this._nearestPointFromCache("" + t.uint32);
      if (i >= 0)
        return i;
      let r = Number.MAX_VALUE;
      i = 0;
      for (let n = 0, a = this._pointArray.length;n < a; n++) {
        const a2 = this._pointArray[n], o = e3.calculateRaw(t.r, t.g, t.b, t.a, a2.r, a2.g, a2.b, a2.a);
        o < r && (r = o, i = n);
      }
      return this._i32idx[t.uint32] = i, i;
    }
    sort() {
      this._i32idx = {}, this._pointArray.sort((e3, t) => {
        const i = rgb2hsl$1(e3.r, e3.g, e3.b), r = rgb2hsl$1(t.r, t.g, t.b), n = e3.r === e3.g && e3.g === e3.b ? 0 : 1 + hueGroup$1(i.h, hueGroups$1), a = (t.r === t.g && t.g === t.b ? 0 : 1 + hueGroup$1(r.h, hueGroups$1)) - n;
        if (a)
          return -a;
        const o = e3.getLuminosity(true), s = t.getLuminosity(true);
        if (s - o != 0)
          return s - o;
        const l = (100 * r.s | 0) - (100 * i.s | 0);
        return l ? -l : 0;
      });
    }
  };
  utils_exports$1 = {};
  __export$1(utils_exports$1, { HueStatistics: () => HueStatistics$1, Palette: () => Palette$1, Point: () => Point$1, PointContainer: () => PointContainer$1, ProgressTracker: () => ProgressTracker$1, arithmetic: () => arithmetic_exports$1 });
  HueGroup$1 = class {
    constructor() {
      __publicField$3(this, "num", 0), __publicField$3(this, "cols", []);
    }
  };
  HueStatistics$1 = class {
    constructor(e3, t) {
      __publicField$3(this, "_numGroups"), __publicField$3(this, "_minCols"), __publicField$3(this, "_stats"), __publicField$3(this, "_groupsFull"), this._numGroups = e3, this._minCols = t, this._stats = [];
      for (let t2 = 0;t2 <= e3; t2++)
        this._stats[t2] = new HueGroup$1;
      this._groupsFull = 0;
    }
    check(e3) {
      this._groupsFull === this._numGroups + 1 && (this.check = () => {
      });
      const t = 255 & e3, i = e3 >>> 8 & 255, r = e3 >>> 16 & 255, n = t === i && i === r ? 0 : 1 + hueGroup$1(rgb2hsl$1(t, i, r).h, this._numGroups), a = this._stats[n], o = this._minCols;
      a.num++, a.num > o || (a.num === o && this._groupsFull++, a.num <= o && this._stats[n].cols.push(e3));
    }
    injectIntoDictionary(e3) {
      for (let t = 0;t <= this._numGroups; t++)
        this._stats[t].num <= this._minCols && this._stats[t].cols.forEach((t2) => {
          e3[t2] ? e3[t2]++ : e3[t2] = 1;
        });
    }
    injectIntoArray(e3) {
      for (let t = 0;t <= this._numGroups; t++)
        this._stats[t].num <= this._minCols && this._stats[t].cols.forEach((t2) => {
          e3.indexOf(t2) === -1 && e3.push(t2);
        });
    }
  };
  _ProgressTracker$1 = class {
    constructor(e3, t) {
      __publicField$3(this, "progress"), __publicField$3(this, "_step"), __publicField$3(this, "_range"), __publicField$3(this, "_last"), __publicField$3(this, "_progressRange"), this._range = e3, this._progressRange = t, this._step = Math.max(1, this._range / (_ProgressTracker$1.steps + 1) | 0), this._last = -this._step, this.progress = 0;
    }
    shouldNotify(e3) {
      return e3 - this._last >= this._step && (this._last = e3, this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange), true);
    }
  };
  ProgressTracker$1 = _ProgressTracker$1;
  __publicField$3(ProgressTracker$1, "steps", 100);
  networkBiasShift$1 = 3;
  Neuron$1 = class {
    constructor(e3) {
      __publicField$3(this, "r"), __publicField$3(this, "g"), __publicField$3(this, "b"), __publicField$3(this, "a"), this.r = this.g = this.b = this.a = e3;
    }
    toPoint() {
      return Point$1.createByRGBA(this.r >> networkBiasShift$1, this.g >> networkBiasShift$1, this.b >> networkBiasShift$1, this.a >> networkBiasShift$1);
    }
    subtract(e3, t, i, r) {
      this.r -= 0 | e3, this.g -= 0 | t, this.b -= 0 | i, this.a -= 0 | r;
    }
  };
  _NeuQuant$1 = class extends AbstractPaletteQuantizer$1 {
    constructor(e3, t = 256) {
      super(), __publicField$3(this, "_pointArray"), __publicField$3(this, "_networkSize"), __publicField$3(this, "_network"), __publicField$3(this, "_sampleFactor"), __publicField$3(this, "_radPower"), __publicField$3(this, "_freq"), __publicField$3(this, "_bias"), __publicField$3(this, "_distance"), this._distance = e3, this._pointArray = [], this._sampleFactor = 1, this._networkSize = t, this._distance.setWhitePoint(255 << networkBiasShift$1, 255 << networkBiasShift$1, 255 << networkBiasShift$1, 255 << networkBiasShift$1);
    }
    sample(e3) {
      this._pointArray = this._pointArray.concat(e3.getPointArray());
    }
    *quantize() {
      this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
    }
    _init() {
      this._freq = [], this._bias = [], this._radPower = [], this._network = [];
      for (let e3 = 0;e3 < this._networkSize; e3++)
        this._network[e3] = new Neuron$1((e3 << networkBiasShift$1 + 8) / this._networkSize | 0), this._freq[e3] = _NeuQuant$1._initialBias / this._networkSize | 0, this._bias[e3] = 0;
    }
    *_learn() {
      let e3 = this._sampleFactor;
      const t = this._pointArray.length;
      t < _NeuQuant$1._minpicturebytes && (e3 = 1);
      const i = 30 + (e3 - 1) / 3 | 0, r = t / e3 | 0;
      let n, a = r / _NeuQuant$1._nCycles | 0, o = _NeuQuant$1._initAlpha, s = (this._networkSize >> 3) * _NeuQuant$1._radiusBias, l = s >> _NeuQuant$1._radiusBiasShift;
      l <= 1 && (l = 0);
      for (let e4 = 0;e4 < l; e4++)
        this._radPower[e4] = o * ((l * l - e4 * e4) * _NeuQuant$1._radBias / (l * l)) >>> 0;
      n = t < _NeuQuant$1._minpicturebytes ? 1 : t % _NeuQuant$1._prime1 != 0 ? _NeuQuant$1._prime1 : t % _NeuQuant$1._prime2 != 0 ? _NeuQuant$1._prime2 : t % _NeuQuant$1._prime3 != 0 ? _NeuQuant$1._prime3 : _NeuQuant$1._prime4;
      const u = new ProgressTracker$1(r, 99);
      for (let e4 = 0, h = 0;e4 < r; ) {
        u.shouldNotify(e4) && (yield { progress: u.progress });
        const r2 = this._pointArray[h], c = r2.b << networkBiasShift$1, f = r2.g << networkBiasShift$1, d = r2.r << networkBiasShift$1, p = r2.a << networkBiasShift$1, m = this._contest(c, f, d, p);
        if (this._alterSingle(o, m, c, f, d, p), l !== 0 && this._alterNeighbour(l, m, c, f, d, p), h += n, h >= t && (h -= t), e4++, a === 0 && (a = 1), e4 % a == 0) {
          o -= o / i | 0, s -= s / _NeuQuant$1._radiusDecrease | 0, l = s >> _NeuQuant$1._radiusBiasShift, l <= 1 && (l = 0);
          for (let e5 = 0;e5 < l; e5++)
            this._radPower[e5] = o * ((l * l - e5 * e5) * _NeuQuant$1._radBias / (l * l)) >>> 0;
        }
      }
    }
    _buildPalette() {
      const e3 = new Palette$1;
      return this._network.forEach((t) => {
        e3.add(t.toPoint());
      }), e3.sort(), e3;
    }
    _alterNeighbour(e3, t, i, r, n, a) {
      let o = t - e3;
      o < -1 && (o = -1);
      let s = t + e3;
      s > this._networkSize && (s = this._networkSize);
      let l = t + 1, u = t - 1, h = 1;
      for (;l < s || u > o; ) {
        const e4 = this._radPower[h++] / _NeuQuant$1._alphaRadBias;
        if (l < s) {
          const t2 = this._network[l++];
          t2.subtract(e4 * (t2.r - n), e4 * (t2.g - r), e4 * (t2.b - i), e4 * (t2.a - a));
        }
        if (u > o) {
          const t2 = this._network[u--];
          t2.subtract(e4 * (t2.r - n), e4 * (t2.g - r), e4 * (t2.b - i), e4 * (t2.a - a));
        }
      }
    }
    _alterSingle(e3, t, i, r, n, a) {
      e3 /= _NeuQuant$1._initAlpha;
      const o = this._network[t];
      o.subtract(e3 * (o.r - n), e3 * (o.g - r), e3 * (o.b - i), e3 * (o.a - a));
    }
    _contest(e3, t, i, r) {
      const n = 1020 << networkBiasShift$1;
      let a = ~(1 << 31), o = a, s = -1, l = s;
      for (let u = 0;u < this._networkSize; u++) {
        const h = this._network[u], c = this._distance.calculateNormalized(h, { r: i, g: t, b: e3, a: r }) * n | 0;
        c < a && (a = c, s = u);
        const f = c - (this._bias[u] >> _NeuQuant$1._initialBiasShift - networkBiasShift$1);
        f < o && (o = f, l = u);
        const d = this._freq[u] >> _NeuQuant$1._betaShift;
        this._freq[u] -= d, this._bias[u] += d << _NeuQuant$1._gammaShift;
      }
      return this._freq[s] += _NeuQuant$1._beta, this._bias[s] -= _NeuQuant$1._betaGamma, l;
    }
  };
  NeuQuant$1 = _NeuQuant$1;
  __publicField$3(NeuQuant$1, "_prime1", 499), __publicField$3(NeuQuant$1, "_prime2", 491), __publicField$3(NeuQuant$1, "_prime3", 487), __publicField$3(NeuQuant$1, "_prime4", 503), __publicField$3(NeuQuant$1, "_minpicturebytes", _NeuQuant$1._prime4), __publicField$3(NeuQuant$1, "_nCycles", 100), __publicField$3(NeuQuant$1, "_initialBiasShift", 16), __publicField$3(NeuQuant$1, "_initialBias", 1 << _NeuQuant$1._initialBiasShift), __publicField$3(NeuQuant$1, "_gammaShift", 10), __publicField$3(NeuQuant$1, "_betaShift", 10), __publicField$3(NeuQuant$1, "_beta", _NeuQuant$1._initialBias >> _NeuQuant$1._betaShift), __publicField$3(NeuQuant$1, "_betaGamma", _NeuQuant$1._initialBias << _NeuQuant$1._gammaShift - _NeuQuant$1._betaShift), __publicField$3(NeuQuant$1, "_radiusBiasShift", 6), __publicField$3(NeuQuant$1, "_radiusBias", 1 << _NeuQuant$1._radiusBiasShift), __publicField$3(NeuQuant$1, "_radiusDecrease", 30), __publicField$3(NeuQuant$1, "_alphaBiasShift", 10), __publicField$3(NeuQuant$1, "_initAlpha", 1 << _NeuQuant$1._alphaBiasShift), __publicField$3(NeuQuant$1, "_radBiasShift", 8), __publicField$3(NeuQuant$1, "_radBias", 1 << _NeuQuant$1._radBiasShift), __publicField$3(NeuQuant$1, "_alphaRadBiasShift", _NeuQuant$1._alphaBiasShift + _NeuQuant$1._radBiasShift), __publicField$3(NeuQuant$1, "_alphaRadBias", 1 << _NeuQuant$1._alphaRadBiasShift);
  networkBiasShift2$1 = 3;
  NeuronFloat$1 = class {
    constructor(e3) {
      __publicField$3(this, "r"), __publicField$3(this, "g"), __publicField$3(this, "b"), __publicField$3(this, "a"), this.r = this.g = this.b = this.a = e3;
    }
    toPoint() {
      return Point$1.createByRGBA(this.r >> networkBiasShift2$1, this.g >> networkBiasShift2$1, this.b >> networkBiasShift2$1, this.a >> networkBiasShift2$1);
    }
    subtract(e3, t, i, r) {
      this.r -= e3, this.g -= t, this.b -= i, this.a -= r;
    }
  };
  _NeuQuantFloat$1 = class extends AbstractPaletteQuantizer$1 {
    constructor(e3, t = 256) {
      super(), __publicField$3(this, "_pointArray"), __publicField$3(this, "_networkSize"), __publicField$3(this, "_network"), __publicField$3(this, "_sampleFactor"), __publicField$3(this, "_radPower"), __publicField$3(this, "_freq"), __publicField$3(this, "_bias"), __publicField$3(this, "_distance"), this._distance = e3, this._pointArray = [], this._sampleFactor = 1, this._networkSize = t, this._distance.setWhitePoint(255 << networkBiasShift2$1, 255 << networkBiasShift2$1, 255 << networkBiasShift2$1, 255 << networkBiasShift2$1);
    }
    sample(e3) {
      this._pointArray = this._pointArray.concat(e3.getPointArray());
    }
    *quantize() {
      this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
    }
    _init() {
      this._freq = [], this._bias = [], this._radPower = [], this._network = [];
      for (let e3 = 0;e3 < this._networkSize; e3++)
        this._network[e3] = new NeuronFloat$1((e3 << networkBiasShift2$1 + 8) / this._networkSize), this._freq[e3] = _NeuQuantFloat$1._initialBias / this._networkSize, this._bias[e3] = 0;
    }
    *_learn() {
      let e3 = this._sampleFactor;
      const t = this._pointArray.length;
      t < _NeuQuantFloat$1._minpicturebytes && (e3 = 1);
      const i = 30 + (e3 - 1) / 3, r = t / e3;
      let n, a = r / _NeuQuantFloat$1._nCycles | 0, o = _NeuQuantFloat$1._initAlpha, s = (this._networkSize >> 3) * _NeuQuantFloat$1._radiusBias, l = s >> _NeuQuantFloat$1._radiusBiasShift;
      l <= 1 && (l = 0);
      for (let e4 = 0;e4 < l; e4++)
        this._radPower[e4] = o * ((l * l - e4 * e4) * _NeuQuantFloat$1._radBias / (l * l));
      n = t < _NeuQuantFloat$1._minpicturebytes ? 1 : t % _NeuQuantFloat$1._prime1 != 0 ? _NeuQuantFloat$1._prime1 : t % _NeuQuantFloat$1._prime2 != 0 ? _NeuQuantFloat$1._prime2 : t % _NeuQuantFloat$1._prime3 != 0 ? _NeuQuantFloat$1._prime3 : _NeuQuantFloat$1._prime4;
      const u = new ProgressTracker$1(r, 99);
      for (let e4 = 0, h = 0;e4 < r; ) {
        u.shouldNotify(e4) && (yield { progress: u.progress });
        const r2 = this._pointArray[h], c = r2.b << networkBiasShift2$1, f = r2.g << networkBiasShift2$1, d = r2.r << networkBiasShift2$1, p = r2.a << networkBiasShift2$1, m = this._contest(c, f, d, p);
        if (this._alterSingle(o, m, c, f, d, p), l !== 0 && this._alterNeighbour(l, m, c, f, d, p), h += n, h >= t && (h -= t), e4++, a === 0 && (a = 1), e4 % a == 0) {
          o -= o / i, s -= s / _NeuQuantFloat$1._radiusDecrease, l = s >> _NeuQuantFloat$1._radiusBiasShift, l <= 1 && (l = 0);
          for (let e5 = 0;e5 < l; e5++)
            this._radPower[e5] = o * ((l * l - e5 * e5) * _NeuQuantFloat$1._radBias / (l * l));
        }
      }
    }
    _buildPalette() {
      const e3 = new Palette$1;
      return this._network.forEach((t) => {
        e3.add(t.toPoint());
      }), e3.sort(), e3;
    }
    _alterNeighbour(e3, t, i, r, n, a) {
      let o = t - e3;
      o < -1 && (o = -1);
      let s = t + e3;
      s > this._networkSize && (s = this._networkSize);
      let l = t + 1, u = t - 1, h = 1;
      for (;l < s || u > o; ) {
        const e4 = this._radPower[h++] / _NeuQuantFloat$1._alphaRadBias;
        if (l < s) {
          const t2 = this._network[l++];
          t2.subtract(e4 * (t2.r - n), e4 * (t2.g - r), e4 * (t2.b - i), e4 * (t2.a - a));
        }
        if (u > o) {
          const t2 = this._network[u--];
          t2.subtract(e4 * (t2.r - n), e4 * (t2.g - r), e4 * (t2.b - i), e4 * (t2.a - a));
        }
      }
    }
    _alterSingle(e3, t, i, r, n, a) {
      e3 /= _NeuQuantFloat$1._initAlpha;
      const o = this._network[t];
      o.subtract(e3 * (o.r - n), e3 * (o.g - r), e3 * (o.b - i), e3 * (o.a - a));
    }
    _contest(e3, t, i, r) {
      const n = 1020 << networkBiasShift2$1;
      let a = ~(1 << 31), o = a, s = -1, l = s;
      for (let u = 0;u < this._networkSize; u++) {
        const h = this._network[u], c = this._distance.calculateNormalized(h, { r: i, g: t, b: e3, a: r }) * n;
        c < a && (a = c, s = u);
        const f = c - (this._bias[u] >> _NeuQuantFloat$1._initialBiasShift - networkBiasShift2$1);
        f < o && (o = f, l = u);
        const d = this._freq[u] >> _NeuQuantFloat$1._betaShift;
        this._freq[u] -= d, this._bias[u] += d << _NeuQuantFloat$1._gammaShift;
      }
      return this._freq[s] += _NeuQuantFloat$1._beta, this._bias[s] -= _NeuQuantFloat$1._betaGamma, l;
    }
  };
  NeuQuantFloat$1 = _NeuQuantFloat$1;
  __publicField$3(NeuQuantFloat$1, "_prime1", 499), __publicField$3(NeuQuantFloat$1, "_prime2", 491), __publicField$3(NeuQuantFloat$1, "_prime3", 487), __publicField$3(NeuQuantFloat$1, "_prime4", 503), __publicField$3(NeuQuantFloat$1, "_minpicturebytes", _NeuQuantFloat$1._prime4), __publicField$3(NeuQuantFloat$1, "_nCycles", 100), __publicField$3(NeuQuantFloat$1, "_initialBiasShift", 16), __publicField$3(NeuQuantFloat$1, "_initialBias", 1 << _NeuQuantFloat$1._initialBiasShift), __publicField$3(NeuQuantFloat$1, "_gammaShift", 10), __publicField$3(NeuQuantFloat$1, "_betaShift", 10), __publicField$3(NeuQuantFloat$1, "_beta", _NeuQuantFloat$1._initialBias >> _NeuQuantFloat$1._betaShift), __publicField$3(NeuQuantFloat$1, "_betaGamma", _NeuQuantFloat$1._initialBias << _NeuQuantFloat$1._gammaShift - _NeuQuantFloat$1._betaShift), __publicField$3(NeuQuantFloat$1, "_radiusBiasShift", 6), __publicField$3(NeuQuantFloat$1, "_radiusBias", 1 << _NeuQuantFloat$1._radiusBiasShift), __publicField$3(NeuQuantFloat$1, "_radiusDecrease", 30), __publicField$3(NeuQuantFloat$1, "_alphaBiasShift", 10), __publicField$3(NeuQuantFloat$1, "_initAlpha", 1 << _NeuQuantFloat$1._alphaBiasShift), __publicField$3(NeuQuantFloat$1, "_radBiasShift", 8), __publicField$3(NeuQuantFloat$1, "_radBias", 1 << _NeuQuantFloat$1._radBiasShift), __publicField$3(NeuQuantFloat$1, "_alphaRadBiasShift", _NeuQuantFloat$1._alphaBiasShift + _NeuQuantFloat$1._radBiasShift), __publicField$3(NeuQuantFloat$1, "_alphaRadBias", 1 << _NeuQuantFloat$1._alphaRadBiasShift);
  _ColorHistogram$1 = class {
    constructor(e3, t) {
      __publicField$3(this, "_method"), __publicField$3(this, "_hueStats"), __publicField$3(this, "_histogram"), __publicField$3(this, "_initColors"), __publicField$3(this, "_minHueCols"), this._method = e3, this._minHueCols = t << 2, this._initColors = t << 2, this._hueStats = new HueStatistics$1(_ColorHistogram$1._hueGroups, this._minHueCols), this._histogram = Object.create(null);
    }
    sample(e3) {
      switch (this._method) {
        case 1:
          this._colorStats1D(e3);
          break;
        case 2:
          this._colorStats2D(e3);
      }
    }
    getImportanceSortedColorsIDXI32() {
      const e3 = stableSort$1(Object.keys(this._histogram), (e4, t2) => this._histogram[t2] - this._histogram[e4]);
      if (e3.length === 0)
        return [];
      let t;
      switch (this._method) {
        case 1:
          const i = Math.min(e3.length, this._initColors), r = e3[i - 1], n = this._histogram[r];
          t = e3.slice(0, i);
          let a = i;
          const o = e3.length;
          for (;a < o && this._histogram[e3[a]] === n; )
            t.push(e3[a++]);
          this._hueStats.injectIntoArray(t);
          break;
        case 2:
          t = e3;
          break;
        default:
          throw new Error("Incorrect method");
      }
      return t.map((e4) => +e4);
    }
    _colorStats1D(e3) {
      const t = this._histogram, i = e3.getPointArray(), r = i.length;
      for (let e4 = 0;e4 < r; e4++) {
        const r2 = i[e4].uint32;
        this._hueStats.check(r2), r2 in t ? t[r2]++ : t[r2] = 1;
      }
    }
    _colorStats2D(e3) {
      const t = e3.getWidth(), i = e3.getHeight(), r = e3.getPointArray(), n = _ColorHistogram$1._boxSize[0], a = _ColorHistogram$1._boxSize[1], o = n * a, s = this._makeBoxes(t, i, n, a), l = this._histogram;
      s.forEach((e4) => {
        let i2 = Math.round(e4.w * e4.h / o) * _ColorHistogram$1._boxPixels;
        i2 < 2 && (i2 = 2);
        const n2 = {};
        this._iterateBox(e4, t, (e5) => {
          const t2 = r[e5].uint32;
          this._hueStats.check(t2), t2 in l ? l[t2]++ : (t2 in n2) ? ++n2[t2] >= i2 && (l[t2] = n2[t2]) : n2[t2] = 1;
        });
      }), this._hueStats.injectIntoDictionary(l);
    }
    _iterateBox(e3, t, i) {
      const r = e3, n = r.y * t + r.x, a = (r.y + r.h - 1) * t + (r.x + r.w - 1), o = t - r.w + 1;
      let s = 0, l = n;
      do {
        i.call(this, l), l += ++s % r.w == 0 ? o : 1;
      } while (l <= a);
    }
    _makeBoxes(e3, t, i, r) {
      const n = e3 % i, a = t % r, o = e3 - n, s = t - a, l = [];
      for (let u = 0;u < t; u += r)
        for (let t2 = 0;t2 < e3; t2 += i)
          l.push({ x: t2, y: u, w: t2 === o ? n : i, h: u === s ? a : r });
      return l;
    }
  };
  ColorHistogram$1 = _ColorHistogram$1;
  __publicField$3(ColorHistogram$1, "_boxSize", [64, 64]), __publicField$3(ColorHistogram$1, "_boxPixels", 2), __publicField$3(ColorHistogram$1, "_hueGroups", 10);
  RemovedColor$1 = class {
    constructor(e3, t, i) {
      __publicField$3(this, "index"), __publicField$3(this, "color"), __publicField$3(this, "distance"), this.index = e3, this.color = t, this.distance = i;
    }
  };
  RGBQuant$1 = class extends AbstractPaletteQuantizer$1 {
    constructor(e3, t = 256, i = 2) {
      super(), __publicField$3(this, "_colors"), __publicField$3(this, "_initialDistance"), __publicField$3(this, "_distanceIncrement"), __publicField$3(this, "_histogram"), __publicField$3(this, "_distance"), this._distance = e3, this._colors = t, this._histogram = new ColorHistogram$1(i, t), this._initialDistance = 0.01, this._distanceIncrement = 0.005;
    }
    sample(e3) {
      this._histogram.sample(e3);
    }
    *quantize() {
      const e3 = this._histogram.getImportanceSortedColorsIDXI32();
      if (e3.length === 0)
        throw new Error("No colors in image");
      yield* this._buildPalette(e3);
    }
    *_buildPalette(e3) {
      const t = new Palette$1, i = t.getPointContainer().getPointArray(), r = new Array(e3.length);
      for (let t2 = 0;t2 < e3.length; t2++)
        i.push(Point$1.createByUint32(e3[t2])), r[t2] = 1;
      const n = i.length, a = [];
      let o = n, s = this._initialDistance;
      const l = new ProgressTracker$1(o - this._colors, 99);
      for (;o > this._colors; ) {
        a.length = 0;
        for (let e4 = 0;e4 < n; e4++) {
          if (l.shouldNotify(n - o) && (yield { progress: l.progress }), r[e4] === 0)
            continue;
          const t2 = i[e4];
          for (let l2 = e4 + 1;l2 < n; l2++) {
            if (r[l2] === 0)
              continue;
            const e5 = i[l2], n2 = this._distance.calculateNormalized(t2, e5);
            n2 < s && (a.push(new RemovedColor$1(l2, e5, n2)), r[l2] = 0, o--);
          }
        }
        s += o > 3 * this._colors ? this._initialDistance : this._distanceIncrement;
      }
      if (o < this._colors) {
        stableSort$1(a, (e5, t2) => t2.distance - e5.distance);
        let e4 = 0;
        for (;o < this._colors && e4 < a.length; ) {
          r[a[e4].index] = 1, o++, e4++;
        }
      }
      let u = i.length;
      for (let e4 = u - 1;e4 >= 0; e4--)
        r[e4] === 0 && (e4 !== u - 1 && (i[e4] = i[u - 1]), --u);
      i.length = u, t.sort(), yield { palette: t, progress: 100 };
    }
  };
  WuColorCube$1 = class {
    constructor() {
      __publicField$3(this, "redMinimum"), __publicField$3(this, "redMaximum"), __publicField$3(this, "greenMinimum"), __publicField$3(this, "greenMaximum"), __publicField$3(this, "blueMinimum"), __publicField$3(this, "blueMaximum"), __publicField$3(this, "volume"), __publicField$3(this, "alphaMinimum"), __publicField$3(this, "alphaMaximum");
    }
  };
  _WuQuant$1 = class extends AbstractPaletteQuantizer$1 {
    constructor(e3, t = 256, i = 5) {
      super(), __publicField$3(this, "_reds"), __publicField$3(this, "_greens"), __publicField$3(this, "_blues"), __publicField$3(this, "_alphas"), __publicField$3(this, "_sums"), __publicField$3(this, "_weights"), __publicField$3(this, "_momentsRed"), __publicField$3(this, "_momentsGreen"), __publicField$3(this, "_momentsBlue"), __publicField$3(this, "_momentsAlpha"), __publicField$3(this, "_moments"), __publicField$3(this, "_table"), __publicField$3(this, "_pixels"), __publicField$3(this, "_cubes"), __publicField$3(this, "_colors"), __publicField$3(this, "_significantBitsPerChannel"), __publicField$3(this, "_maxSideIndex"), __publicField$3(this, "_alphaMaxSideIndex"), __publicField$3(this, "_sideSize"), __publicField$3(this, "_alphaSideSize"), __publicField$3(this, "_distance"), this._distance = e3, this._setQuality(i), this._initialize(t);
    }
    sample(e3) {
      const t = e3.getPointArray();
      for (let e4 = 0, i = t.length;e4 < i; e4++)
        this._addColor(t[e4]);
      this._pixels = this._pixels.concat(t);
    }
    *quantize() {
      yield* this._preparePalette();
      const e3 = new Palette$1;
      for (let t = 0;t < this._colors; t++)
        if (this._sums[t] > 0) {
          const i = this._sums[t], r = this._reds[t] / i, n = this._greens[t] / i, a = this._blues[t] / i, o = this._alphas[t] / i, s = Point$1.createByRGBA(0 | r, 0 | n, 0 | a, 0 | o);
          e3.add(s);
        }
      e3.sort(), yield { palette: e3, progress: 100 };
    }
    *_preparePalette() {
      yield* this._calculateMoments();
      let e3 = 0;
      const t = createArray1D$1(this._colors);
      for (let i2 = 1;i2 < this._colors; ++i2) {
        this._cut(this._cubes[e3], this._cubes[i2]) ? (t[e3] = this._cubes[e3].volume > 1 ? this._calculateVariance(this._cubes[e3]) : 0, t[i2] = this._cubes[i2].volume > 1 ? this._calculateVariance(this._cubes[i2]) : 0) : (t[e3] = 0, i2--), e3 = 0;
        let r2 = t[0];
        for (let n2 = 1;n2 <= i2; ++n2)
          t[n2] > r2 && (r2 = t[n2], e3 = n2);
        if (r2 <= 0) {
          this._colors = i2 + 1;
          break;
        }
      }
      const i = [], r = [], n = [], a = [];
      for (let e4 = 0;e4 < this._colors; ++e4) {
        const t2 = _WuQuant$1._volume(this._cubes[e4], this._weights);
        t2 > 0 ? (i[e4] = _WuQuant$1._volume(this._cubes[e4], this._momentsRed) / t2 | 0, r[e4] = _WuQuant$1._volume(this._cubes[e4], this._momentsGreen) / t2 | 0, n[e4] = _WuQuant$1._volume(this._cubes[e4], this._momentsBlue) / t2 | 0, a[e4] = _WuQuant$1._volume(this._cubes[e4], this._momentsAlpha) / t2 | 0) : (i[e4] = 0, r[e4] = 0, n[e4] = 0, a[e4] = 0);
      }
      this._reds = createArray1D$1(this._colors + 1), this._greens = createArray1D$1(this._colors + 1), this._blues = createArray1D$1(this._colors + 1), this._alphas = createArray1D$1(this._colors + 1), this._sums = createArray1D$1(this._colors + 1);
      for (let e4 = 0, t2 = this._pixels.length;e4 < t2; e4++) {
        const t3 = this._pixels[e4];
        let o = -1, s = Number.MAX_VALUE;
        for (let e5 = 0;e5 < this._colors; e5++) {
          const l = i[e5], u = r[e5], h = n[e5], c = a[e5], f = this._distance.calculateRaw(l, u, h, c, t3.r, t3.g, t3.b, t3.a);
          f < s && (s = f, o = e5);
        }
        this._reds[o] += t3.r, this._greens[o] += t3.g, this._blues[o] += t3.b, this._alphas[o] += t3.a, this._sums[o]++;
      }
    }
    _addColor(e3) {
      const t = 8 - this._significantBitsPerChannel, i = 1 + (e3.r >> t), r = 1 + (e3.g >> t), n = 1 + (e3.b >> t), a = 1 + (e3.a >> t);
      this._weights[a][i][r][n]++, this._momentsRed[a][i][r][n] += e3.r, this._momentsGreen[a][i][r][n] += e3.g, this._momentsBlue[a][i][r][n] += e3.b, this._momentsAlpha[a][i][r][n] += e3.a, this._moments[a][i][r][n] += this._table[e3.r] + this._table[e3.g] + this._table[e3.b] + this._table[e3.a];
    }
    *_calculateMoments() {
      const e3 = [], t = [], i = [], r = [], n = [], a = [], o = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), s = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), l = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), u = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), h = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), c = createArray3D$1(this._sideSize, this._sideSize, this._sideSize);
      let f = 0;
      const d = new ProgressTracker$1(this._alphaMaxSideIndex * this._maxSideIndex, 99);
      for (let p = 1;p <= this._alphaMaxSideIndex; ++p) {
        fillArray3D$1(o, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(s, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(l, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(u, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(h, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(c, this._sideSize, this._sideSize, this._sideSize, 0);
        for (let m = 1;m <= this._maxSideIndex; ++m, ++f) {
          d.shouldNotify(f) && (yield { progress: d.progress }), fillArray1D$1(e3, this._sideSize, 0), fillArray1D$1(t, this._sideSize, 0), fillArray1D$1(i, this._sideSize, 0), fillArray1D$1(r, this._sideSize, 0), fillArray1D$1(n, this._sideSize, 0), fillArray1D$1(a, this._sideSize, 0);
          for (let f2 = 1;f2 <= this._maxSideIndex; ++f2) {
            let d2 = 0, _ = 0, g = 0, b2 = 0, y = 0, w = 0;
            for (let v = 1;v <= this._maxSideIndex; ++v)
              d2 += this._weights[p][m][f2][v], _ += this._momentsRed[p][m][f2][v], g += this._momentsGreen[p][m][f2][v], b2 += this._momentsBlue[p][m][f2][v], y += this._momentsAlpha[p][m][f2][v], w += this._moments[p][m][f2][v], e3[v] += d2, t[v] += _, i[v] += g, r[v] += b2, n[v] += y, a[v] += w, o[m][f2][v] = o[m - 1][f2][v] + e3[v], s[m][f2][v] = s[m - 1][f2][v] + t[v], l[m][f2][v] = l[m - 1][f2][v] + i[v], u[m][f2][v] = u[m - 1][f2][v] + r[v], h[m][f2][v] = h[m - 1][f2][v] + n[v], c[m][f2][v] = c[m - 1][f2][v] + a[v], this._weights[p][m][f2][v] = this._weights[p - 1][m][f2][v] + o[m][f2][v], this._momentsRed[p][m][f2][v] = this._momentsRed[p - 1][m][f2][v] + s[m][f2][v], this._momentsGreen[p][m][f2][v] = this._momentsGreen[p - 1][m][f2][v] + l[m][f2][v], this._momentsBlue[p][m][f2][v] = this._momentsBlue[p - 1][m][f2][v] + u[m][f2][v], this._momentsAlpha[p][m][f2][v] = this._momentsAlpha[p - 1][m][f2][v] + h[m][f2][v], this._moments[p][m][f2][v] = this._moments[p - 1][m][f2][v] + c[m][f2][v];
          }
        }
      }
    }
    static _volumeFloat(e3, t) {
      return t[e3.alphaMaximum][e3.redMaximum][e3.greenMaximum][e3.blueMaximum] - t[e3.alphaMaximum][e3.redMaximum][e3.greenMinimum][e3.blueMaximum] - t[e3.alphaMaximum][e3.redMinimum][e3.greenMaximum][e3.blueMaximum] + t[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] - t[e3.alphaMinimum][e3.redMaximum][e3.greenMaximum][e3.blueMaximum] + t[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][e3.blueMaximum] + t[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][e3.blueMaximum] - t[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] - (t[e3.alphaMaximum][e3.redMaximum][e3.greenMaximum][e3.blueMinimum] - t[e3.alphaMinimum][e3.redMaximum][e3.greenMaximum][e3.blueMinimum] - t[e3.alphaMaximum][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] + t[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] - t[e3.alphaMaximum][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] + t[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] + t[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum] - t[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum]);
    }
    static _volume(e3, t) {
      return 0 | _WuQuant$1._volumeFloat(e3, t);
    }
    static _top(e3, t, i, r) {
      let n;
      switch (t) {
        case _WuQuant$1._alpha:
          n = r[i][e3.redMaximum][e3.greenMaximum][e3.blueMaximum] - r[i][e3.redMaximum][e3.greenMinimum][e3.blueMaximum] - r[i][e3.redMinimum][e3.greenMaximum][e3.blueMaximum] + r[i][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] - (r[i][e3.redMaximum][e3.greenMaximum][e3.blueMinimum] - r[i][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] - r[i][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] + r[i][e3.redMinimum][e3.greenMinimum][e3.blueMinimum]);
          break;
        case _WuQuant$1._red:
          n = r[e3.alphaMaximum][i][e3.greenMaximum][e3.blueMaximum] - r[e3.alphaMaximum][i][e3.greenMinimum][e3.blueMaximum] - r[e3.alphaMinimum][i][e3.greenMaximum][e3.blueMaximum] + r[e3.alphaMinimum][i][e3.greenMinimum][e3.blueMaximum] - (r[e3.alphaMaximum][i][e3.greenMaximum][e3.blueMinimum] - r[e3.alphaMaximum][i][e3.greenMinimum][e3.blueMinimum] - r[e3.alphaMinimum][i][e3.greenMaximum][e3.blueMinimum] + r[e3.alphaMinimum][i][e3.greenMinimum][e3.blueMinimum]);
          break;
        case _WuQuant$1._green:
          n = r[e3.alphaMaximum][e3.redMaximum][i][e3.blueMaximum] - r[e3.alphaMaximum][e3.redMinimum][i][e3.blueMaximum] - r[e3.alphaMinimum][e3.redMaximum][i][e3.blueMaximum] + r[e3.alphaMinimum][e3.redMinimum][i][e3.blueMaximum] - (r[e3.alphaMaximum][e3.redMaximum][i][e3.blueMinimum] - r[e3.alphaMaximum][e3.redMinimum][i][e3.blueMinimum] - r[e3.alphaMinimum][e3.redMaximum][i][e3.blueMinimum] + r[e3.alphaMinimum][e3.redMinimum][i][e3.blueMinimum]);
          break;
        case _WuQuant$1._blue:
          n = r[e3.alphaMaximum][e3.redMaximum][e3.greenMaximum][i] - r[e3.alphaMaximum][e3.redMaximum][e3.greenMinimum][i] - r[e3.alphaMaximum][e3.redMinimum][e3.greenMaximum][i] + r[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][i] - (r[e3.alphaMinimum][e3.redMaximum][e3.greenMaximum][i] - r[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][i] - r[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][i] + r[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][i]);
          break;
        default:
          throw new Error("impossible");
      }
      return 0 | n;
    }
    static _bottom(e3, t, i) {
      switch (t) {
        case _WuQuant$1._alpha:
          return -i[e3.alphaMinimum][e3.redMaximum][e3.greenMaximum][e3.blueMaximum] + i[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][e3.blueMaximum] + i[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][e3.blueMaximum] - i[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] - (-i[e3.alphaMinimum][e3.redMaximum][e3.greenMaximum][e3.blueMinimum] + i[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] + i[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] - i[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum]);
        case _WuQuant$1._red:
          return -i[e3.alphaMaximum][e3.redMinimum][e3.greenMaximum][e3.blueMaximum] + i[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] + i[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][e3.blueMaximum] - i[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] - (-i[e3.alphaMaximum][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] + i[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum] + i[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] - i[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum]);
        case _WuQuant$1._green:
          return -i[e3.alphaMaximum][e3.redMaximum][e3.greenMinimum][e3.blueMaximum] + i[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] + i[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][e3.blueMaximum] - i[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] - (-i[e3.alphaMaximum][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] + i[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum] + i[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] - i[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum]);
        case _WuQuant$1._blue:
          return -i[e3.alphaMaximum][e3.redMaximum][e3.greenMaximum][e3.blueMinimum] + i[e3.alphaMaximum][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] + i[e3.alphaMaximum][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] - i[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum] - (-i[e3.alphaMinimum][e3.redMaximum][e3.greenMaximum][e3.blueMinimum] + i[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] + i[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] - i[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum]);
        default:
          return 0;
      }
    }
    _calculateVariance(e3) {
      const t = _WuQuant$1._volume(e3, this._momentsRed), i = _WuQuant$1._volume(e3, this._momentsGreen), r = _WuQuant$1._volume(e3, this._momentsBlue), n = _WuQuant$1._volume(e3, this._momentsAlpha);
      return _WuQuant$1._volumeFloat(e3, this._moments) - (t * t + i * i + r * r + n * n) / _WuQuant$1._volume(e3, this._weights);
    }
    _maximize(e3, t, i, r, n, a, o, s, l) {
      const u = 0 | _WuQuant$1._bottom(e3, t, this._momentsRed), h = 0 | _WuQuant$1._bottom(e3, t, this._momentsGreen), c = 0 | _WuQuant$1._bottom(e3, t, this._momentsBlue), f = 0 | _WuQuant$1._bottom(e3, t, this._momentsAlpha), d = 0 | _WuQuant$1._bottom(e3, t, this._weights);
      let p = 0, m = -1;
      for (let _ = i;_ < r; ++_) {
        let i2 = u + _WuQuant$1._top(e3, t, _, this._momentsRed), r2 = h + _WuQuant$1._top(e3, t, _, this._momentsGreen), g = c + _WuQuant$1._top(e3, t, _, this._momentsBlue), b2 = f + _WuQuant$1._top(e3, t, _, this._momentsAlpha), y = d + _WuQuant$1._top(e3, t, _, this._weights);
        if (y !== 0) {
          let e4 = i2 * i2 + r2 * r2 + g * g + b2 * b2, t2 = e4 / y;
          i2 = n - i2, r2 = a - r2, g = o - g, b2 = s - b2, y = l - y, y !== 0 && (e4 = i2 * i2 + r2 * r2 + g * g + b2 * b2, t2 += e4 / y, t2 > p && (p = t2, m = _));
        }
      }
      return { max: p, position: m };
    }
    _cut(e3, t) {
      let i;
      const r = _WuQuant$1._volume(e3, this._momentsRed), n = _WuQuant$1._volume(e3, this._momentsGreen), a = _WuQuant$1._volume(e3, this._momentsBlue), o = _WuQuant$1._volume(e3, this._momentsAlpha), s = _WuQuant$1._volume(e3, this._weights), l = this._maximize(e3, _WuQuant$1._red, e3.redMinimum + 1, e3.redMaximum, r, n, a, o, s), u = this._maximize(e3, _WuQuant$1._green, e3.greenMinimum + 1, e3.greenMaximum, r, n, a, o, s), h = this._maximize(e3, _WuQuant$1._blue, e3.blueMinimum + 1, e3.blueMaximum, r, n, a, o, s), c = this._maximize(e3, _WuQuant$1._alpha, e3.alphaMinimum + 1, e3.alphaMaximum, r, n, a, o, s);
      if (c.max >= l.max && c.max >= u.max && c.max >= h.max) {
        if (i = _WuQuant$1._alpha, c.position < 0)
          return false;
      } else
        i = l.max >= c.max && l.max >= u.max && l.max >= h.max ? _WuQuant$1._red : u.max >= c.max && u.max >= l.max && u.max >= h.max ? _WuQuant$1._green : _WuQuant$1._blue;
      switch (t.redMaximum = e3.redMaximum, t.greenMaximum = e3.greenMaximum, t.blueMaximum = e3.blueMaximum, t.alphaMaximum = e3.alphaMaximum, i) {
        case _WuQuant$1._red:
          t.redMinimum = e3.redMaximum = l.position, t.greenMinimum = e3.greenMinimum, t.blueMinimum = e3.blueMinimum, t.alphaMinimum = e3.alphaMinimum;
          break;
        case _WuQuant$1._green:
          t.greenMinimum = e3.greenMaximum = u.position, t.redMinimum = e3.redMinimum, t.blueMinimum = e3.blueMinimum, t.alphaMinimum = e3.alphaMinimum;
          break;
        case _WuQuant$1._blue:
          t.blueMinimum = e3.blueMaximum = h.position, t.redMinimum = e3.redMinimum, t.greenMinimum = e3.greenMinimum, t.alphaMinimum = e3.alphaMinimum;
          break;
        case _WuQuant$1._alpha:
          t.alphaMinimum = e3.alphaMaximum = c.position, t.blueMinimum = e3.blueMinimum, t.redMinimum = e3.redMinimum, t.greenMinimum = e3.greenMinimum;
      }
      return e3.volume = (e3.redMaximum - e3.redMinimum) * (e3.greenMaximum - e3.greenMinimum) * (e3.blueMaximum - e3.blueMinimum) * (e3.alphaMaximum - e3.alphaMinimum), t.volume = (t.redMaximum - t.redMinimum) * (t.greenMaximum - t.greenMinimum) * (t.blueMaximum - t.blueMinimum) * (t.alphaMaximum - t.alphaMinimum), true;
    }
    _initialize(e3) {
      this._colors = e3, this._cubes = [];
      for (let t = 0;t < e3; t++)
        this._cubes[t] = new WuColorCube$1;
      this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
      for (let e4 = 0;e4 < 256; ++e4)
        this._table[e4] = e4 * e4;
      this._pixels = [];
    }
    _setQuality(e3 = 5) {
      this._significantBitsPerChannel = e3, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
    }
  };
  WuQuant$1 = _WuQuant$1;
  __publicField$3(WuQuant$1, "_alpha", 3), __publicField$3(WuQuant$1, "_red", 2), __publicField$3(WuQuant$1, "_green", 1), __publicField$3(WuQuant$1, "_blue", 0);
  image_exports$1 = {};
  __export$1(image_exports$1, { AbstractImageQuantizer: () => AbstractImageQuantizer$1, ErrorDiffusionArray: () => ErrorDiffusionArray$1, ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel$1, ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma$1, NearestColor: () => NearestColor$1 });
  AbstractImageQuantizer$1 = class {
    quantizeSync(e3, t) {
      for (const i of this.quantize(e3, t))
        if (i.pointContainer)
          return i.pointContainer;
      throw new Error("unreachable");
    }
  };
  NearestColor$1 = class extends AbstractImageQuantizer$1 {
    constructor(e3) {
      super(), __publicField$3(this, "_distance"), this._distance = e3;
    }
    *quantize(e3, t) {
      const i = e3.getPointArray(), r = e3.getWidth(), n = e3.getHeight(), a = new ProgressTracker$1(n, 99);
      for (let e4 = 0;e4 < n; e4++) {
        a.shouldNotify(e4) && (yield { progress: a.progress });
        for (let n2 = 0, a2 = e4 * r;n2 < r; n2++, a2++) {
          const e5 = i[a2];
          e5.from(t.getNearestColor(this._distance, e5));
        }
      }
      yield { pointContainer: e3, progress: 100 };
    }
  };
  ErrorDiffusionArrayKernel$1 = ((e3) => (e3[e3.FloydSteinberg = 0] = "FloydSteinberg", e3[e3.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", e3[e3.Stucki = 2] = "Stucki", e3[e3.Atkinson = 3] = "Atkinson", e3[e3.Jarvis = 4] = "Jarvis", e3[e3.Burkes = 5] = "Burkes", e3[e3.Sierra = 6] = "Sierra", e3[e3.TwoSierra = 7] = "TwoSierra", e3[e3.SierraLite = 8] = "SierraLite", e3))(ErrorDiffusionArrayKernel$1 || {});
  ErrorDiffusionArray$1 = class extends AbstractImageQuantizer$1 {
    constructor(e3, t, i = true, r = 0, n = false) {
      super(), __publicField$3(this, "_minColorDistance"), __publicField$3(this, "_serpentine"), __publicField$3(this, "_kernel"), __publicField$3(this, "_calculateErrorLikeGIMP"), __publicField$3(this, "_distance"), this._setKernel(t), this._distance = e3, this._minColorDistance = r, this._serpentine = i, this._calculateErrorLikeGIMP = n;
    }
    *quantize(e3, t) {
      const i = e3.getPointArray(), r = new Point$1, n = e3.getWidth(), a = e3.getHeight(), o = [];
      let s = 1, l = 1;
      for (const e4 of this._kernel) {
        const t2 = e4[2] + 1;
        l < t2 && (l = t2);
      }
      for (let e4 = 0;e4 < l; e4++)
        this._fillErrorLine(o[e4] = [], n);
      const u = new ProgressTracker$1(a, 99);
      for (let e4 = 0;e4 < a; e4++) {
        u.shouldNotify(e4) && (yield { progress: u.progress }), this._serpentine && (s *= -1);
        const l2 = e4 * n, h = s === 1 ? 0 : n - 1, c = s === 1 ? n : -1;
        this._fillErrorLine(o[0], n), o.push(o.shift());
        const f = o[0];
        for (let u2 = h, d = l2 + h;u2 !== c; u2 += s, d += s) {
          const l3 = i[d], h2 = f[u2];
          r.from(l3);
          const c2 = Point$1.createByRGBA(inRange0to255Rounded$1(l3.r + h2[0]), inRange0to255Rounded$1(l3.g + h2[1]), inRange0to255Rounded$1(l3.b + h2[2]), inRange0to255Rounded$1(l3.a + h2[3])), p = t.getNearestColor(this._distance, c2);
          if (l3.from(p), this._minColorDistance) {
            if (this._distance.calculateNormalized(r, p) < this._minColorDistance)
              continue;
          }
          let m, _, g, b2;
          this._calculateErrorLikeGIMP ? (m = c2.r - p.r, _ = c2.g - p.g, g = c2.b - p.b, b2 = c2.a - p.a) : (m = r.r - p.r, _ = r.g - p.g, g = r.b - p.b, b2 = r.a - p.a);
          const y = s === 1 ? 0 : this._kernel.length - 1, w = s === 1 ? this._kernel.length : -1;
          for (let t2 = y;t2 !== w; t2 += s) {
            const i2 = this._kernel[t2][1] * s, r2 = this._kernel[t2][2];
            if (i2 + u2 >= 0 && i2 + u2 < n && r2 + e4 >= 0 && r2 + e4 < a) {
              const e5 = this._kernel[t2][0], n2 = o[r2][i2 + u2];
              n2[0] += m * e5, n2[1] += _ * e5, n2[2] += g * e5, n2[3] += b2 * e5;
            }
          }
        }
      }
      yield { pointContainer: e3, progress: 100 };
    }
    _fillErrorLine(e3, t) {
      e3.length > t && (e3.length = t);
      const i = e3.length;
      for (let t2 = 0;t2 < i; t2++) {
        const i2 = e3[t2];
        i2[0] = i2[1] = i2[2] = i2[3] = 0;
      }
      for (let r = i;r < t; r++)
        e3[r] = [0, 0, 0, 0];
    }
    _setKernel(e3) {
      switch (e3) {
        case 0:
          this._kernel = [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]];
          break;
        case 1:
          this._kernel = [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]];
          break;
        case 2:
          this._kernel = [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]];
          break;
        case 3:
          this._kernel = [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]];
          break;
        case 4:
          this._kernel = [[7 / 48, 1, 0], [5 / 48, 2, 0], [3 / 48, -2, 1], [5 / 48, -1, 1], [7 / 48, 0, 1], [5 / 48, 1, 1], [3 / 48, 2, 1], [1 / 48, -2, 2], [3 / 48, -1, 2], [5 / 48, 0, 2], [3 / 48, 1, 2], [1 / 48, 2, 2]];
          break;
        case 5:
          this._kernel = [[0.25, 1, 0], [4 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [0.25, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1]];
          break;
        case 6:
          this._kernel = [[5 / 32, 1, 0], [3 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [5 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1], [2 / 32, -1, 2], [3 / 32, 0, 2], [2 / 32, 1, 2]];
          break;
        case 7:
          this._kernel = [[0.25, 1, 0], [3 / 16, 2, 0], [1 / 16, -2, 1], [2 / 16, -1, 1], [3 / 16, 0, 1], [2 / 16, 1, 1], [1 / 16, 2, 1]];
          break;
        case 8:
          this._kernel = [[0.5, 1, 0], [1 / 4, -1, 1], [1 / 4, 0, 1]];
          break;
        default:
          throw new Error(`ErrorDiffusionArray: unknown kernel = ${e3}`);
      }
    }
  };
  ErrorDiffusionRiemersma$1 = class extends AbstractImageQuantizer$1 {
    constructor(e3, t = 16, i = 1) {
      super(), __publicField$3(this, "_distance"), __publicField$3(this, "_weights"), __publicField$3(this, "_errorQueueSize"), this._distance = e3, this._errorQueueSize = t, this._weights = ErrorDiffusionRiemersma$1._createWeights(i, t);
    }
    *quantize(e3, t) {
      const i = e3.getPointArray(), r = e3.getWidth(), n = e3.getHeight(), a = [];
      let o = 0;
      for (let e4 = 0;e4 < this._errorQueueSize; e4++)
        a[e4] = { r: 0, g: 0, b: 0, a: 0 };
      yield* hilbertCurve$1(r, n, (e4, n2) => {
        const s = i[e4 + n2 * r];
        let { r: l, g: u, b: h, a: c } = s;
        for (let e5 = 0;e5 < this._errorQueueSize; e5++) {
          const t2 = this._weights[e5], i2 = a[(e5 + o) % this._errorQueueSize];
          l += i2.r * t2, u += i2.g * t2, h += i2.b * t2, c += i2.a * t2;
        }
        const f = Point$1.createByRGBA(inRange0to255Rounded$1(l), inRange0to255Rounded$1(u), inRange0to255Rounded$1(h), inRange0to255Rounded$1(c)), d = t.getNearestColor(this._distance, f);
        o = (o + 1) % this._errorQueueSize;
        const p = (o + this._errorQueueSize - 1) % this._errorQueueSize;
        a[p].r = s.r - d.r, a[p].g = s.g - d.g, a[p].b = s.b - d.b, a[p].a = s.a - d.a, s.from(d);
      }), yield { pointContainer: e3, progress: 100 };
    }
    static _createWeights(e3, t) {
      const i = [], r = Math.exp(Math.log(t) / (t - 1));
      for (let n = 0, a = 1;n < t; n++)
        i[n] = (a + 0.5 | 0) / t * e3, a *= r;
      return i;
    }
  };
  quality_exports$1 = {};
  __export$1(quality_exports$1, { ssim: () => ssim$1 });
  K1$1 = 0.01;
  K2$1 = 0.03;
  setImmediateImpl = typeof setImmediate == "function" ? setImmediate : typeof process != "undefined" && typeof (process == null ? undefined : process.nextTick) == "function" ? (e3) => process.nextTick(e3) : (e3) => setTimeout(e3, 0);
  imageQ = __toCommonJS2(src_exports);
  gifframe = {};
  BitmapImage$1 = bitmapimage;
  GifFrame$1 = class e3 extends BitmapImage$1 {
    constructor(...t) {
      if (super(...t), t[0] instanceof e3) {
        const e4 = t[0];
        this.xOffset = e4.xOffset, this.yOffset = e4.yOffset, this.disposalMethod = e4.disposalMethod, this.delayCentisecs = e4.delayCentisecs, this.interlaced = e4.interlaced;
      } else {
        const i = t[t.length - 1];
        let r = {};
        typeof i != "object" || i instanceof BitmapImage$1 || (r = i), this.xOffset = r.xOffset || 0, this.yOffset = r.yOffset || 0, this.disposalMethod = r.disposalMethod !== undefined ? r.disposalMethod : e3.DisposeToBackgroundColor, this.delayCentisecs = r.delayCentisecs || 8, this.interlaced = r.interlaced || false;
      }
    }
    getPalette() {
      const e4 = new Set, t = this.bitmap.data;
      let i = 0, r = false;
      for (;i < t.length; ) {
        if (t[i + 3] === 0)
          r = true;
        else {
          const r2 = t.readUInt32BE(i, true) >> 8 & 16777215;
          e4.add(r2);
        }
        i += 4;
      }
      const n = new Array(e4.size), a = e4.values();
      for (i = 0;i < n.length; ++i)
        n[i] = a.next().value;
      n.sort((e5, t2) => e5 - t2);
      let o = n.length;
      return r && ++o, { colors: n, usesTransparency: r, indexCount: o };
    }
  };
  GifFrame$1.DisposeToAnything = 0, GifFrame$1.DisposeNothing = 1, GifFrame$1.DisposeToBackgroundColor = 2, GifFrame$1.DisposeToPrevious = 3, gifframe.GifFrame = GifFrame$1;
  BitmapImage = bitmapimage;
  ({ Gif, GifError: GifError$1 } = gif$1);
  ({ GifCodec } = requireGifcodec());
  ({ GifFrame } = gifframe);
  GifUtil = requireGifutil();
  src = { BitmapImage, Gif, GifCodec, GifFrame, GifUtil, GifError: GifError$1 };
  encoder = { exports: {} };
  (function(e4) {
    function t(e5) {
      var t2, i, r, n, a, o = Math.floor, s = new Array(64), l = new Array(64), u = new Array(64), h = new Array(64), c = new Array(65535), f = new Array(65535), d = new Array(64), p = new Array(64), m = [], _ = 0, g = 7, b2 = new Array(64), y = new Array(64), w = new Array(64), v = new Array(256), x = new Array(2048), E = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], k = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], A = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], I = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], M = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], T = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], P = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], B = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
      function C(e6, t3) {
        for (var i2 = 0, r2 = 0, n2 = new Array, a2 = 1;a2 <= 16; a2++) {
          for (var o2 = 1;o2 <= e6[a2]; o2++)
            n2[t3[r2]] = [], n2[t3[r2]][0] = i2, n2[t3[r2]][1] = a2, r2++, i2++;
          i2 *= 2;
        }
        return n2;
      }
      function R(e6) {
        for (var t3 = e6[0], i2 = e6[1] - 1;i2 >= 0; )
          t3 & 1 << i2 && (_ |= 1 << g), i2--, --g < 0 && (_ == 255 ? (z(255), z(0)) : z(_), g = 7, _ = 0);
      }
      function z(e6) {
        m.push(e6);
      }
      function F(e6) {
        z(e6 >> 8 & 255), z(255 & e6);
      }
      function N(e6, t3, i2, r2, n2) {
        for (var a2, o2 = n2[0], s2 = n2[240], l2 = function(e7, t4) {
          var i3, r3, n3, a3, o3, s3, l3, u3, h3, c2, f2 = 0;
          for (h3 = 0;h3 < 8; ++h3) {
            i3 = e7[f2], r3 = e7[f2 + 1], n3 = e7[f2 + 2], a3 = e7[f2 + 3], o3 = e7[f2 + 4], s3 = e7[f2 + 5], l3 = e7[f2 + 6];
            var p2 = i3 + (u3 = e7[f2 + 7]), m3 = i3 - u3, _3 = r3 + l3, g3 = r3 - l3, b4 = n3 + s3, y3 = n3 - s3, w3 = a3 + o3, v2 = a3 - o3, x2 = p2 + w3, E2 = p2 - w3, k2 = _3 + b4, S2 = _3 - b4;
            e7[f2] = x2 + k2, e7[f2 + 4] = x2 - k2;
            var A2 = 0.707106781 * (S2 + E2);
            e7[f2 + 2] = E2 + A2, e7[f2 + 6] = E2 - A2;
            var I2 = 0.382683433 * ((x2 = v2 + y3) - (S2 = g3 + m3)), M2 = 0.5411961 * x2 + I2, T2 = 1.306562965 * S2 + I2, P2 = 0.707106781 * (k2 = y3 + g3), B2 = m3 + P2, C2 = m3 - P2;
            e7[f2 + 5] = C2 + M2, e7[f2 + 3] = C2 - M2, e7[f2 + 1] = B2 + T2, e7[f2 + 7] = B2 - T2, f2 += 8;
          }
          for (f2 = 0, h3 = 0;h3 < 8; ++h3) {
            i3 = e7[f2], r3 = e7[f2 + 8], n3 = e7[f2 + 16], a3 = e7[f2 + 24], o3 = e7[f2 + 32], s3 = e7[f2 + 40], l3 = e7[f2 + 48];
            var R2 = i3 + (u3 = e7[f2 + 56]), z2 = i3 - u3, F2 = r3 + l3, N2 = r3 - l3, O2 = n3 + s3, D = n3 - s3, $ = a3 + o3, L = a3 - o3, U = R2 + $, Z = R2 - $, j = F2 + O2, G = F2 - O2;
            e7[f2] = U + j, e7[f2 + 32] = U - j;
            var H = 0.707106781 * (G + Z);
            e7[f2 + 16] = Z + H, e7[f2 + 48] = Z - H;
            var Q = 0.382683433 * ((U = L + D) - (G = N2 + z2)), W = 0.5411961 * U + Q, q = 1.306562965 * G + Q, V = 0.707106781 * (j = D + N2), Y = z2 + V, K = z2 - V;
            e7[f2 + 40] = K + W, e7[f2 + 24] = K - W, e7[f2 + 8] = Y + q, e7[f2 + 56] = Y - q, f2++;
          }
          for (h3 = 0;h3 < 64; ++h3)
            c2 = e7[h3] * t4[h3], d[h3] = c2 > 0 ? c2 + 0.5 | 0 : c2 - 0.5 | 0;
          return d;
        }(e6, t3), u2 = 0;u2 < 64; ++u2)
          p[E[u2]] = l2[u2];
        var h2 = p[0] - i2;
        i2 = p[0], h2 == 0 ? R(r2[0]) : (R(r2[f[a2 = 32767 + h2]]), R(c[a2]));
        for (var m2 = 63;m2 > 0 && p[m2] == 0; m2--)
          ;
        if (m2 == 0)
          return R(o2), i2;
        for (var _2, g2 = 1;g2 <= m2; ) {
          for (var b3 = g2;p[g2] == 0 && g2 <= m2; ++g2)
            ;
          var y2 = g2 - b3;
          if (y2 >= 16) {
            _2 = y2 >> 4;
            for (var w2 = 1;w2 <= _2; ++w2)
              R(s2);
            y2 &= 15;
          }
          a2 = 32767 + p[g2], R(n2[(y2 << 4) + f[a2]]), R(c[a2]), g2++;
        }
        return m2 != 63 && R(o2), i2;
      }
      function O(e6) {
        if (e6 <= 0 && (e6 = 1), e6 > 100 && (e6 = 100), a != e6) {
          (function(e7) {
            for (var t3 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], i2 = 0;i2 < 64; i2++) {
              var r2 = o((t3[i2] * e7 + 50) / 100);
              r2 < 1 ? r2 = 1 : r2 > 255 && (r2 = 255), s[E[i2]] = r2;
            }
            for (var n2 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a2 = 0;a2 < 64; a2++) {
              var c2 = o((n2[a2] * e7 + 50) / 100);
              c2 < 1 ? c2 = 1 : c2 > 255 && (c2 = 255), l[E[a2]] = c2;
            }
            for (var f2 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d2 = 0, p2 = 0;p2 < 8; p2++)
              for (var m2 = 0;m2 < 8; m2++)
                u[d2] = 1 / (s[E[d2]] * f2[p2] * f2[m2] * 8), h[d2] = 1 / (l[E[d2]] * f2[p2] * f2[m2] * 8), d2++;
          })(e6 < 50 ? Math.floor(5000 / e6) : Math.floor(200 - 2 * e6)), a = e6;
        }
      }
      this.encode = function(e6, a2) {
        var o2;
        new Date().getTime(), a2 && O(a2), m = new Array, _ = 0, g = 7, F(65496), F(65504), F(16), z(74), z(70), z(73), z(70), z(0), z(1), z(1), z(0), F(1), F(1), z(0), z(0), (o2 = e6.comments) !== undefined && o2.constructor === Array && o2.forEach((e7) => {
          if (typeof e7 == "string") {
            F(65534);
            var t3, i2 = e7.length;
            for (F(i2 + 2), t3 = 0;t3 < i2; t3++)
              z(e7.charCodeAt(t3));
          }
        }), function(e7) {
          if (e7) {
            F(65505), e7[0] === 69 && e7[1] === 120 && e7[2] === 105 && e7[3] === 102 ? F(e7.length + 2) : (F(e7.length + 5 + 2), z(69), z(120), z(105), z(102), z(0));
            for (var t3 = 0;t3 < e7.length; t3++)
              z(e7[t3]);
          }
        }(e6.exifBuffer), function() {
          F(65499), F(132), z(0);
          for (var e7 = 0;e7 < 64; e7++)
            z(s[e7]);
          z(1);
          for (var t3 = 0;t3 < 64; t3++)
            z(l[t3]);
        }(), function(e7, t3) {
          F(65472), F(17), z(8), F(t3), F(e7), z(3), z(1), z(17), z(0), z(2), z(17), z(1), z(3), z(17), z(1);
        }(e6.width, e6.height), function() {
          F(65476), F(418), z(0);
          for (var e7 = 0;e7 < 16; e7++)
            z(k[e7 + 1]);
          for (var t3 = 0;t3 <= 11; t3++)
            z(S[t3]);
          z(16);
          for (var i2 = 0;i2 < 16; i2++)
            z(A[i2 + 1]);
          for (var r2 = 0;r2 <= 161; r2++)
            z(I[r2]);
          z(1);
          for (var n2 = 0;n2 < 16; n2++)
            z(M[n2 + 1]);
          for (var a3 = 0;a3 <= 11; a3++)
            z(T[a3]);
          z(17);
          for (var o3 = 0;o3 < 16; o3++)
            z(P[o3 + 1]);
          for (var s2 = 0;s2 <= 161; s2++)
            z(B[s2]);
        }(), F(65498), F(12), z(3), z(1), z(0), z(2), z(17), z(3), z(17), z(0), z(63), z(0);
        var c2 = 0, f2 = 0, d2 = 0;
        _ = 0, g = 7, this.encode.displayName = "_encode_";
        for (var p2, v2, E2, C2, D, $, L, U, Z, j = e6.data, G = e6.width, H = e6.height, Q = 4 * G, W = 0;W < H; ) {
          for (p2 = 0;p2 < Q; ) {
            for ($ = D = Q * W + p2, L = -1, U = 0, Z = 0;Z < 64; Z++)
              $ = D + (U = Z >> 3) * Q + (L = 4 * (7 & Z)), W + U >= H && ($ -= Q * (W + 1 + U - H)), p2 + L >= Q && ($ -= p2 + L - Q + 4), v2 = j[$++], E2 = j[$++], C2 = j[$++], b2[Z] = (x[v2] + x[E2 + 256 | 0] + x[C2 + 512 | 0] >> 16) - 128, y[Z] = (x[v2 + 768 | 0] + x[E2 + 1024 | 0] + x[C2 + 1280 | 0] >> 16) - 128, w[Z] = (x[v2 + 1280 | 0] + x[E2 + 1536 | 0] + x[C2 + 1792 | 0] >> 16) - 128;
            c2 = N(b2, u, c2, t2, r), f2 = N(y, h, f2, i, n), d2 = N(w, h, d2, i, n), p2 += 32;
          }
          W += 8;
        }
        if (g >= 0) {
          var q = [];
          q[1] = g + 1, q[0] = (1 << g + 1) - 1, R(q);
        }
        return F(65497), Buffer2.from(m);
      }, new Date().getTime(), e5 || (e5 = 50), function() {
        for (var e6 = String.fromCharCode, t3 = 0;t3 < 256; t3++)
          v[t3] = e6(t3);
      }(), t2 = C(k, S), i = C(M, T), r = C(A, I), n = C(P, B), function() {
        for (var e6 = 1, t3 = 2, i2 = 1;i2 <= 15; i2++) {
          for (var r2 = e6;r2 < t3; r2++)
            f[32767 + r2] = i2, c[32767 + r2] = [], c[32767 + r2][1] = i2, c[32767 + r2][0] = r2;
          for (var n2 = -(t3 - 1);n2 <= -e6; n2++)
            f[32767 + n2] = i2, c[32767 + n2] = [], c[32767 + n2][1] = i2, c[32767 + n2][0] = t3 - 1 + n2;
          e6 <<= 1, t3 <<= 1;
        }
      }(), function() {
        for (var e6 = 0;e6 < 256; e6++)
          x[e6] = 19595 * e6, x[e6 + 256 | 0] = 38470 * e6, x[e6 + 512 | 0] = 7471 * e6 + 32768, x[e6 + 768 | 0] = -11059 * e6, x[e6 + 1024 | 0] = -21709 * e6, x[e6 + 1280 | 0] = 32768 * e6 + 8421375, x[e6 + 1536 | 0] = -27439 * e6, x[e6 + 1792 | 0] = -5329 * e6;
      }(), O(e5), new Date().getTime();
    }
    encoder.exports = function(e5, i) {
      i === undefined && (i = 50);
      var r = new t(i), n = r.encode(e5, i);
      return { data: n, width: e5.width, height: e5.height };
    };
  })();
  encoderExports = encoder.exports;
  decoder = { exports: {} };
  module = decoder, JpegImage = function() {
    var e4 = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), t = 4017, i = 799, r = 3406, n = 2276, a = 1567, o = 3784, s = 5793, l = 2896;
    function u() {
    }
    function h(e5, t2) {
      for (var i2, r2, n2 = 0, a2 = [], o2 = 16;o2 > 0 && !e5[o2 - 1]; )
        o2--;
      a2.push({ children: [], index: 0 });
      var s2, l2 = a2[0];
      for (i2 = 0;i2 < o2; i2++) {
        for (r2 = 0;r2 < e5[i2]; r2++) {
          for ((l2 = a2.pop()).children[l2.index] = t2[n2];l2.index > 0; ) {
            if (a2.length === 0)
              throw new Error("Could not recreate Huffman Table");
            l2 = a2.pop();
          }
          for (l2.index++, a2.push(l2);a2.length <= i2; )
            a2.push(s2 = { children: [], index: 0 }), l2.children[l2.index] = s2.children, l2 = s2;
          n2++;
        }
        i2 + 1 < o2 && (a2.push(s2 = { children: [], index: 0 }), l2.children[l2.index] = s2.children, l2 = s2);
      }
      return a2[0].children;
    }
    function c(t2, i2, r2, n2, a2, o2, s2, l2, u2, h2) {
      r2.precision, r2.samplesPerLine, r2.scanLines;
      var { mcusPerLine: c2, progressive: f2 } = r2;
      r2.maxH, r2.maxV;
      var d2 = i2, p2 = 0, m2 = 0;
      function _2() {
        if (m2 > 0)
          return m2--, p2 >> m2 & 1;
        if ((p2 = t2[i2++]) == 255) {
          var e5 = t2[i2++];
          if (e5)
            throw new Error("unexpected marker: " + (p2 << 8 | e5).toString(16));
        }
        return m2 = 7, p2 >>> 7;
      }
      function g(e5) {
        for (var t3, i3 = e5;(t3 = _2()) !== null; ) {
          if (typeof (i3 = i3[t3]) == "number")
            return i3;
          if (typeof i3 != "object")
            throw new Error("invalid huffman sequence");
        }
        return null;
      }
      function b2(e5) {
        for (var t3 = 0;e5 > 0; ) {
          var i3 = _2();
          if (i3 === null)
            return;
          t3 = t3 << 1 | i3, e5--;
        }
        return t3;
      }
      function y(e5) {
        var t3 = b2(e5);
        return t3 >= 1 << e5 - 1 ? t3 : t3 + (-1 << e5) + 1;
      }
      var w, v = 0, x = 0;
      function E(e5, t3, i3, r3, n3) {
        var a3 = i3 % c2, o3 = (i3 / c2 | 0) * e5.v + r3, s3 = a3 * e5.h + n3;
        e5.blocks[o3] === undefined && h2.tolerantDecoding || t3(e5, e5.blocks[o3][s3]);
      }
      function k(e5, t3, i3) {
        var r3 = i3 / e5.blocksPerLine | 0, n3 = i3 % e5.blocksPerLine;
        e5.blocks[r3] === undefined && h2.tolerantDecoding || t3(e5, e5.blocks[r3][n3]);
      }
      var S, A, I, M, T, P, B = n2.length;
      P = f2 ? o2 === 0 ? l2 === 0 ? function(e5, t3) {
        var i3 = g(e5.huffmanTableDC), r3 = i3 === 0 ? 0 : y(i3) << u2;
        t3[0] = e5.pred += r3;
      } : function(e5, t3) {
        t3[0] |= _2() << u2;
      } : l2 === 0 ? function(t3, i3) {
        if (v > 0)
          v--;
        else
          for (var r3 = o2, n3 = s2;r3 <= n3; ) {
            var a3 = g(t3.huffmanTableAC), l3 = 15 & a3, h3 = a3 >> 4;
            if (l3 !== 0)
              i3[e4[r3 += h3]] = y(l3) * (1 << u2), r3++;
            else {
              if (h3 < 15) {
                v = b2(h3) + (1 << h3) - 1;
                break;
              }
              r3 += 16;
            }
          }
      } : function(t3, i3) {
        for (var r3 = o2, n3 = s2, a3 = 0;r3 <= n3; ) {
          var l3 = e4[r3], h3 = i3[l3] < 0 ? -1 : 1;
          switch (x) {
            case 0:
              var c3 = g(t3.huffmanTableAC), f3 = 15 & c3;
              if (a3 = c3 >> 4, f3 === 0)
                a3 < 15 ? (v = b2(a3) + (1 << a3), x = 4) : (a3 = 16, x = 1);
              else {
                if (f3 !== 1)
                  throw new Error("invalid ACn encoding");
                w = y(f3), x = a3 ? 2 : 3;
              }
              continue;
            case 1:
            case 2:
              i3[l3] ? i3[l3] += (_2() << u2) * h3 : --a3 == 0 && (x = x == 2 ? 3 : 0);
              break;
            case 3:
              i3[l3] ? i3[l3] += (_2() << u2) * h3 : (i3[l3] = w << u2, x = 0);
              break;
            case 4:
              i3[l3] && (i3[l3] += (_2() << u2) * h3);
          }
          r3++;
        }
        x === 4 && --v == 0 && (x = 0);
      } : function(t3, i3) {
        var r3 = g(t3.huffmanTableDC), n3 = r3 === 0 ? 0 : y(r3);
        i3[0] = t3.pred += n3;
        for (var a3 = 1;a3 < 64; ) {
          var o3 = g(t3.huffmanTableAC), s3 = 15 & o3, l3 = o3 >> 4;
          if (s3 !== 0)
            i3[e4[a3 += l3]] = y(s3), a3++;
          else {
            if (l3 < 15)
              break;
            a3 += 16;
          }
        }
      };
      var C, R, z, F, N = 0;
      for (R = B == 1 ? n2[0].blocksPerLine * n2[0].blocksPerColumn : c2 * r2.mcusPerColumn, a2 || (a2 = R);N < R; ) {
        for (A = 0;A < B; A++)
          n2[A].pred = 0;
        if (v = 0, B == 1)
          for (S = n2[0], T = 0;T < a2; T++)
            k(S, P, N), N++;
        else
          for (T = 0;T < a2; T++) {
            for (A = 0;A < B; A++)
              for (z = (S = n2[A]).h, F = S.v, I = 0;I < F; I++)
                for (M = 0;M < z; M++)
                  E(S, P, N, I, M);
            if (++N === R)
              break;
          }
        if (N === R)
          do {
            if (t2[i2] === 255 && t2[i2 + 1] !== 0)
              break;
            i2 += 1;
          } while (i2 < t2.length - 2);
        if (m2 = 0, (C = t2[i2] << 8 | t2[i2 + 1]) < 65280)
          throw new Error("marker was not found");
        if (!(C >= 65488 && C <= 65495))
          break;
        i2 += 2;
      }
      return i2 - d2;
    }
    function f(e5, u2) {
      var h2, c2, f2 = [], d2 = u2.blocksPerLine, p2 = u2.blocksPerColumn, m2 = d2 << 3, g = new Int32Array(64), b2 = new Uint8Array(64);
      function y(e6, h3, c3) {
        var f3, d3, p3, m3, _2, g2, b3, y2, w2, v2, x2 = u2.quantizationTable, E2 = c3;
        for (v2 = 0;v2 < 64; v2++)
          E2[v2] = e6[v2] * x2[v2];
        for (v2 = 0;v2 < 8; ++v2) {
          var k2 = 8 * v2;
          E2[1 + k2] != 0 || E2[2 + k2] != 0 || E2[3 + k2] != 0 || E2[4 + k2] != 0 || E2[5 + k2] != 0 || E2[6 + k2] != 0 || E2[7 + k2] != 0 ? (f3 = s * E2[0 + k2] + 128 >> 8, d3 = s * E2[4 + k2] + 128 >> 8, p3 = E2[2 + k2], m3 = E2[6 + k2], _2 = l * (E2[1 + k2] - E2[7 + k2]) + 128 >> 8, y2 = l * (E2[1 + k2] + E2[7 + k2]) + 128 >> 8, g2 = E2[3 + k2] << 4, b3 = E2[5 + k2] << 4, w2 = f3 - d3 + 1 >> 1, f3 = f3 + d3 + 1 >> 1, d3 = w2, w2 = p3 * o + m3 * a + 128 >> 8, p3 = p3 * a - m3 * o + 128 >> 8, m3 = w2, w2 = _2 - b3 + 1 >> 1, _2 = _2 + b3 + 1 >> 1, b3 = w2, w2 = y2 + g2 + 1 >> 1, g2 = y2 - g2 + 1 >> 1, y2 = w2, w2 = f3 - m3 + 1 >> 1, f3 = f3 + m3 + 1 >> 1, m3 = w2, w2 = d3 - p3 + 1 >> 1, d3 = d3 + p3 + 1 >> 1, p3 = w2, w2 = _2 * n + y2 * r + 2048 >> 12, _2 = _2 * r - y2 * n + 2048 >> 12, y2 = w2, w2 = g2 * i + b3 * t + 2048 >> 12, g2 = g2 * t - b3 * i + 2048 >> 12, b3 = w2, E2[0 + k2] = f3 + y2, E2[7 + k2] = f3 - y2, E2[1 + k2] = d3 + b3, E2[6 + k2] = d3 - b3, E2[2 + k2] = p3 + g2, E2[5 + k2] = p3 - g2, E2[3 + k2] = m3 + _2, E2[4 + k2] = m3 - _2) : (w2 = s * E2[0 + k2] + 512 >> 10, E2[0 + k2] = w2, E2[1 + k2] = w2, E2[2 + k2] = w2, E2[3 + k2] = w2, E2[4 + k2] = w2, E2[5 + k2] = w2, E2[6 + k2] = w2, E2[7 + k2] = w2);
        }
        for (v2 = 0;v2 < 8; ++v2) {
          var S2 = v2;
          E2[8 + S2] != 0 || E2[16 + S2] != 0 || E2[24 + S2] != 0 || E2[32 + S2] != 0 || E2[40 + S2] != 0 || E2[48 + S2] != 0 || E2[56 + S2] != 0 ? (f3 = s * E2[0 + S2] + 2048 >> 12, d3 = s * E2[32 + S2] + 2048 >> 12, p3 = E2[16 + S2], m3 = E2[48 + S2], _2 = l * (E2[8 + S2] - E2[56 + S2]) + 2048 >> 12, y2 = l * (E2[8 + S2] + E2[56 + S2]) + 2048 >> 12, g2 = E2[24 + S2], b3 = E2[40 + S2], w2 = f3 - d3 + 1 >> 1, f3 = f3 + d3 + 1 >> 1, d3 = w2, w2 = p3 * o + m3 * a + 2048 >> 12, p3 = p3 * a - m3 * o + 2048 >> 12, m3 = w2, w2 = _2 - b3 + 1 >> 1, _2 = _2 + b3 + 1 >> 1, b3 = w2, w2 = y2 + g2 + 1 >> 1, g2 = y2 - g2 + 1 >> 1, y2 = w2, w2 = f3 - m3 + 1 >> 1, f3 = f3 + m3 + 1 >> 1, m3 = w2, w2 = d3 - p3 + 1 >> 1, d3 = d3 + p3 + 1 >> 1, p3 = w2, w2 = _2 * n + y2 * r + 2048 >> 12, _2 = _2 * r - y2 * n + 2048 >> 12, y2 = w2, w2 = g2 * i + b3 * t + 2048 >> 12, g2 = g2 * t - b3 * i + 2048 >> 12, b3 = w2, E2[0 + S2] = f3 + y2, E2[56 + S2] = f3 - y2, E2[8 + S2] = d3 + b3, E2[48 + S2] = d3 - b3, E2[16 + S2] = p3 + g2, E2[40 + S2] = p3 - g2, E2[24 + S2] = m3 + _2, E2[32 + S2] = m3 - _2) : (w2 = s * c3[v2 + 0] + 8192 >> 14, E2[0 + S2] = w2, E2[8 + S2] = w2, E2[16 + S2] = w2, E2[24 + S2] = w2, E2[32 + S2] = w2, E2[40 + S2] = w2, E2[48 + S2] = w2, E2[56 + S2] = w2);
        }
        for (v2 = 0;v2 < 64; ++v2) {
          var A = 128 + (E2[v2] + 8 >> 4);
          h3[v2] = A < 0 ? 0 : A > 255 ? 255 : A;
        }
      }
      _(m2 * p2 * 8);
      for (var w = 0;w < p2; w++) {
        var v = w << 3;
        for (h2 = 0;h2 < 8; h2++)
          f2.push(new Uint8Array(m2));
        for (var x = 0;x < d2; x++) {
          y(u2.blocks[w][x], b2, g);
          var E = 0, k = x << 3;
          for (c2 = 0;c2 < 8; c2++) {
            var S = f2[v + c2];
            for (h2 = 0;h2 < 8; h2++)
              S[k + h2] = b2[E++];
          }
        }
      }
      return f2;
    }
    function d(e5) {
      return e5 < 0 ? 0 : e5 > 255 ? 255 : e5;
    }
    u.prototype = { load: function(e5) {
      var t2 = new XMLHttpRequest;
      t2.open("GET", e5, true), t2.responseType = "arraybuffer", t2.onload = function() {
        var e6 = new Uint8Array(t2.response || t2.mozResponseArrayBuffer);
        this.parse(e6), this.onload && this.onload();
      }.bind(this), t2.send(null);
    }, parse: function(t2) {
      var i2 = 1000 * this.opts.maxResolutionInMP * 1000, r2 = 0;
      function n2() {
        var e5 = t2[r2] << 8 | t2[r2 + 1];
        return r2 += 2, e5;
      }
      function a2(e5) {
        var t3, i3, r3 = 1, n3 = 1;
        for (i3 in e5.components)
          e5.components.hasOwnProperty(i3) && (r3 < (t3 = e5.components[i3]).h && (r3 = t3.h), n3 < t3.v && (n3 = t3.v));
        var a3 = Math.ceil(e5.samplesPerLine / 8 / r3), o3 = Math.ceil(e5.scanLines / 8 / n3);
        for (i3 in e5.components)
          if (e5.components.hasOwnProperty(i3)) {
            t3 = e5.components[i3];
            var s3 = Math.ceil(Math.ceil(e5.samplesPerLine / 8) * t3.h / r3), l3 = Math.ceil(Math.ceil(e5.scanLines / 8) * t3.v / n3), u3 = a3 * t3.h, h2 = o3 * t3.v, c2 = [];
            _(h2 * u3 * 256);
            for (var f2 = 0;f2 < h2; f2++) {
              for (var d3 = [], p3 = 0;p3 < u3; p3++)
                d3.push(new Int32Array(64));
              c2.push(d3);
            }
            t3.blocksPerLine = s3, t3.blocksPerColumn = l3, t3.blocks = c2;
          }
        e5.maxH = r3, e5.maxV = n3, e5.mcusPerLine = a3, e5.mcusPerColumn = o3;
      }
      t2.length;
      var o2, s2, l2, u2, d2 = null, p2 = null, m2 = [], g = [], b2 = [], y = [], w = n2(), v = -1;
      if (this.comments = [], w != 65496)
        throw new Error("SOI not found");
      for (w = n2();w != 65497; ) {
        switch (w) {
          case 65280:
            break;
          case 65504:
          case 65505:
          case 65506:
          case 65507:
          case 65508:
          case 65509:
          case 65510:
          case 65511:
          case 65512:
          case 65513:
          case 65514:
          case 65515:
          case 65516:
          case 65517:
          case 65518:
          case 65519:
          case 65534:
            var x = (l2 = undefined, u2 = undefined, l2 = n2(), u2 = t2.subarray(r2, r2 + l2 - 2), r2 += u2.length, u2);
            if (w === 65534) {
              var E = String.fromCharCode.apply(null, x);
              this.comments.push(E);
            }
            w === 65504 && x[0] === 74 && x[1] === 70 && x[2] === 73 && x[3] === 70 && x[4] === 0 && (d2 = { version: { major: x[5], minor: x[6] }, densityUnits: x[7], xDensity: x[8] << 8 | x[9], yDensity: x[10] << 8 | x[11], thumbWidth: x[12], thumbHeight: x[13], thumbData: x.subarray(14, 14 + 3 * x[12] * x[13]) }), w === 65505 && x[0] === 69 && x[1] === 120 && x[2] === 105 && x[3] === 102 && x[4] === 0 && (this.exifBuffer = x.subarray(5, x.length)), w === 65518 && x[0] === 65 && x[1] === 100 && x[2] === 111 && x[3] === 98 && x[4] === 101 && x[5] === 0 && (p2 = { version: x[6], flags0: x[7] << 8 | x[8], flags1: x[9] << 8 | x[10], transformCode: x[11] });
            break;
          case 65499:
            for (var k = n2() + r2 - 2;r2 < k; ) {
              var S = t2[r2++];
              _(256);
              var A = new Int32Array(64);
              if (S >> 4) {
                if (S >> 4 != 1)
                  throw new Error("DQT: invalid table spec");
                for (q = 0;q < 64; q++)
                  A[e4[q]] = n2();
              } else
                for (q = 0;q < 64; q++)
                  A[e4[q]] = t2[r2++];
              m2[15 & S] = A;
            }
            break;
          case 65472:
          case 65473:
          case 65474:
            n2(), (o2 = {}).extended = w === 65473, o2.progressive = w === 65474, o2.precision = t2[r2++], o2.scanLines = n2(), o2.samplesPerLine = n2(), o2.components = {}, o2.componentsOrder = [];
            var I = o2.scanLines * o2.samplesPerLine;
            if (I > i2) {
              var M = Math.ceil((I - i2) / 1e6);
              throw new Error(`maxResolutionInMP limit exceeded by ${M}MP`);
            }
            var T, P = t2[r2++];
            for (Q = 0;Q < P; Q++) {
              T = t2[r2];
              var B = t2[r2 + 1] >> 4, C = 15 & t2[r2 + 1], R = t2[r2 + 2];
              if (B <= 0 || C <= 0)
                throw new Error("Invalid sampling factor, expected values above 0");
              o2.componentsOrder.push(T), o2.components[T] = { h: B, v: C, quantizationIdx: R }, r2 += 3;
            }
            a2(o2), g.push(o2);
            break;
          case 65476:
            var z = n2();
            for (Q = 2;Q < z; ) {
              var F = t2[r2++], N = new Uint8Array(16), O = 0;
              for (q = 0;q < 16; q++, r2++)
                O += N[q] = t2[r2];
              _(16 + O);
              var D = new Uint8Array(O);
              for (q = 0;q < O; q++, r2++)
                D[q] = t2[r2];
              Q += 17 + O, (F >> 4 ? b2 : y)[15 & F] = h(N, D);
            }
            break;
          case 65501:
            n2(), s2 = n2();
            break;
          case 65500:
            n2(), n2();
            break;
          case 65498:
            n2();
            var $ = t2[r2++], L = [];
            for (Q = 0;Q < $; Q++) {
              V = o2.components[t2[r2++]];
              var U = t2[r2++];
              V.huffmanTableDC = y[U >> 4], V.huffmanTableAC = b2[15 & U], L.push(V);
            }
            var Z = t2[r2++], j = t2[r2++], G = t2[r2++], H = c(t2, r2, o2, L, s2, Z, j, G >> 4, 15 & G, this.opts);
            r2 += H;
            break;
          case 65535:
            t2[r2] !== 255 && r2--;
            break;
          default:
            if (t2[r2 - 3] == 255 && t2[r2 - 2] >= 192 && t2[r2 - 2] <= 254) {
              r2 -= 3;
              break;
            }
            if (w === 224 || w == 225) {
              if (v !== -1)
                throw new Error(`first unknown JPEG marker at offset ${v.toString(16)}, second unknown JPEG marker ${w.toString(16)} at offset ${(r2 - 1).toString(16)}`);
              v = r2 - 1;
              const e5 = n2();
              if (t2[r2 + e5 - 2] === 255) {
                r2 += e5 - 2;
                break;
              }
            }
            throw new Error("unknown JPEG marker " + w.toString(16));
        }
        w = n2();
      }
      if (g.length != 1)
        throw new Error("only single frame JPEGs supported");
      for (var Q = 0;Q < g.length; Q++) {
        var W = g[Q].components;
        for (var q in W)
          W[q].quantizationTable = m2[W[q].quantizationIdx], delete W[q].quantizationIdx;
      }
      for (this.width = o2.samplesPerLine, this.height = o2.scanLines, this.jfif = d2, this.adobe = p2, this.components = [], Q = 0;Q < o2.componentsOrder.length; Q++) {
        var V = o2.components[o2.componentsOrder[Q]];
        this.components.push({ lines: f(0, V), scaleX: V.h / o2.maxH, scaleY: V.v / o2.maxV });
      }
    }, getData: function(e5, t2) {
      var i2, r2, n2, a2, o2, s2, l2, u2, h2, c2, f2, p2, m2, g, b2, y, w, v, x, E, k, S = this.width / e5, A = this.height / t2, I = 0, M = e5 * t2 * this.components.length;
      _(M);
      var T = new Uint8Array(M);
      switch (this.components.length) {
        case 1:
          for (i2 = this.components[0], c2 = 0;c2 < t2; c2++)
            for (o2 = i2.lines[0 | c2 * i2.scaleY * A], h2 = 0;h2 < e5; h2++)
              f2 = o2[0 | h2 * i2.scaleX * S], T[I++] = f2;
          break;
        case 2:
          for (i2 = this.components[0], r2 = this.components[1], c2 = 0;c2 < t2; c2++)
            for (o2 = i2.lines[0 | c2 * i2.scaleY * A], s2 = r2.lines[0 | c2 * r2.scaleY * A], h2 = 0;h2 < e5; h2++)
              f2 = o2[0 | h2 * i2.scaleX * S], T[I++] = f2, f2 = s2[0 | h2 * r2.scaleX * S], T[I++] = f2;
          break;
        case 3:
          for (k = true, this.adobe && this.adobe.transformCode ? k = true : this.opts.colorTransform !== undefined && (k = !!this.opts.colorTransform), i2 = this.components[0], r2 = this.components[1], n2 = this.components[2], c2 = 0;c2 < t2; c2++)
            for (o2 = i2.lines[0 | c2 * i2.scaleY * A], s2 = r2.lines[0 | c2 * r2.scaleY * A], l2 = n2.lines[0 | c2 * n2.scaleY * A], h2 = 0;h2 < e5; h2++)
              k ? (f2 = o2[0 | h2 * i2.scaleX * S], p2 = s2[0 | h2 * r2.scaleX * S], v = d(f2 + 1.402 * ((m2 = l2[0 | h2 * n2.scaleX * S]) - 128)), x = d(f2 - 0.3441363 * (p2 - 128) - 0.71413636 * (m2 - 128)), E = d(f2 + 1.772 * (p2 - 128))) : (v = o2[0 | h2 * i2.scaleX * S], x = s2[0 | h2 * r2.scaleX * S], E = l2[0 | h2 * n2.scaleX * S]), T[I++] = v, T[I++] = x, T[I++] = E;
          break;
        case 4:
          if (!this.adobe)
            throw new Error("Unsupported color mode (4 components)");
          for (k = false, this.adobe && this.adobe.transformCode ? k = true : this.opts.colorTransform !== undefined && (k = !!this.opts.colorTransform), i2 = this.components[0], r2 = this.components[1], n2 = this.components[2], a2 = this.components[3], c2 = 0;c2 < t2; c2++)
            for (o2 = i2.lines[0 | c2 * i2.scaleY * A], s2 = r2.lines[0 | c2 * r2.scaleY * A], l2 = n2.lines[0 | c2 * n2.scaleY * A], u2 = a2.lines[0 | c2 * a2.scaleY * A], h2 = 0;h2 < e5; h2++)
              k ? (f2 = o2[0 | h2 * i2.scaleX * S], p2 = s2[0 | h2 * r2.scaleX * S], m2 = l2[0 | h2 * n2.scaleX * S], g = u2[0 | h2 * a2.scaleX * S], b2 = 255 - d(f2 + 1.402 * (m2 - 128)), y = 255 - d(f2 - 0.3441363 * (p2 - 128) - 0.71413636 * (m2 - 128)), w = 255 - d(f2 + 1.772 * (p2 - 128))) : (b2 = o2[0 | h2 * i2.scaleX * S], y = s2[0 | h2 * r2.scaleX * S], w = l2[0 | h2 * n2.scaleX * S], g = u2[0 | h2 * a2.scaleX * S]), T[I++] = 255 - b2, T[I++] = 255 - y, T[I++] = 255 - w, T[I++] = 255 - g;
          break;
        default:
          throw new Error("Unsupported color mode");
      }
      return T;
    }, copyToImageData: function(e5, t2) {
      var i2, r2, n2, a2, o2, s2, l2, u2, h2, c2 = e5.width, f2 = e5.height, p2 = e5.data, m2 = this.getData(c2, f2), _2 = 0, g = 0;
      switch (this.components.length) {
        case 1:
          for (r2 = 0;r2 < f2; r2++)
            for (i2 = 0;i2 < c2; i2++)
              n2 = m2[_2++], p2[g++] = n2, p2[g++] = n2, p2[g++] = n2, t2 && (p2[g++] = 255);
          break;
        case 3:
          for (r2 = 0;r2 < f2; r2++)
            for (i2 = 0;i2 < c2; i2++)
              l2 = m2[_2++], u2 = m2[_2++], h2 = m2[_2++], p2[g++] = l2, p2[g++] = u2, p2[g++] = h2, t2 && (p2[g++] = 255);
          break;
        case 4:
          for (r2 = 0;r2 < f2; r2++)
            for (i2 = 0;i2 < c2; i2++)
              o2 = m2[_2++], s2 = m2[_2++], n2 = m2[_2++], l2 = 255 - d(o2 * (1 - (a2 = m2[_2++]) / 255) + a2), u2 = 255 - d(s2 * (1 - a2 / 255) + a2), h2 = 255 - d(n2 * (1 - a2 / 255) + a2), p2[g++] = l2, p2[g++] = u2, p2[g++] = h2, t2 && (p2[g++] = 255);
          break;
        default:
          throw new Error("Unsupported color mode");
      }
    } };
    var p = 0, m = 0;
    function _(e5 = 0) {
      var t2 = p + e5;
      if (t2 > m) {
        var i2 = Math.ceil((t2 - m) / 1024 / 1024);
        throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${i2}MB`);
      }
      p = t2;
    }
    return u.resetMaxMemoryUsage = function(e5) {
      p = 0, m = e5;
    }, u.getBytesAllocated = function() {
      return p;
    }, u.requestMemoryAllocation = _, u;
  }(), module.exports = function(e4, t = {}) {
    var i = { colorTransform: undefined, useTArray: false, formatAsRGBA: true, tolerantDecoding: true, maxResolutionInMP: 100, maxMemoryUsageInMB: 512, ...t }, r = new Uint8Array(e4), n = new JpegImage;
    n.opts = i, JpegImage.resetMaxMemoryUsage(1024 * i.maxMemoryUsageInMB * 1024), n.parse(r);
    var a = i.formatAsRGBA ? 4 : 3, o = n.width * n.height * a;
    try {
      JpegImage.requestMemoryAllocation(o);
      var s = { width: n.width, height: n.height, exifBuffer: n.exifBuffer, data: i.useTArray ? new Uint8Array(o) : Buffer2.alloc(o) };
      n.comments.length > 0 && (s.comments = n.comments);
    } catch (e5) {
      if (e5 instanceof RangeError)
        throw new Error("Could not allocate enough memory for the image. Required: " + o);
      if (e5 instanceof ReferenceError && e5.message === "Buffer is not defined")
        throw new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true");
      throw e5;
    }
    return n.copyToImageData(s, i.formatAsRGBA), s;
  };
  decoderExports = decoder.exports;
  encode = encoderExports;
  decode = decoderExports;
  jpegJs = { encode, decode };
  JPEG = getDefaultExportFromCjs(jpegJs);
  browser$1 = { exports: {} };
  browser$1.exports = function() {
    function e4(t, i, r) {
      function n(o2, s) {
        if (!i[o2]) {
          if (!t[o2]) {
            var l = typeof commonjsRequire == "function" && commonjsRequire;
            if (!s && l)
              return l(o2, true);
            if (a)
              return a(o2, true);
            var u = new Error("Cannot find module '" + o2 + "'");
            throw u.code = "MODULE_NOT_FOUND", u;
          }
          var h = i[o2] = { exports: {} };
          t[o2][0].call(h.exports, function(e5) {
            return n(t[o2][1][e5] || e5);
          }, h, h.exports, e4, t, i, r);
        }
        return i[o2].exports;
      }
      for (var a = typeof commonjsRequire == "function" && commonjsRequire, o = 0;o < r.length; o++)
        n(r[o]);
      return n;
    }
    return e4;
  }()({ 1: [function(e4, t, i) {
    (function(t2) {
      (function() {
        let r = e4("./interlace"), n = [function() {
        }, function(e5, t3, i2, r2) {
          if (r2 === t3.length)
            throw new Error("Ran out of data");
          let n2 = t3[r2];
          e5[i2] = n2, e5[i2 + 1] = n2, e5[i2 + 2] = n2, e5[i2 + 3] = 255;
        }, function(e5, t3, i2, r2) {
          if (r2 + 1 >= t3.length)
            throw new Error("Ran out of data");
          let n2 = t3[r2];
          e5[i2] = n2, e5[i2 + 1] = n2, e5[i2 + 2] = n2, e5[i2 + 3] = t3[r2 + 1];
        }, function(e5, t3, i2, r2) {
          if (r2 + 2 >= t3.length)
            throw new Error("Ran out of data");
          e5[i2] = t3[r2], e5[i2 + 1] = t3[r2 + 1], e5[i2 + 2] = t3[r2 + 2], e5[i2 + 3] = 255;
        }, function(e5, t3, i2, r2) {
          if (r2 + 3 >= t3.length)
            throw new Error("Ran out of data");
          e5[i2] = t3[r2], e5[i2 + 1] = t3[r2 + 1], e5[i2 + 2] = t3[r2 + 2], e5[i2 + 3] = t3[r2 + 3];
        }], a = [function() {
        }, function(e5, t3, i2, r2) {
          let n2 = t3[0];
          e5[i2] = n2, e5[i2 + 1] = n2, e5[i2 + 2] = n2, e5[i2 + 3] = r2;
        }, function(e5, t3, i2) {
          let r2 = t3[0];
          e5[i2] = r2, e5[i2 + 1] = r2, e5[i2 + 2] = r2, e5[i2 + 3] = t3[1];
        }, function(e5, t3, i2, r2) {
          e5[i2] = t3[0], e5[i2 + 1] = t3[1], e5[i2 + 2] = t3[2], e5[i2 + 3] = r2;
        }, function(e5, t3, i2) {
          e5[i2] = t3[0], e5[i2 + 1] = t3[1], e5[i2 + 2] = t3[2], e5[i2 + 3] = t3[3];
        }];
        function o(e5, t3) {
          let i2 = [], r2 = 0;
          function n2() {
            if (r2 === e5.length)
              throw new Error("Ran out of data");
            let n3, a2, o2, s2, l2, u, h, c, f = e5[r2];
            switch (r2++, t3) {
              default:
                throw new Error("unrecognised depth");
              case 16:
                h = e5[r2], r2++, i2.push((f << 8) + h);
                break;
              case 4:
                h = 15 & f, c = f >> 4, i2.push(c, h);
                break;
              case 2:
                l2 = 3 & f, u = f >> 2 & 3, h = f >> 4 & 3, c = f >> 6 & 3, i2.push(c, h, u, l2);
                break;
              case 1:
                n3 = 1 & f, a2 = f >> 1 & 1, o2 = f >> 2 & 1, s2 = f >> 3 & 1, l2 = f >> 4 & 1, u = f >> 5 & 1, h = f >> 6 & 1, c = f >> 7 & 1, i2.push(c, h, u, l2, s2, o2, a2, n3);
            }
          }
          return { get: function(e6) {
            for (;i2.length < e6; )
              n2();
            let t4 = i2.slice(0, e6);
            return i2 = i2.slice(e6), t4;
          }, resetAfterLine: function() {
            i2.length = 0;
          }, end: function() {
            if (r2 !== e5.length)
              throw new Error("extra data found");
          } };
        }
        function s(e5, t3, i2, r2, a2, o2) {
          let { width: s2, height: l2, index: u } = e5;
          for (let e6 = 0;e6 < l2; e6++)
            for (let l3 = 0;l3 < s2; l3++) {
              let s3 = i2(l3, e6, u);
              n[r2](t3, a2, s3, o2), o2 += r2;
            }
          return o2;
        }
        function l(e5, t3, i2, r2, n2, o2) {
          let { width: s2, height: l2, index: u } = e5;
          for (let e6 = 0;e6 < l2; e6++) {
            for (let l3 = 0;l3 < s2; l3++) {
              let s3 = n2.get(r2), h = i2(l3, e6, u);
              a[r2](t3, s3, h, o2);
            }
            n2.resetAfterLine();
          }
        }
        i.dataToBitMap = function(e5, i2) {
          let n2, a2, u = i2.width, h = i2.height, c = i2.depth, f = i2.bpp, d = i2.interlace;
          c !== 8 && (n2 = o(e5, c)), a2 = c <= 8 ? t2.alloc(u * h * 4) : new Uint16Array(u * h * 4);
          let p, m, _ = Math.pow(2, c) - 1, g = 0;
          if (d)
            p = r.getImagePasses(u, h), m = r.getInterlaceIterator(u, h);
          else {
            let e6 = 0;
            m = function() {
              let t3 = e6;
              return e6 += 4, t3;
            }, p = [{ width: u, height: h }];
          }
          for (let t3 = 0;t3 < p.length; t3++)
            c === 8 ? g = s(p[t3], a2, m, f, e5, g) : l(p[t3], a2, m, f, n2, _);
          if (c === 8) {
            if (g !== e5.length)
              throw new Error("extra data found");
          } else
            n2.end();
          return a2;
        };
      }).call(this);
    }).call(this, e4("buffer").Buffer);
  }, { "./interlace": 11, buffer: 32 }], 2: [function(e4, t, i) {
    (function(i2) {
      (function() {
        let r = e4("./constants");
        t.exports = function(e5, t2, n, a) {
          let o = [r.COLORTYPE_COLOR_ALPHA, r.COLORTYPE_ALPHA].indexOf(a.colorType) !== -1;
          if (a.colorType === a.inputColorType) {
            let t3 = function() {
              let e6 = new ArrayBuffer(2);
              return new DataView(e6).setInt16(0, 256, true), new Int16Array(e6)[0] !== 256;
            }();
            if (a.bitDepth === 8 || a.bitDepth === 16 && t3)
              return e5;
          }
          let s = a.bitDepth !== 16 ? e5 : new Uint16Array(e5.buffer), l = 255, u = r.COLORTYPE_TO_BPP_MAP[a.inputColorType];
          u !== 4 || a.inputHasAlpha || (u = 3);
          let h = r.COLORTYPE_TO_BPP_MAP[a.colorType];
          a.bitDepth === 16 && (l = 65535, h *= 2);
          let c = i2.alloc(t2 * n * h), f = 0, d = 0, p = a.bgColor || {};
          function m() {
            let e6, t3, i3, n2 = l;
            switch (a.inputColorType) {
              case r.COLORTYPE_COLOR_ALPHA:
                n2 = s[f + 3], e6 = s[f], t3 = s[f + 1], i3 = s[f + 2];
                break;
              case r.COLORTYPE_COLOR:
                e6 = s[f], t3 = s[f + 1], i3 = s[f + 2];
                break;
              case r.COLORTYPE_ALPHA:
                n2 = s[f + 1], e6 = s[f], t3 = e6, i3 = e6;
                break;
              case r.COLORTYPE_GRAYSCALE:
                e6 = s[f], t3 = e6, i3 = e6;
                break;
              default:
                throw new Error("input color type:" + a.inputColorType + " is not supported at present");
            }
            return a.inputHasAlpha && (o || (n2 /= l, e6 = Math.min(Math.max(Math.round((1 - n2) * p.red + n2 * e6), 0), l), t3 = Math.min(Math.max(Math.round((1 - n2) * p.green + n2 * t3), 0), l), i3 = Math.min(Math.max(Math.round((1 - n2) * p.blue + n2 * i3), 0), l))), { red: e6, green: t3, blue: i3, alpha: n2 };
          }
          p.red === undefined && (p.red = l), p.green === undefined && (p.green = l), p.blue === undefined && (p.blue = l);
          for (let e6 = 0;e6 < n; e6++)
            for (let e7 = 0;e7 < t2; e7++) {
              let e8 = m();
              switch (a.colorType) {
                case r.COLORTYPE_COLOR_ALPHA:
                case r.COLORTYPE_COLOR:
                  a.bitDepth === 8 ? (c[d] = e8.red, c[d + 1] = e8.green, c[d + 2] = e8.blue, o && (c[d + 3] = e8.alpha)) : (c.writeUInt16BE(e8.red, d), c.writeUInt16BE(e8.green, d + 2), c.writeUInt16BE(e8.blue, d + 4), o && c.writeUInt16BE(e8.alpha, d + 6));
                  break;
                case r.COLORTYPE_ALPHA:
                case r.COLORTYPE_GRAYSCALE: {
                  let t3 = (e8.red + e8.green + e8.blue) / 3;
                  a.bitDepth === 8 ? (c[d] = t3, o && (c[d + 1] = e8.alpha)) : (c.writeUInt16BE(t3, d), o && c.writeUInt16BE(e8.alpha, d + 2));
                  break;
                }
                default:
                  throw new Error("unrecognised color Type " + a.colorType);
              }
              f += u, d += h;
            }
          return c;
        };
      }).call(this);
    }).call(this, e4("buffer").Buffer);
  }, { "./constants": 4, buffer: 32 }], 3: [function(e4, t, i) {
    (function(i2, r) {
      (function() {
        let n = e4("util"), a = e4("stream"), o = t.exports = function() {
          a.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = false, this._encoding = "utf8", this.writable = true;
        };
        n.inherits(o, a), o.prototype.read = function(e5, t2) {
          this._reads.push({ length: Math.abs(e5), allowLess: e5 < 0, func: t2 }), i2.nextTick(function() {
            this._process(), this._paused && this._reads && this._reads.length > 0 && (this._paused = false, this.emit("drain"));
          }.bind(this));
        }, o.prototype.write = function(e5, t2) {
          if (!this.writable)
            return this.emit("error", new Error("Stream not writable")), false;
          let i3;
          return i3 = r.isBuffer(e5) ? e5 : r.from(e5, t2 || this._encoding), this._buffers.push(i3), this._buffered += i3.length, this._process(), this._reads && this._reads.length === 0 && (this._paused = true), this.writable && !this._paused;
        }, o.prototype.end = function(e5, t2) {
          e5 && this.write(e5, t2), this.writable = false, this._buffers && (this._buffers.length === 0 ? this._end() : (this._buffers.push(null), this._process()));
        }, o.prototype.destroySoon = o.prototype.end, o.prototype._end = function() {
          this._reads.length > 0 && this.emit("error", new Error("Unexpected end of input")), this.destroy();
        }, o.prototype.destroy = function() {
          this._buffers && (this.writable = false, this._reads = null, this._buffers = null, this.emit("close"));
        }, o.prototype._processReadAllowingLess = function(e5) {
          this._reads.shift();
          let t2 = this._buffers[0];
          t2.length > e5.length ? (this._buffered -= e5.length, this._buffers[0] = t2.slice(e5.length), e5.func.call(this, t2.slice(0, e5.length))) : (this._buffered -= t2.length, this._buffers.shift(), e5.func.call(this, t2));
        }, o.prototype._processRead = function(e5) {
          this._reads.shift();
          let t2 = 0, i3 = 0, n2 = r.alloc(e5.length);
          for (;t2 < e5.length; ) {
            let r2 = this._buffers[i3++], a2 = Math.min(r2.length, e5.length - t2);
            r2.copy(n2, t2, 0, a2), t2 += a2, a2 !== r2.length && (this._buffers[--i3] = r2.slice(a2));
          }
          i3 > 0 && this._buffers.splice(0, i3), this._buffered -= e5.length, e5.func.call(this, n2);
        }, o.prototype._process = function() {
          try {
            for (;this._buffered > 0 && this._reads && this._reads.length > 0; ) {
              let e5 = this._reads[0];
              if (e5.allowLess)
                this._processReadAllowingLess(e5);
              else {
                if (!(this._buffered >= e5.length))
                  break;
                this._processRead(e5);
              }
            }
            this._buffers && !this.writable && this._end();
          } catch (e5) {
            this.emit("error", e5);
          }
        };
      }).call(this);
    }).call(this, e4("_process"), e4("buffer").Buffer);
  }, { _process: 63, buffer: 32, stream: 65, util: 84 }], 4: [function(e4, t, i) {
    t.exports = { PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10], TYPE_IHDR: 1229472850, TYPE_IEND: 1229278788, TYPE_IDAT: 1229209940, TYPE_PLTE: 1347179589, TYPE_tRNS: 1951551059, TYPE_gAMA: 1732332865, COLORTYPE_GRAYSCALE: 0, COLORTYPE_PALETTE: 1, COLORTYPE_COLOR: 2, COLORTYPE_ALPHA: 4, COLORTYPE_PALETTE_COLOR: 3, COLORTYPE_COLOR_ALPHA: 6, COLORTYPE_TO_BPP_MAP: { 0: 1, 2: 3, 3: 1, 4: 2, 6: 4 }, GAMMA_DIVISION: 1e5 };
  }, {}], 5: [function(e4, t, i) {
    let r = [];
    (function() {
      for (let e5 = 0;e5 < 256; e5++) {
        let t2 = e5;
        for (let e6 = 0;e6 < 8; e6++)
          1 & t2 ? t2 = 3988292384 ^ t2 >>> 1 : t2 >>>= 1;
        r[e5] = t2;
      }
    })();
    let n = t.exports = function() {
      this._crc = -1;
    };
    n.prototype.write = function(e5) {
      for (let t2 = 0;t2 < e5.length; t2++)
        this._crc = r[255 & (this._crc ^ e5[t2])] ^ this._crc >>> 8;
      return true;
    }, n.prototype.crc32 = function() {
      return ~this._crc;
    }, n.crc32 = function(e5) {
      let t2 = -1;
      for (let i2 = 0;i2 < e5.length; i2++)
        t2 = r[255 & (t2 ^ e5[i2])] ^ t2 >>> 8;
      return ~t2;
    };
  }, {}], 6: [function(e4, t, i) {
    (function(i2) {
      (function() {
        let r = e4("./paeth-predictor");
        function n(e5, t2, i3, r2, n2) {
          for (let a2 = 0;a2 < i3; a2++)
            r2[n2 + a2] = e5[t2 + a2];
        }
        function a(e5, t2, i3) {
          let r2 = 0, n2 = t2 + i3;
          for (let i4 = t2;i4 < n2; i4++)
            r2 += Math.abs(e5[i4]);
          return r2;
        }
        function o(e5, t2, i3, r2, n2, a2) {
          for (let o2 = 0;o2 < i3; o2++) {
            let i4 = o2 >= a2 ? e5[t2 + o2 - a2] : 0, s2 = e5[t2 + o2] - i4;
            r2[n2 + o2] = s2;
          }
        }
        function s(e5, t2, i3, r2) {
          let n2 = 0;
          for (let a2 = 0;a2 < i3; a2++) {
            let i4 = a2 >= r2 ? e5[t2 + a2 - r2] : 0, o2 = e5[t2 + a2] - i4;
            n2 += Math.abs(o2);
          }
          return n2;
        }
        function l(e5, t2, i3, r2, n2) {
          for (let a2 = 0;a2 < i3; a2++) {
            let o2 = t2 > 0 ? e5[t2 + a2 - i3] : 0, s2 = e5[t2 + a2] - o2;
            r2[n2 + a2] = s2;
          }
        }
        function u(e5, t2, i3) {
          let r2 = 0, n2 = t2 + i3;
          for (let a2 = t2;a2 < n2; a2++) {
            let n3 = t2 > 0 ? e5[a2 - i3] : 0, o2 = e5[a2] - n3;
            r2 += Math.abs(o2);
          }
          return r2;
        }
        function h(e5, t2, i3, r2, n2, a2) {
          for (let o2 = 0;o2 < i3; o2++) {
            let s2 = o2 >= a2 ? e5[t2 + o2 - a2] : 0, l2 = t2 > 0 ? e5[t2 + o2 - i3] : 0, u2 = e5[t2 + o2] - (s2 + l2 >> 1);
            r2[n2 + o2] = u2;
          }
        }
        function c(e5, t2, i3, r2) {
          let n2 = 0;
          for (let a2 = 0;a2 < i3; a2++) {
            let o2 = a2 >= r2 ? e5[t2 + a2 - r2] : 0, s2 = t2 > 0 ? e5[t2 + a2 - i3] : 0, l2 = e5[t2 + a2] - (o2 + s2 >> 1);
            n2 += Math.abs(l2);
          }
          return n2;
        }
        function f(e5, t2, i3, n2, a2, o2) {
          for (let s2 = 0;s2 < i3; s2++) {
            let l2 = s2 >= o2 ? e5[t2 + s2 - o2] : 0, u2 = t2 > 0 ? e5[t2 + s2 - i3] : 0, h2 = t2 > 0 && s2 >= o2 ? e5[t2 + s2 - (i3 + o2)] : 0, c2 = e5[t2 + s2] - r(l2, u2, h2);
            n2[a2 + s2] = c2;
          }
        }
        function d(e5, t2, i3, n2) {
          let a2 = 0;
          for (let o2 = 0;o2 < i3; o2++) {
            let s2 = o2 >= n2 ? e5[t2 + o2 - n2] : 0, l2 = t2 > 0 ? e5[t2 + o2 - i3] : 0, u2 = t2 > 0 && o2 >= n2 ? e5[t2 + o2 - (i3 + n2)] : 0, h2 = e5[t2 + o2] - r(s2, l2, u2);
            a2 += Math.abs(h2);
          }
          return a2;
        }
        let p = { 0: n, 1: o, 2: l, 3: h, 4: f }, m = { 0: a, 1: s, 2: u, 3: c, 4: d };
        t.exports = function(e5, t2, r2, n2, a2) {
          let o2;
          if ("filterType" in n2 && n2.filterType !== -1) {
            if (typeof n2.filterType != "number")
              throw new Error("unrecognised filter types");
            o2 = [n2.filterType];
          } else
            o2 = [0, 1, 2, 3, 4];
          n2.bitDepth === 16 && (a2 *= 2);
          let s2 = t2 * a2, l2 = 0, u2 = 0, h2 = i2.alloc((s2 + 1) * r2), c2 = o2[0];
          for (let t3 = 0;t3 < r2; t3++) {
            if (o2.length > 1) {
              let t4 = 1 / 0;
              for (let i3 = 0;i3 < o2.length; i3++) {
                let r3 = m[o2[i3]](e5, u2, s2, a2);
                r3 < t4 && (c2 = o2[i3], t4 = r3);
              }
            }
            h2[l2] = c2, l2++, p[c2](e5, u2, s2, h2, l2, a2), l2 += s2, u2 += s2;
          }
          return h2;
        };
      }).call(this);
    }).call(this, e4("buffer").Buffer);
  }, { "./paeth-predictor": 15, buffer: 32 }], 7: [function(e4, t, i) {
    (function(i2) {
      (function() {
        let r = e4("util"), n = e4("./chunkstream"), a = e4("./filter-parse"), o = t.exports = function(e5) {
          n.call(this);
          let t2 = [], r2 = this;
          this._filter = new a(e5, { read: this.read.bind(this), write: function(e6) {
            t2.push(e6);
          }, complete: function() {
            r2.emit("complete", i2.concat(t2));
          } }), this._filter.start();
        };
        r.inherits(o, n);
      }).call(this);
    }).call(this, e4("buffer").Buffer);
  }, { "./chunkstream": 3, "./filter-parse": 9, buffer: 32, util: 84 }], 8: [function(e4, t, i) {
    (function(t2) {
      (function() {
        let r = e4("./sync-reader"), n = e4("./filter-parse");
        i.process = function(e5, i2) {
          let a = [], o = new r(e5);
          return new n(i2, { read: o.read.bind(o), write: function(e6) {
            a.push(e6);
          }, complete: function() {
          } }).start(), o.process(), t2.concat(a);
        };
      }).call(this);
    }).call(this, e4("buffer").Buffer);
  }, { "./filter-parse": 9, "./sync-reader": 22, buffer: 32 }], 9: [function(e4, t, i) {
    (function(i2) {
      (function() {
        let r = e4("./interlace"), n = e4("./paeth-predictor");
        function a(e5, t2, i3) {
          let r2 = e5 * t2;
          return i3 !== 8 && (r2 = Math.ceil(r2 / (8 / i3))), r2;
        }
        let o = t.exports = function(e5, t2) {
          let { width: i3, height: n2, interlace: o2, bpp: s, depth: l } = e5;
          if (this.read = t2.read, this.write = t2.write, this.complete = t2.complete, this._imageIndex = 0, this._images = [], o2) {
            let e6 = r.getImagePasses(i3, n2);
            for (let t3 = 0;t3 < e6.length; t3++)
              this._images.push({ byteWidth: a(e6[t3].width, s, l), height: e6[t3].height, lineIndex: 0 });
          } else
            this._images.push({ byteWidth: a(i3, s, l), height: n2, lineIndex: 0 });
          this._xComparison = l === 8 ? s : l === 16 ? 2 * s : 1;
        };
        o.prototype.start = function() {
          this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
        }, o.prototype._unFilterType1 = function(e5, t2, i3) {
          let r2 = this._xComparison, n2 = r2 - 1;
          for (let a2 = 0;a2 < i3; a2++) {
            let i4 = e5[1 + a2], o2 = a2 > n2 ? t2[a2 - r2] : 0;
            t2[a2] = i4 + o2;
          }
        }, o.prototype._unFilterType2 = function(e5, t2, i3) {
          let r2 = this._lastLine;
          for (let n2 = 0;n2 < i3; n2++) {
            let i4 = e5[1 + n2], a2 = r2 ? r2[n2] : 0;
            t2[n2] = i4 + a2;
          }
        }, o.prototype._unFilterType3 = function(e5, t2, i3) {
          let r2 = this._xComparison, n2 = r2 - 1, a2 = this._lastLine;
          for (let o2 = 0;o2 < i3; o2++) {
            let i4 = e5[1 + o2], s = a2 ? a2[o2] : 0, l = o2 > n2 ? t2[o2 - r2] : 0, u = Math.floor((l + s) / 2);
            t2[o2] = i4 + u;
          }
        }, o.prototype._unFilterType4 = function(e5, t2, i3) {
          let r2 = this._xComparison, a2 = r2 - 1, o2 = this._lastLine;
          for (let s = 0;s < i3; s++) {
            let i4 = e5[1 + s], l = o2 ? o2[s] : 0, u = s > a2 ? t2[s - r2] : 0, h = s > a2 && o2 ? o2[s - r2] : 0, c = n(u, l, h);
            t2[s] = i4 + c;
          }
        }, o.prototype._reverseFilterLine = function(e5) {
          let t2, r2 = e5[0], n2 = this._images[this._imageIndex], a2 = n2.byteWidth;
          if (r2 === 0)
            t2 = e5.slice(1, a2 + 1);
          else
            switch (t2 = i2.alloc(a2), r2) {
              case 1:
                this._unFilterType1(e5, t2, a2);
                break;
              case 2:
                this._unFilterType2(e5, t2, a2);
                break;
              case 3:
                this._unFilterType3(e5, t2, a2);
                break;
              case 4:
                this._unFilterType4(e5, t2, a2);
                break;
              default:
                throw new Error("Unrecognised filter type - " + r2);
            }
          this.write(t2), n2.lineIndex++, n2.lineIndex >= n2.height ? (this._lastLine = null, this._imageIndex++, n2 = this._images[this._imageIndex]) : this._lastLine = t2, n2 ? this.read(n2.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, this.complete());
        };
      }).call(this);
    }).call(this, e4("buffer").Buffer);
  }, { "./interlace": 11, "./paeth-predictor": 15, buffer: 32 }], 10: [function(e4, t, i) {
    (function(e5) {
      (function() {
        function i2(e6, t2, i3, r2, n2) {
          let a = 0;
          for (let o = 0;o < r2; o++)
            for (let r3 = 0;r3 < i3; r3++) {
              let i4 = n2[e6[a]];
              if (!i4)
                throw new Error("index " + e6[a] + " not in palette");
              for (let e7 = 0;e7 < 4; e7++)
                t2[a + e7] = i4[e7];
              a += 4;
            }
        }
        function r(e6, t2, i3, r2, n2) {
          let a = 0;
          for (let o = 0;o < r2; o++)
            for (let r3 = 0;r3 < i3; r3++) {
              let i4 = false;
              if (n2.length === 1 ? n2[0] === e6[a] && (i4 = true) : n2[0] === e6[a] && n2[1] === e6[a + 1] && n2[2] === e6[a + 2] && (i4 = true), i4)
                for (let e7 = 0;e7 < 4; e7++)
                  t2[a + e7] = 0;
              a += 4;
            }
        }
        function n(e6, t2, i3, r2, n2) {
          let a = 255, o = Math.pow(2, n2) - 1, s = 0;
          for (let n3 = 0;n3 < r2; n3++)
            for (let r3 = 0;r3 < i3; r3++) {
              for (let i4 = 0;i4 < 4; i4++)
                t2[s + i4] = Math.floor(e6[s + i4] * a / o + 0.5);
              s += 4;
            }
        }
        t.exports = function(t2, a, o = false) {
          let { depth: s, width: l, height: u, colorType: h, transColor: c, palette: f } = a, d = t2;
          return h === 3 ? i2(t2, d, l, u, f) : (c && r(t2, d, l, u, c), s === 8 || o || (s === 16 && (d = e5.alloc(l * u * 4)), n(t2, d, l, u, s))), d;
        };
      }).call(this);
    }).call(this, e4("buffer").Buffer);
  }, { buffer: 32 }], 11: [function(e4, t, i) {
    let r = [{ x: [0], y: [0] }, { x: [4], y: [0] }, { x: [0, 4], y: [4] }, { x: [2, 6], y: [0, 4] }, { x: [0, 2, 4, 6], y: [2, 6] }, { x: [1, 3, 5, 7], y: [0, 2, 4, 6] }, { x: [0, 1, 2, 3, 4, 5, 6, 7], y: [1, 3, 5, 7] }];
    i.getImagePasses = function(e5, t2) {
      let i2 = [], n = e5 % 8, a = t2 % 8, o = (e5 - n) / 8, s = (t2 - a) / 8;
      for (let e6 = 0;e6 < r.length; e6++) {
        let t3 = r[e6], l = o * t3.x.length, u = s * t3.y.length;
        for (let e7 = 0;e7 < t3.x.length && t3.x[e7] < n; e7++)
          l++;
        for (let e7 = 0;e7 < t3.y.length && t3.y[e7] < a; e7++)
          u++;
        l > 0 && u > 0 && i2.push({ width: l, height: u, index: e6 });
      }
      return i2;
    }, i.getInterlaceIterator = function(e5) {
      return function(t2, i2, n) {
        let a = t2 % r[n].x.length, o = (t2 - a) / r[n].x.length * 8 + r[n].x[a], s = i2 % r[n].y.length;
        return 4 * o + ((i2 - s) / r[n].y.length * 8 + r[n].y[s]) * e5 * 4;
      };
    };
  }, {}], 12: [function(e4, t, i) {
    (function(i2) {
      (function() {
        let r = e4("util"), n = e4("stream"), a = e4("./constants"), o = e4("./packer"), s = t.exports = function(e5) {
          n.call(this);
          let t2 = e5 || {};
          this._packer = new o(t2), this._deflate = this._packer.createDeflate(), this.readable = true;
        };
        r.inherits(s, n), s.prototype.pack = function(e5, t2, r2, n2) {
          this.emit("data", i2.from(a.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(t2, r2)), n2 && this.emit("data", this._packer.packGAMA(n2));
          let o2 = this._packer.filterData(e5, t2, r2);
          this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on("data", function(e6) {
            this.emit("data", this._packer.packIDAT(e6));
          }.bind(this)), this._deflate.on("end", function() {
            this.emit("data", this._packer.packIEND()), this.emit("end");
          }.bind(this)), this._deflate.end(o2);
        };
      }).call(this);
    }).call(this, e4("buffer").Buffer);
  }, { "./constants": 4, "./packer": 14, buffer: 32, stream: 65, util: 84 }], 13: [function(e4, t, i) {
    (function(i2) {
      (function() {
        let r = true, n = e4("zlib");
        n.deflateSync || (r = false);
        let a = e4("./constants"), o = e4("./packer");
        t.exports = function(e5, t2) {
          if (!r)
            throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
          let s = new o(t2 || {}), l = [];
          l.push(i2.from(a.PNG_SIGNATURE)), l.push(s.packIHDR(e5.width, e5.height)), e5.gamma && l.push(s.packGAMA(e5.gamma));
          let u = s.filterData(e5.data, e5.width, e5.height), h = n.deflateSync(u, s.getDeflateOptions());
          if (u = null, !h || !h.length)
            throw new Error("bad png - invalid compressed data response");
          return l.push(s.packIDAT(h)), l.push(s.packIEND()), i2.concat(l);
        };
      }).call(this);
    }).call(this, e4("buffer").Buffer);
  }, { "./constants": 4, "./packer": 14, buffer: 32, zlib: 31 }], 14: [function(e4, t, i) {
    (function(i2) {
      (function() {
        let r = e4("./constants"), n = e4("./crc"), a = e4("./bitpacker"), o = e4("./filter-pack"), s = e4("zlib"), l = t.exports = function(e5) {
          if (this._options = e5, e5.deflateChunkSize = e5.deflateChunkSize || 32768, e5.deflateLevel = e5.deflateLevel != null ? e5.deflateLevel : 9, e5.deflateStrategy = e5.deflateStrategy != null ? e5.deflateStrategy : 3, e5.inputHasAlpha = e5.inputHasAlpha == null || e5.inputHasAlpha, e5.deflateFactory = e5.deflateFactory || s.createDeflate, e5.bitDepth = e5.bitDepth || 8, e5.colorType = typeof e5.colorType == "number" ? e5.colorType : r.COLORTYPE_COLOR_ALPHA, e5.inputColorType = typeof e5.inputColorType == "number" ? e5.inputColorType : r.COLORTYPE_COLOR_ALPHA, [r.COLORTYPE_GRAYSCALE, r.COLORTYPE_COLOR, r.COLORTYPE_COLOR_ALPHA, r.COLORTYPE_ALPHA].indexOf(e5.colorType) === -1)
            throw new Error("option color type:" + e5.colorType + " is not supported at present");
          if ([r.COLORTYPE_GRAYSCALE, r.COLORTYPE_COLOR, r.COLORTYPE_COLOR_ALPHA, r.COLORTYPE_ALPHA].indexOf(e5.inputColorType) === -1)
            throw new Error("option input color type:" + e5.inputColorType + " is not supported at present");
          if (e5.bitDepth !== 8 && e5.bitDepth !== 16)
            throw new Error("option bit depth:" + e5.bitDepth + " is not supported at present");
        };
        l.prototype.getDeflateOptions = function() {
          return { chunkSize: this._options.deflateChunkSize, level: this._options.deflateLevel, strategy: this._options.deflateStrategy };
        }, l.prototype.createDeflate = function() {
          return this._options.deflateFactory(this.getDeflateOptions());
        }, l.prototype.filterData = function(e5, t2, i3) {
          let n2 = a(e5, t2, i3, this._options), s2 = r.COLORTYPE_TO_BPP_MAP[this._options.colorType];
          return o(n2, t2, i3, this._options, s2);
        }, l.prototype._packChunk = function(e5, t2) {
          let r2 = t2 ? t2.length : 0, a2 = i2.alloc(r2 + 12);
          return a2.writeUInt32BE(r2, 0), a2.writeUInt32BE(e5, 4), t2 && t2.copy(a2, 8), a2.writeInt32BE(n.crc32(a2.slice(4, a2.length - 4)), a2.length - 4), a2;
        }, l.prototype.packGAMA = function(e5) {
          let t2 = i2.alloc(4);
          return t2.writeUInt32BE(Math.floor(e5 * r.GAMMA_DIVISION), 0), this._packChunk(r.TYPE_gAMA, t2);
        }, l.prototype.packIHDR = function(e5, t2) {
          let n2 = i2.alloc(13);
          return n2.writeUInt32BE(e5, 0), n2.writeUInt32BE(t2, 4), n2[8] = this._options.bitDepth, n2[9] = this._options.colorType, n2[10] = 0, n2[11] = 0, n2[12] = 0, this._packChunk(r.TYPE_IHDR, n2);
        }, l.prototype.packIDAT = function(e5) {
          return this._packChunk(r.TYPE_IDAT, e5);
        }, l.prototype.packIEND = function() {
          return this._packChunk(r.TYPE_IEND, null);
        };
      }).call(this);
    }).call(this, e4("buffer").Buffer);
  }, { "./bitpacker": 2, "./constants": 4, "./crc": 5, "./filter-pack": 6, buffer: 32, zlib: 31 }], 15: [function(e4, t, i) {
    t.exports = function(e5, t2, i2) {
      let r = e5 + t2 - i2, n = Math.abs(r - e5), a = Math.abs(r - t2), o = Math.abs(r - i2);
      return n <= a && n <= o ? e5 : a <= o ? t2 : i2;
    };
  }, {}], 16: [function(e4, t, i) {
    let r = e4("util"), n = e4("zlib"), a = e4("./chunkstream"), o = e4("./filter-parse-async"), s = e4("./parser"), l = e4("./bitmapper"), u = e4("./format-normaliser"), h = t.exports = function(e5) {
      a.call(this), this._parser = new s(e5, { read: this.read.bind(this), error: this._handleError.bind(this), metadata: this._handleMetaData.bind(this), gamma: this.emit.bind(this, "gamma"), palette: this._handlePalette.bind(this), transColor: this._handleTransColor.bind(this), finished: this._finished.bind(this), inflateData: this._inflateData.bind(this), simpleTransparency: this._simpleTransparency.bind(this), headersFinished: this._headersFinished.bind(this) }), this._options = e5, this.writable = true, this._parser.start();
    };
    r.inherits(h, a), h.prototype._handleError = function(e5) {
      this.emit("error", e5), this.writable = false, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), this._filter && (this._filter.destroy(), this._filter.on("error", function() {
      })), this.errord = true;
    }, h.prototype._inflateData = function(e5) {
      if (!this._inflate)
        if (this._bitmapInfo.interlace)
          this._inflate = n.createInflate(), this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), this._inflate.pipe(this._filter);
        else {
          let e6 = (1 + (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3)) * this._bitmapInfo.height, t2 = Math.max(e6, n.Z_MIN_CHUNK);
          this._inflate = n.createInflate({ chunkSize: t2 });
          let i2 = e6, r2 = this.emit.bind(this, "error");
          this._inflate.on("error", function(e7) {
            i2 && r2(e7);
          }), this._filter.on("complete", this._complete.bind(this));
          let a2 = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(e7) {
            i2 && (e7.length > i2 && (e7 = e7.slice(0, i2)), i2 -= e7.length, a2(e7));
          }), this._inflate.on("end", this._filter.end.bind(this._filter));
        }
      this._inflate.write(e5);
    }, h.prototype._handleMetaData = function(e5) {
      this._metaData = e5, this._bitmapInfo = Object.create(e5), this._filter = new o(this._bitmapInfo);
    }, h.prototype._handleTransColor = function(e5) {
      this._bitmapInfo.transColor = e5;
    }, h.prototype._handlePalette = function(e5) {
      this._bitmapInfo.palette = e5;
    }, h.prototype._simpleTransparency = function() {
      this._metaData.alpha = true;
    }, h.prototype._headersFinished = function() {
      this.emit("metadata", this._metaData);
    }, h.prototype._finished = function() {
      this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"));
    }, h.prototype._complete = function(e5) {
      if (this.errord)
        return;
      let t2;
      try {
        let i2 = l.dataToBitMap(e5, this._bitmapInfo);
        t2 = u(i2, this._bitmapInfo, this._options.skipRescale), i2 = null;
      } catch (e6) {
        return void this._handleError(e6);
      }
      this.emit("parsed", t2);
    };
  }, { "./bitmapper": 1, "./chunkstream": 3, "./filter-parse-async": 7, "./format-normaliser": 10, "./parser": 18, util: 84, zlib: 31 }], 17: [function(e4, t, i) {
    (function(i2) {
      (function() {
        let r = true, n = e4("zlib"), a = e4("./sync-inflate");
        n.deflateSync || (r = false);
        let o = e4("./sync-reader"), s = e4("./filter-parse-sync"), l = e4("./parser"), u = e4("./bitmapper"), h = e4("./format-normaliser");
        t.exports = function(e5, t2) {
          if (!r)
            throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
          let c, f, d;
          function p(e6) {
            c = e6;
          }
          function m(e6) {
            f = e6;
          }
          function _(e6) {
            f.transColor = e6;
          }
          function g(e6) {
            f.palette = e6;
          }
          function b2() {
            f.alpha = true;
          }
          function y(e6) {
            d = e6;
          }
          let w = [];
          function v(e6) {
            w.push(e6);
          }
          let x = new o(e5);
          if (new l(t2, { read: x.read.bind(x), error: p, metadata: m, gamma: y, palette: g, transColor: _, inflateData: v, simpleTransparency: b2 }).start(), x.process(), c)
            throw c;
          let E, k = i2.concat(w);
          if (w.length = 0, f.interlace)
            E = n.inflateSync(k);
          else {
            let e6 = (1 + (f.width * f.bpp * f.depth + 7 >> 3)) * f.height;
            E = a(k, { chunkSize: e6, maxLength: e6 });
          }
          if (k = null, !E || !E.length)
            throw new Error("bad png - invalid inflate data response");
          let S = s.process(E, f);
          k = null;
          let A = u.dataToBitMap(S, f);
          S = null;
          let I = h(A, f, t2.skipRescale);
          return f.data = I, f.gamma = d || 0, f;
        };
      }).call(this);
    }).call(this, e4("buffer").Buffer);
  }, { "./bitmapper": 1, "./filter-parse-sync": 8, "./format-normaliser": 10, "./parser": 18, "./sync-inflate": 21, "./sync-reader": 22, buffer: 32, zlib: 31 }], 18: [function(e4, t, i) {
    (function(i2) {
      (function() {
        let r = e4("./constants"), n = e4("./crc"), a = t.exports = function(e5, t2) {
          this._options = e5, e5.checkCRC = e5.checkCRC !== false, this._hasIHDR = false, this._hasIEND = false, this._emittedHeadersFinished = false, this._palette = [], this._colorType = 0, this._chunks = {}, this._chunks[r.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[r.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[r.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[r.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[r.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[r.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = t2.read, this.error = t2.error, this.metadata = t2.metadata, this.gamma = t2.gamma, this.transColor = t2.transColor, this.palette = t2.palette, this.parsed = t2.parsed, this.inflateData = t2.inflateData, this.finished = t2.finished, this.simpleTransparency = t2.simpleTransparency, this.headersFinished = t2.headersFinished || function() {
          };
        };
        a.prototype.start = function() {
          this.read(r.PNG_SIGNATURE.length, this._parseSignature.bind(this));
        }, a.prototype._parseSignature = function(e5) {
          let t2 = r.PNG_SIGNATURE;
          for (let i3 = 0;i3 < t2.length; i3++)
            if (e5[i3] !== t2[i3])
              return void this.error(new Error("Invalid file signature"));
          this.read(8, this._parseChunkBegin.bind(this));
        }, a.prototype._parseChunkBegin = function(e5) {
          let t2 = e5.readUInt32BE(0), a2 = e5.readUInt32BE(4), o = "";
          for (let t3 = 4;t3 < 8; t3++)
            o += String.fromCharCode(e5[t3]);
          let s = Boolean(32 & e5[4]);
          if (this._hasIHDR || a2 === r.TYPE_IHDR) {
            if (this._crc = new n, this._crc.write(i2.from(o)), this._chunks[a2])
              return this._chunks[a2](t2);
            s ? this.read(t2 + 4, this._skipChunk.bind(this)) : this.error(new Error("Unsupported critical chunk type " + o));
          } else
            this.error(new Error("Expected IHDR on beggining"));
        }, a.prototype._skipChunk = function() {
          this.read(8, this._parseChunkBegin.bind(this));
        }, a.prototype._handleChunkEnd = function() {
          this.read(4, this._parseChunkEnd.bind(this));
        }, a.prototype._parseChunkEnd = function(e5) {
          let t2 = e5.readInt32BE(0), i3 = this._crc.crc32();
          this._options.checkCRC && i3 !== t2 ? this.error(new Error("Crc error - " + t2 + " - " + i3)) : this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
        }, a.prototype._handleIHDR = function(e5) {
          this.read(e5, this._parseIHDR.bind(this));
        }, a.prototype._parseIHDR = function(e5) {
          this._crc.write(e5);
          let t2 = e5.readUInt32BE(0), i3 = e5.readUInt32BE(4), n2 = e5[8], a2 = e5[9], o = e5[10], s = e5[11], l = e5[12];
          if (n2 !== 8 && n2 !== 4 && n2 !== 2 && n2 !== 1 && n2 !== 16)
            return void this.error(new Error("Unsupported bit depth " + n2));
          if (!(a2 in r.COLORTYPE_TO_BPP_MAP))
            return void this.error(new Error("Unsupported color type"));
          if (o !== 0)
            return void this.error(new Error("Unsupported compression method"));
          if (s !== 0)
            return void this.error(new Error("Unsupported filter method"));
          if (l !== 0 && l !== 1)
            return void this.error(new Error("Unsupported interlace method"));
          this._colorType = a2;
          let u = r.COLORTYPE_TO_BPP_MAP[this._colorType];
          this._hasIHDR = true, this.metadata({ width: t2, height: i3, depth: n2, interlace: Boolean(l), palette: Boolean(a2 & r.COLORTYPE_PALETTE), color: Boolean(a2 & r.COLORTYPE_COLOR), alpha: Boolean(a2 & r.COLORTYPE_ALPHA), bpp: u, colorType: a2 }), this._handleChunkEnd();
        }, a.prototype._handlePLTE = function(e5) {
          this.read(e5, this._parsePLTE.bind(this));
        }, a.prototype._parsePLTE = function(e5) {
          this._crc.write(e5);
          let t2 = Math.floor(e5.length / 3);
          for (let i3 = 0;i3 < t2; i3++)
            this._palette.push([e5[3 * i3], e5[3 * i3 + 1], e5[3 * i3 + 2], 255]);
          this.palette(this._palette), this._handleChunkEnd();
        }, a.prototype._handleTRNS = function(e5) {
          this.simpleTransparency(), this.read(e5, this._parseTRNS.bind(this));
        }, a.prototype._parseTRNS = function(e5) {
          if (this._crc.write(e5), this._colorType === r.COLORTYPE_PALETTE_COLOR) {
            if (this._palette.length === 0)
              return void this.error(new Error("Transparency chunk must be after palette"));
            if (e5.length > this._palette.length)
              return void this.error(new Error("More transparent colors than palette size"));
            for (let t2 = 0;t2 < e5.length; t2++)
              this._palette[t2][3] = e5[t2];
            this.palette(this._palette);
          }
          this._colorType === r.COLORTYPE_GRAYSCALE && this.transColor([e5.readUInt16BE(0)]), this._colorType === r.COLORTYPE_COLOR && this.transColor([e5.readUInt16BE(0), e5.readUInt16BE(2), e5.readUInt16BE(4)]), this._handleChunkEnd();
        }, a.prototype._handleGAMA = function(e5) {
          this.read(e5, this._parseGAMA.bind(this));
        }, a.prototype._parseGAMA = function(e5) {
          this._crc.write(e5), this.gamma(e5.readUInt32BE(0) / r.GAMMA_DIVISION), this._handleChunkEnd();
        }, a.prototype._handleIDAT = function(e5) {
          this._emittedHeadersFinished || (this._emittedHeadersFinished = true, this.headersFinished()), this.read(-e5, this._parseIDAT.bind(this, e5));
        }, a.prototype._parseIDAT = function(e5, t2) {
          if (this._crc.write(t2), this._colorType === r.COLORTYPE_PALETTE_COLOR && this._palette.length === 0)
            throw new Error("Expected palette not found");
          this.inflateData(t2);
          let i3 = e5 - t2.length;
          i3 > 0 ? this._handleIDAT(i3) : this._handleChunkEnd();
        }, a.prototype._handleIEND = function(e5) {
          this.read(e5, this._parseIEND.bind(this));
        }, a.prototype._parseIEND = function(e5) {
          this._crc.write(e5), this._hasIEND = true, this._handleChunkEnd(), this.finished && this.finished();
        };
      }).call(this);
    }).call(this, e4("buffer").Buffer);
  }, { "./constants": 4, "./crc": 5, buffer: 32 }], 19: [function(e4, t, i) {
    let r = e4("./parser-sync"), n = e4("./packer-sync");
    i.read = function(e5, t2) {
      return r(e5, t2 || {});
    }, i.write = function(e5, t2) {
      return n(e5, t2);
    };
  }, { "./packer-sync": 13, "./parser-sync": 17 }], 20: [function(e4, t, i) {
    (function(t2, r) {
      (function() {
        let n = e4("util"), a = e4("stream"), o = e4("./parser-async"), s = e4("./packer-async"), l = e4("./png-sync"), u = i.PNG = function(e5) {
          a.call(this), e5 = e5 || {}, this.width = 0 | e5.width, this.height = 0 | e5.height, this.data = this.width > 0 && this.height > 0 ? r.alloc(4 * this.width * this.height) : null, e5.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = true, this._parser = new o(e5), this._parser.on("error", this.emit.bind(this, "error")), this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), this._parser.on("gamma", this._gamma.bind(this)), this._parser.on("parsed", function(e6) {
            this.data = e6, this.emit("parsed", e6);
          }.bind(this)), this._packer = new s(e5), this._packer.on("data", this.emit.bind(this, "data")), this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), this._packer.on("error", this.emit.bind(this, "error"));
        };
        n.inherits(u, a), u.sync = l, u.prototype.pack = function() {
          return this.data && this.data.length ? (t2.nextTick(function() {
            this._packer.pack(this.data, this.width, this.height, this.gamma);
          }.bind(this)), this) : (this.emit("error", "No data provided"), this);
        }, u.prototype.parse = function(e5, t3) {
          if (t3) {
            let e6, i2;
            e6 = function(e7) {
              this.removeListener("error", i2), this.data = e7, t3(null, this);
            }.bind(this), i2 = function(i3) {
              this.removeListener("parsed", e6), t3(i3, null);
            }.bind(this), this.once("parsed", e6), this.once("error", i2);
          }
          return this.end(e5), this;
        }, u.prototype.write = function(e5) {
          return this._parser.write(e5), true;
        }, u.prototype.end = function(e5) {
          this._parser.end(e5);
        }, u.prototype._metadata = function(e5) {
          this.width = e5.width, this.height = e5.height, this.emit("metadata", e5);
        }, u.prototype._gamma = function(e5) {
          this.gamma = e5;
        }, u.prototype._handleClose = function() {
          this._parser.writable || this._packer.readable || this.emit("close");
        }, u.bitblt = function(e5, t3, i2, r2, n2, a2, o2, s2) {
          if (r2 |= 0, n2 |= 0, a2 |= 0, o2 |= 0, s2 |= 0, (i2 |= 0) > e5.width || r2 > e5.height || i2 + n2 > e5.width || r2 + a2 > e5.height)
            throw new Error("bitblt reading outside image");
          if (o2 > t3.width || s2 > t3.height || o2 + n2 > t3.width || s2 + a2 > t3.height)
            throw new Error("bitblt writing outside image");
          for (let l2 = 0;l2 < a2; l2++)
            e5.data.copy(t3.data, (s2 + l2) * t3.width + o2 << 2, (r2 + l2) * e5.width + i2 << 2, (r2 + l2) * e5.width + i2 + n2 << 2);
        }, u.prototype.bitblt = function(e5, t3, i2, r2, n2, a2, o2) {
          return u.bitblt(this, e5, t3, i2, r2, n2, a2, o2), this;
        }, u.adjustGamma = function(e5) {
          if (e5.gamma) {
            for (let t3 = 0;t3 < e5.height; t3++)
              for (let i2 = 0;i2 < e5.width; i2++) {
                let r2 = e5.width * t3 + i2 << 2;
                for (let t4 = 0;t4 < 3; t4++) {
                  let i3 = e5.data[r2 + t4] / 255;
                  i3 = Math.pow(i3, 1 / 2.2 / e5.gamma), e5.data[r2 + t4] = Math.round(255 * i3);
                }
              }
            e5.gamma = 0;
          }
        }, u.prototype.adjustGamma = function() {
          u.adjustGamma(this);
        };
      }).call(this);
    }).call(this, e4("_process"), e4("buffer").Buffer);
  }, { "./packer-async": 12, "./parser-async": 16, "./png-sync": 19, _process: 63, buffer: 32, stream: 65, util: 84 }], 21: [function(e4, t, i) {
    (function(r, n) {
      (function() {
        let r2 = e4("assert").ok, a = e4("zlib"), o = e4("util"), s = e4("buffer").kMaxLength;
        function l(e5) {
          if (!(this instanceof l))
            return new l(e5);
          e5 && e5.chunkSize < a.Z_MIN_CHUNK && (e5.chunkSize = a.Z_MIN_CHUNK), a.Inflate.call(this, e5), this._offset = this._offset === undefined ? this._outOffset : this._offset, this._buffer = this._buffer || this._outBuffer, e5 && e5.maxLength != null && (this._maxLength = e5.maxLength);
        }
        function u(e5) {
          return new l(e5);
        }
        function h(e5, t2) {
          e5._handle && (e5._handle.close(), e5._handle = null);
        }
        function c(e5, t2) {
          if (typeof t2 == "string" && (t2 = n.from(t2)), !(t2 instanceof n))
            throw new TypeError("Not a string or buffer");
          let i2 = e5._finishFlushFlag;
          return i2 == null && (i2 = a.Z_FINISH), e5._processChunk(t2, i2);
        }
        function f(e5, t2) {
          return c(new l(t2), e5);
        }
        l.prototype._processChunk = function(e5, t2, i2) {
          if (typeof i2 == "function")
            return a.Inflate._processChunk.call(this, e5, t2, i2);
          let o2, l2, u2 = this, c2 = e5 && e5.length, f2 = this._chunkSize - this._offset, d = this._maxLength, p = 0, m = [], _ = 0;
          function g(e6, t3) {
            if (u2._hadError)
              return;
            let i3 = f2 - t3;
            if (r2(i3 >= 0, "have should not go down"), i3 > 0) {
              let e7 = u2._buffer.slice(u2._offset, u2._offset + i3);
              if (u2._offset += i3, e7.length > d && (e7 = e7.slice(0, d)), m.push(e7), _ += e7.length, d -= e7.length, d === 0)
                return false;
            }
            return (t3 === 0 || u2._offset >= u2._chunkSize) && (f2 = u2._chunkSize, u2._offset = 0, u2._buffer = n.allocUnsafe(u2._chunkSize)), t3 === 0 && (p += c2 - e6, c2 = e6, true);
          }
          this.on("error", function(e6) {
            o2 = e6;
          }), r2(this._handle, "zlib binding closed");
          do {
            l2 = this._handle.writeSync(t2, e5, p, c2, this._buffer, this._offset, f2), l2 = l2 || this._writeState;
          } while (!this._hadError && g(l2[0], l2[1]));
          if (this._hadError)
            throw o2;
          if (_ >= s)
            throw h(this), new RangeError("Cannot create final Buffer. It would be larger than 0x" + s.toString(16) + " bytes");
          let b2 = n.concat(m, _);
          return h(this), b2;
        }, o.inherits(l, a.Inflate), t.exports = i = f, i.Inflate = l, i.createInflate = u, i.inflateSync = f;
      }).call(this);
    }).call(this, e4("_process"), e4("buffer").Buffer);
  }, { _process: 63, assert: 23, buffer: 32, util: 84, zlib: 31 }], 22: [function(e4, t, i) {
    let r = t.exports = function(e5) {
      this._buffer = e5, this._reads = [];
    };
    r.prototype.read = function(e5, t2) {
      this._reads.push({ length: Math.abs(e5), allowLess: e5 < 0, func: t2 });
    }, r.prototype.process = function() {
      for (;this._reads.length > 0 && this._buffer.length; ) {
        let e5 = this._reads[0];
        if (!this._buffer.length || !(this._buffer.length >= e5.length || e5.allowLess))
          break;
        {
          this._reads.shift();
          let t2 = this._buffer;
          this._buffer = t2.slice(e5.length), e5.func.call(this, t2.slice(0, e5.length));
        }
      }
      if (this._reads.length > 0)
        throw new Error("There are some read requests waitng on finished stream");
      if (this._buffer.length > 0)
        throw new Error("unrecognised content at end of stream");
    };
  }, {}], 23: [function(e4, t, i) {
    (function(i2) {
      (function() {
        var r = e4("object-assign");
        /*!
        	 * The buffer module from node.js, for the browser.
        	 *
        	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
        	 * @license  MIT
        	 */
        function n(e5, t2) {
          if (e5 === t2)
            return 0;
          for (var i3 = e5.length, r2 = t2.length, n2 = 0, a2 = Math.min(i3, r2);n2 < a2; ++n2)
            if (e5[n2] !== t2[n2]) {
              i3 = e5[n2], r2 = t2[n2];
              break;
            }
          return i3 < r2 ? -1 : r2 < i3 ? 1 : 0;
        }
        function a(e5) {
          return i2.Buffer && typeof i2.Buffer.isBuffer == "function" ? i2.Buffer.isBuffer(e5) : !(e5 == null || !e5._isBuffer);
        }
        var o = e4("util/"), s = Object.prototype.hasOwnProperty, l = Array.prototype.slice, u = function() {
        }.name === "foo";
        function h(e5) {
          return Object.prototype.toString.call(e5);
        }
        function c(e5) {
          return !a(e5) && typeof i2.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e5) : !!e5 && (e5 instanceof DataView || !!(e5.buffer && e5.buffer instanceof ArrayBuffer)));
        }
        var f = t.exports = y, d = /\s*function\s+([^\(\s]*)\s*/;
        function p(e5) {
          if (o.isFunction(e5)) {
            if (u)
              return e5.name;
            var t2 = e5.toString().match(d);
            return t2 && t2[1];
          }
        }
        function m(e5, t2) {
          return typeof e5 == "string" ? e5.length < t2 ? e5 : e5.slice(0, t2) : e5;
        }
        function _(e5) {
          if (u || !o.isFunction(e5))
            return o.inspect(e5);
          var t2 = p(e5);
          return "[Function" + (t2 ? ": " + t2 : "") + "]";
        }
        function g(e5) {
          return m(_(e5.actual), 128) + " " + e5.operator + " " + m(_(e5.expected), 128);
        }
        function b2(e5, t2, i3, r2, n2) {
          throw new f.AssertionError({ message: i3, actual: e5, expected: t2, operator: r2, stackStartFunction: n2 });
        }
        function y(e5, t2) {
          e5 || b2(e5, true, t2, "==", f.ok);
        }
        function w(e5, t2, i3, r2) {
          if (e5 === t2)
            return true;
          if (a(e5) && a(t2))
            return n(e5, t2) === 0;
          if (o.isDate(e5) && o.isDate(t2))
            return e5.getTime() === t2.getTime();
          if (o.isRegExp(e5) && o.isRegExp(t2))
            return e5.source === t2.source && e5.global === t2.global && e5.multiline === t2.multiline && e5.lastIndex === t2.lastIndex && e5.ignoreCase === t2.ignoreCase;
          if (e5 !== null && typeof e5 == "object" || t2 !== null && typeof t2 == "object") {
            if (c(e5) && c(t2) && h(e5) === h(t2) && !(e5 instanceof Float32Array || e5 instanceof Float64Array))
              return n(new Uint8Array(e5.buffer), new Uint8Array(t2.buffer)) === 0;
            if (a(e5) !== a(t2))
              return false;
            var s2 = (r2 = r2 || { actual: [], expected: [] }).actual.indexOf(e5);
            return s2 !== -1 && s2 === r2.expected.indexOf(t2) || (r2.actual.push(e5), r2.expected.push(t2), x(e5, t2, i3, r2));
          }
          return i3 ? e5 === t2 : e5 == t2;
        }
        function v(e5) {
          return Object.prototype.toString.call(e5) == "[object Arguments]";
        }
        function x(e5, t2, i3, r2) {
          if (e5 == null || t2 == null)
            return false;
          if (o.isPrimitive(e5) || o.isPrimitive(t2))
            return e5 === t2;
          if (i3 && Object.getPrototypeOf(e5) !== Object.getPrototypeOf(t2))
            return false;
          var n2 = v(e5), a2 = v(t2);
          if (n2 && !a2 || !n2 && a2)
            return false;
          if (n2)
            return w(e5 = l.call(e5), t2 = l.call(t2), i3);
          var s2, u2, h2 = M(e5), c2 = M(t2);
          if (h2.length !== c2.length)
            return false;
          for (h2.sort(), c2.sort(), u2 = h2.length - 1;u2 >= 0; u2--)
            if (h2[u2] !== c2[u2])
              return false;
          for (u2 = h2.length - 1;u2 >= 0; u2--)
            if (!w(e5[s2 = h2[u2]], t2[s2], i3, r2))
              return false;
          return true;
        }
        function E(e5, t2, i3) {
          w(e5, t2, true) && b2(e5, t2, i3, "notDeepStrictEqual", E);
        }
        function k(e5, t2) {
          if (!e5 || !t2)
            return false;
          if (Object.prototype.toString.call(t2) == "[object RegExp]")
            return t2.test(e5);
          try {
            if (e5 instanceof t2)
              return true;
          } catch (e6) {
          }
          return !Error.isPrototypeOf(t2) && t2.call({}, e5) === true;
        }
        function S(e5) {
          var t2;
          try {
            e5();
          } catch (e6) {
            t2 = e6;
          }
          return t2;
        }
        function A(e5, t2, i3, r2) {
          var n2;
          if (typeof t2 != "function")
            throw new TypeError('"block" argument must be a function');
          typeof i3 == "string" && (r2 = i3, i3 = null), n2 = S(t2), r2 = (i3 && i3.name ? " (" + i3.name + ")." : ".") + (r2 ? " " + r2 : "."), e5 && !n2 && b2(n2, i3, "Missing expected exception" + r2);
          var a2 = typeof r2 == "string", s2 = !e5 && n2 && !i3;
          if ((!e5 && o.isError(n2) && a2 && k(n2, i3) || s2) && b2(n2, i3, "Got unwanted exception" + r2), e5 && n2 && i3 && !k(n2, i3) || !e5 && n2)
            throw n2;
        }
        function I(e5, t2) {
          e5 || b2(e5, true, t2, "==", I);
        }
        f.AssertionError = function(e5) {
          this.name = "AssertionError", this.actual = e5.actual, this.expected = e5.expected, this.operator = e5.operator, e5.message ? (this.message = e5.message, this.generatedMessage = false) : (this.message = g(this), this.generatedMessage = true);
          var t2 = e5.stackStartFunction || b2;
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, t2);
          else {
            var i3 = new Error;
            if (i3.stack) {
              var r2 = i3.stack, n2 = p(t2), a2 = r2.indexOf("\n" + n2);
              if (a2 >= 0) {
                var o2 = r2.indexOf("\n", a2 + 1);
                r2 = r2.substring(o2 + 1);
              }
              this.stack = r2;
            }
          }
        }, o.inherits(f.AssertionError, Error), f.fail = b2, f.ok = y, f.equal = function(e5, t2, i3) {
          e5 != t2 && b2(e5, t2, i3, "==", f.equal);
        }, f.notEqual = function(e5, t2, i3) {
          e5 == t2 && b2(e5, t2, i3, "!=", f.notEqual);
        }, f.deepEqual = function(e5, t2, i3) {
          w(e5, t2, false) || b2(e5, t2, i3, "deepEqual", f.deepEqual);
        }, f.deepStrictEqual = function(e5, t2, i3) {
          w(e5, t2, true) || b2(e5, t2, i3, "deepStrictEqual", f.deepStrictEqual);
        }, f.notDeepEqual = function(e5, t2, i3) {
          w(e5, t2, false) && b2(e5, t2, i3, "notDeepEqual", f.notDeepEqual);
        }, f.notDeepStrictEqual = E, f.strictEqual = function(e5, t2, i3) {
          e5 !== t2 && b2(e5, t2, i3, "===", f.strictEqual);
        }, f.notStrictEqual = function(e5, t2, i3) {
          e5 === t2 && b2(e5, t2, i3, "!==", f.notStrictEqual);
        }, f.throws = function(e5, t2, i3) {
          A(true, e5, t2, i3);
        }, f.doesNotThrow = function(e5, t2, i3) {
          A(false, e5, t2, i3);
        }, f.ifError = function(e5) {
          if (e5)
            throw e5;
        }, f.strict = r(I, f, { equal: f.strictEqual, deepEqual: f.deepStrictEqual, notEqual: f.notStrictEqual, notDeepEqual: f.notDeepStrictEqual }), f.strict.strict = f.strict;
        var M = Object.keys || function(e5) {
          var t2 = [];
          for (var i3 in e5)
            s.call(e5, i3) && t2.push(i3);
          return t2;
        };
      }).call(this);
    }).call(this, commonjsGlobal !== undefined ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { "object-assign": 51, "util/": 26 }], 24: [function(e4, t, i) {
    typeof Object.create == "function" ? t.exports = function(e5, t2) {
      e5.super_ = t2, e5.prototype = Object.create(t2.prototype, { constructor: { value: e5, enumerable: false, writable: true, configurable: true } });
    } : t.exports = function(e5, t2) {
      e5.super_ = t2;
      var i2 = function() {
      };
      i2.prototype = t2.prototype, e5.prototype = new i2, e5.prototype.constructor = e5;
    };
  }, {}], 25: [function(e4, t, i) {
    t.exports = function(e5) {
      return e5 && typeof e5 == "object" && typeof e5.copy == "function" && typeof e5.fill == "function" && typeof e5.readUInt8 == "function";
    };
  }, {}], 26: [function(e4, t, i) {
    (function(t2, r) {
      (function() {
        var n = /%[sdj%]/g;
        i.format = function(e5) {
          if (!x(e5)) {
            for (var t3 = [], i2 = 0;i2 < arguments.length; i2++)
              t3.push(s(arguments[i2]));
            return t3.join(" ");
          }
          i2 = 1;
          for (var r2 = arguments, a2 = r2.length, o2 = String(e5).replace(n, function(e6) {
            if (e6 === "%%")
              return "%";
            if (i2 >= a2)
              return e6;
            switch (e6) {
              case "%s":
                return String(r2[i2++]);
              case "%d":
                return Number(r2[i2++]);
              case "%j":
                try {
                  return JSON.stringify(r2[i2++]);
                } catch (e7) {
                  return "[Circular]";
                }
              default:
                return e6;
            }
          }), l2 = r2[i2];i2 < a2; l2 = r2[++i2])
            y(l2) || !A(l2) ? o2 += " " + l2 : o2 += " " + s(l2);
          return o2;
        }, i.deprecate = function(e5, n2) {
          if (k(r.process))
            return function() {
              return i.deprecate(e5, n2).apply(this, arguments);
            };
          if (t2.noDeprecation === true)
            return e5;
          var a2 = false;
          function o2() {
            if (!a2) {
              if (t2.throwDeprecation)
                throw new Error(n2);
              t2.traceDeprecation ? console.trace(n2) : console.error(n2), a2 = true;
            }
            return e5.apply(this, arguments);
          }
          return o2;
        };
        var a, o = {};
        function s(e5, t3) {
          var r2 = { seen: [], stylize: u };
          return arguments.length >= 3 && (r2.depth = arguments[2]), arguments.length >= 4 && (r2.colors = arguments[3]), b2(t3) ? r2.showHidden = t3 : t3 && i._extend(r2, t3), k(r2.showHidden) && (r2.showHidden = false), k(r2.depth) && (r2.depth = 2), k(r2.colors) && (r2.colors = false), k(r2.customInspect) && (r2.customInspect = true), r2.colors && (r2.stylize = l), c(r2, e5, r2.depth);
        }
        function l(e5, t3) {
          var i2 = s.styles[t3];
          return i2 ? "[" + s.colors[i2][0] + "m" + e5 + "[" + s.colors[i2][1] + "m" : e5;
        }
        function u(e5, t3) {
          return e5;
        }
        function h(e5) {
          var t3 = {};
          return e5.forEach(function(e6, i2) {
            t3[e6] = true;
          }), t3;
        }
        function c(e5, t3, r2) {
          if (e5.customInspect && t3 && T(t3.inspect) && t3.inspect !== i.inspect && (!t3.constructor || t3.constructor.prototype !== t3)) {
            var n2 = t3.inspect(r2, e5);
            return x(n2) || (n2 = c(e5, n2, r2)), n2;
          }
          var a2 = f(e5, t3);
          if (a2)
            return a2;
          var o2 = Object.keys(t3), s2 = h(o2);
          if (e5.showHidden && (o2 = Object.getOwnPropertyNames(t3)), M(t3) && (o2.indexOf("message") >= 0 || o2.indexOf("description") >= 0))
            return d(t3);
          if (o2.length === 0) {
            if (T(t3)) {
              var l2 = t3.name ? ": " + t3.name : "";
              return e5.stylize("[Function" + l2 + "]", "special");
            }
            if (S(t3))
              return e5.stylize(RegExp.prototype.toString.call(t3), "regexp");
            if (I(t3))
              return e5.stylize(Date.prototype.toString.call(t3), "date");
            if (M(t3))
              return d(t3);
          }
          var u2, b3 = "", y2 = false, w2 = ["{", "}"];
          return g(t3) && (y2 = true, w2 = ["[", "]"]), T(t3) && (b3 = " [Function" + (t3.name ? ": " + t3.name : "") + "]"), S(t3) && (b3 = " " + RegExp.prototype.toString.call(t3)), I(t3) && (b3 = " " + Date.prototype.toUTCString.call(t3)), M(t3) && (b3 = " " + d(t3)), o2.length !== 0 || y2 && t3.length != 0 ? r2 < 0 ? S(t3) ? e5.stylize(RegExp.prototype.toString.call(t3), "regexp") : e5.stylize("[Object]", "special") : (e5.seen.push(t3), u2 = y2 ? p(e5, t3, r2, s2, o2) : o2.map(function(i2) {
            return m(e5, t3, r2, s2, i2, y2);
          }), e5.seen.pop(), _(u2, b3, w2)) : w2[0] + b3 + w2[1];
        }
        function f(e5, t3) {
          if (k(t3))
            return e5.stylize("undefined", "undefined");
          if (x(t3)) {
            var i2 = "'" + JSON.stringify(t3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return e5.stylize(i2, "string");
          }
          return v(t3) ? e5.stylize("" + t3, "number") : b2(t3) ? e5.stylize("" + t3, "boolean") : y(t3) ? e5.stylize("null", "null") : undefined;
        }
        function d(e5) {
          return "[" + Error.prototype.toString.call(e5) + "]";
        }
        function p(e5, t3, i2, r2, n2) {
          for (var a2 = [], o2 = 0, s2 = t3.length;o2 < s2; ++o2)
            F(t3, String(o2)) ? a2.push(m(e5, t3, i2, r2, String(o2), true)) : a2.push("");
          return n2.forEach(function(n3) {
            n3.match(/^\d+$/) || a2.push(m(e5, t3, i2, r2, n3, true));
          }), a2;
        }
        function m(e5, t3, i2, r2, n2, a2) {
          var o2, s2, l2;
          if ((l2 = Object.getOwnPropertyDescriptor(t3, n2) || { value: t3[n2] }).get ? s2 = l2.set ? e5.stylize("[Getter/Setter]", "special") : e5.stylize("[Getter]", "special") : l2.set && (s2 = e5.stylize("[Setter]", "special")), F(r2, n2) || (o2 = "[" + n2 + "]"), s2 || (e5.seen.indexOf(l2.value) < 0 ? (s2 = y(i2) ? c(e5, l2.value, null) : c(e5, l2.value, i2 - 1)).indexOf("\n") > -1 && (s2 = a2 ? s2.split("\n").map(function(e6) {
            return "  " + e6;
          }).join("\n").substr(2) : "\n" + s2.split("\n").map(function(e6) {
            return "   " + e6;
          }).join("\n")) : s2 = e5.stylize("[Circular]", "special")), k(o2)) {
            if (a2 && n2.match(/^\d+$/))
              return s2;
            (o2 = JSON.stringify("" + n2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o2 = o2.substr(1, o2.length - 2), o2 = e5.stylize(o2, "name")) : (o2 = o2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o2 = e5.stylize(o2, "string"));
          }
          return o2 + ": " + s2;
        }
        function _(e5, t3, i2) {
          return e5.reduce(function(e6, t4) {
            return t4.indexOf("\n"), e6 + t4.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0) > 60 ? i2[0] + (t3 === "" ? "" : t3 + "\n ") + " " + e5.join(",\n  ") + " " + i2[1] : i2[0] + t3 + " " + e5.join(", ") + " " + i2[1];
        }
        function g(e5) {
          return Array.isArray(e5);
        }
        function b2(e5) {
          return typeof e5 == "boolean";
        }
        function y(e5) {
          return e5 === null;
        }
        function w(e5) {
          return e5 == null;
        }
        function v(e5) {
          return typeof e5 == "number";
        }
        function x(e5) {
          return typeof e5 == "string";
        }
        function E(e5) {
          return typeof e5 == "symbol";
        }
        function k(e5) {
          return e5 === undefined;
        }
        function S(e5) {
          return A(e5) && B(e5) === "[object RegExp]";
        }
        function A(e5) {
          return typeof e5 == "object" && e5 !== null;
        }
        function I(e5) {
          return A(e5) && B(e5) === "[object Date]";
        }
        function M(e5) {
          return A(e5) && (B(e5) === "[object Error]" || e5 instanceof Error);
        }
        function T(e5) {
          return typeof e5 == "function";
        }
        function P(e5) {
          return e5 === null || typeof e5 == "boolean" || typeof e5 == "number" || typeof e5 == "string" || typeof e5 == "symbol" || e5 === undefined;
        }
        function B(e5) {
          return Object.prototype.toString.call(e5);
        }
        function C(e5) {
          return e5 < 10 ? "0" + e5.toString(10) : e5.toString(10);
        }
        i.debuglog = function(e5) {
          if (k(a) && (a = t2.env.NODE_DEBUG || ""), e5 = e5.toUpperCase(), !o[e5])
            if (new RegExp("\\b" + e5 + "\\b", "i").test(a)) {
              var r2 = t2.pid;
              o[e5] = function() {
                var t3 = i.format.apply(i, arguments);
                console.error("%s %d: %s", e5, r2, t3);
              };
            } else
              o[e5] = function() {
              };
          return o[e5];
        }, i.inspect = s, s.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, s.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i.isArray = g, i.isBoolean = b2, i.isNull = y, i.isNullOrUndefined = w, i.isNumber = v, i.isString = x, i.isSymbol = E, i.isUndefined = k, i.isRegExp = S, i.isObject = A, i.isDate = I, i.isError = M, i.isFunction = T, i.isPrimitive = P, i.isBuffer = e4("./support/isBuffer");
        var R = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        function z() {
          var e5 = new Date, t3 = [C(e5.getHours()), C(e5.getMinutes()), C(e5.getSeconds())].join(":");
          return [e5.getDate(), R[e5.getMonth()], t3].join(" ");
        }
        function F(e5, t3) {
          return Object.prototype.hasOwnProperty.call(e5, t3);
        }
        i.log = function() {
          console.log("%s - %s", z(), i.format.apply(i, arguments));
        }, i.inherits = e4("inherits"), i._extend = function(e5, t3) {
          if (!t3 || !A(t3))
            return e5;
          for (var i2 = Object.keys(t3), r2 = i2.length;r2--; )
            e5[i2[r2]] = t3[i2[r2]];
          return e5;
        };
      }).call(this);
    }).call(this, e4("_process"), commonjsGlobal !== undefined ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { "./support/isBuffer": 25, _process: 63, inherits: 24 }], 27: [function(e4, t, i) {
    (function(e5) {
      (function() {
        var i2 = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], r = typeof globalThis == "undefined" ? e5 : globalThis;
        t.exports = function() {
          for (var e6 = [], t2 = 0;t2 < i2.length; t2++)
            typeof r[i2[t2]] == "function" && (e6[e6.length] = i2[t2]);
          return e6;
        };
      }).call(this);
    }).call(this, commonjsGlobal !== undefined ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, {}], 28: [function(e4, t, i) {
    i.byteLength = h, i.toByteArray = f, i.fromByteArray = m;
    for (var r = [], n = [], a = typeof Uint8Array != "undefined" ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, l = o.length;s < l; ++s)
      r[s] = o[s], n[o.charCodeAt(s)] = s;
    function u(e5) {
      var t2 = e5.length;
      if (t2 % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var i2 = e5.indexOf("=");
      return i2 === -1 && (i2 = t2), [i2, i2 === t2 ? 0 : 4 - i2 % 4];
    }
    function h(e5) {
      var t2 = u(e5), i2 = t2[0], r2 = t2[1];
      return 3 * (i2 + r2) / 4 - r2;
    }
    function c(e5, t2, i2) {
      return 3 * (t2 + i2) / 4 - i2;
    }
    function f(e5) {
      var t2, i2, r2 = u(e5), o2 = r2[0], s2 = r2[1], l2 = new a(c(e5, o2, s2)), h2 = 0, f2 = s2 > 0 ? o2 - 4 : o2;
      for (i2 = 0;i2 < f2; i2 += 4)
        t2 = n[e5.charCodeAt(i2)] << 18 | n[e5.charCodeAt(i2 + 1)] << 12 | n[e5.charCodeAt(i2 + 2)] << 6 | n[e5.charCodeAt(i2 + 3)], l2[h2++] = t2 >> 16 & 255, l2[h2++] = t2 >> 8 & 255, l2[h2++] = 255 & t2;
      return s2 === 2 && (t2 = n[e5.charCodeAt(i2)] << 2 | n[e5.charCodeAt(i2 + 1)] >> 4, l2[h2++] = 255 & t2), s2 === 1 && (t2 = n[e5.charCodeAt(i2)] << 10 | n[e5.charCodeAt(i2 + 1)] << 4 | n[e5.charCodeAt(i2 + 2)] >> 2, l2[h2++] = t2 >> 8 & 255, l2[h2++] = 255 & t2), l2;
    }
    function d(e5) {
      return r[e5 >> 18 & 63] + r[e5 >> 12 & 63] + r[e5 >> 6 & 63] + r[63 & e5];
    }
    function p(e5, t2, i2) {
      for (var r2, n2 = [], a2 = t2;a2 < i2; a2 += 3)
        r2 = (e5[a2] << 16 & 16711680) + (e5[a2 + 1] << 8 & 65280) + (255 & e5[a2 + 2]), n2.push(d(r2));
      return n2.join("");
    }
    function m(e5) {
      for (var t2, i2 = e5.length, n2 = i2 % 3, a2 = [], o2 = 16383, s2 = 0, l2 = i2 - n2;s2 < l2; s2 += o2)
        a2.push(p(e5, s2, s2 + o2 > l2 ? l2 : s2 + o2));
      return n2 === 1 ? (t2 = e5[i2 - 1], a2.push(r[t2 >> 2] + r[t2 << 4 & 63] + "==")) : n2 === 2 && (t2 = (e5[i2 - 2] << 8) + e5[i2 - 1], a2.push(r[t2 >> 10] + r[t2 >> 4 & 63] + r[t2 << 2 & 63] + "=")), a2.join("");
    }
    n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63;
  }, {}], 29: [function(e4, t, i) {
  }, {}], 30: [function(e4, t, i) {
    (function(t2, r) {
      (function() {
        var n = e4("assert"), a = e4("pako/lib/zlib/zstream"), o = e4("pako/lib/zlib/deflate.js"), s = e4("pako/lib/zlib/inflate.js"), l = e4("pako/lib/zlib/constants");
        for (var u in l)
          i[u] = l[u];
        i.NONE = 0, i.DEFLATE = 1, i.INFLATE = 2, i.GZIP = 3, i.GUNZIP = 4, i.DEFLATERAW = 5, i.INFLATERAW = 6, i.UNZIP = 7;
        var h = 31, c = 139;
        function f(e5) {
          if (typeof e5 != "number" || e5 < i.DEFLATE || e5 > i.UNZIP)
            throw new TypeError("Bad argument");
          this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = false, this.level = 0, this.memLevel = 0, this.mode = e5, this.strategy = 0, this.windowBits = 0, this.write_in_progress = false, this.pending_close = false, this.gzip_id_bytes_read = 0;
        }
        f.prototype.close = function() {
          this.write_in_progress ? this.pending_close = true : (this.pending_close = false, n(this.init_done, "close before init"), n(this.mode <= i.UNZIP), this.mode === i.DEFLATE || this.mode === i.GZIP || this.mode === i.DEFLATERAW ? o.deflateEnd(this.strm) : this.mode !== i.INFLATE && this.mode !== i.GUNZIP && this.mode !== i.INFLATERAW && this.mode !== i.UNZIP || s.inflateEnd(this.strm), this.mode = i.NONE, this.dictionary = null);
        }, f.prototype.write = function(e5, t3, i2, r2, n2, a2, o2) {
          return this._write(true, e5, t3, i2, r2, n2, a2, o2);
        }, f.prototype.writeSync = function(e5, t3, i2, r2, n2, a2, o2) {
          return this._write(false, e5, t3, i2, r2, n2, a2, o2);
        }, f.prototype._write = function(e5, a2, o2, s2, l2, u2, h2, c2) {
          if (n.equal(arguments.length, 8), n(this.init_done, "write before init"), n(this.mode !== i.NONE, "already finalized"), n.equal(false, this.write_in_progress, "write already in progress"), n.equal(false, this.pending_close, "close is pending"), this.write_in_progress = true, n.equal(false, a2 === undefined, "must provide flush value"), this.write_in_progress = true, a2 !== i.Z_NO_FLUSH && a2 !== i.Z_PARTIAL_FLUSH && a2 !== i.Z_SYNC_FLUSH && a2 !== i.Z_FULL_FLUSH && a2 !== i.Z_FINISH && a2 !== i.Z_BLOCK)
            throw new Error("Invalid flush value");
          if (o2 == null && (o2 = r.alloc(0), l2 = 0, s2 = 0), this.strm.avail_in = l2, this.strm.input = o2, this.strm.next_in = s2, this.strm.avail_out = c2, this.strm.output = u2, this.strm.next_out = h2, this.flush = a2, !e5)
            return this._process(), this._checkError() ? this._afterSync() : undefined;
          var f2 = this;
          return t2.nextTick(function() {
            f2._process(), f2._after();
          }), this;
        }, f.prototype._afterSync = function() {
          var e5 = this.strm.avail_out, t3 = this.strm.avail_in;
          return this.write_in_progress = false, [t3, e5];
        }, f.prototype._process = function() {
          var e5 = null;
          switch (this.mode) {
            case i.DEFLATE:
            case i.GZIP:
            case i.DEFLATERAW:
              this.err = o.deflate(this.strm, this.flush);
              break;
            case i.UNZIP:
              switch (this.strm.avail_in > 0 && (e5 = this.strm.next_in), this.gzip_id_bytes_read) {
                case 0:
                  if (e5 === null)
                    break;
                  if (this.strm.input[e5] !== h) {
                    this.mode = i.INFLATE;
                    break;
                  }
                  if (this.gzip_id_bytes_read = 1, e5++, this.strm.avail_in === 1)
                    break;
                case 1:
                  if (e5 === null)
                    break;
                  this.strm.input[e5] === c ? (this.gzip_id_bytes_read = 2, this.mode = i.GUNZIP) : this.mode = i.INFLATE;
                  break;
                default:
                  throw new Error("invalid number of gzip magic number bytes read");
              }
            case i.INFLATE:
            case i.GUNZIP:
            case i.INFLATERAW:
              for (this.err = s.inflate(this.strm, this.flush), this.err === i.Z_NEED_DICT && this.dictionary && (this.err = s.inflateSetDictionary(this.strm, this.dictionary), this.err === i.Z_OK ? this.err = s.inflate(this.strm, this.flush) : this.err === i.Z_DATA_ERROR && (this.err = i.Z_NEED_DICT));this.strm.avail_in > 0 && this.mode === i.GUNZIP && this.err === i.Z_STREAM_END && this.strm.next_in[0] !== 0; )
                this.reset(), this.err = s.inflate(this.strm, this.flush);
              break;
            default:
              throw new Error("Unknown mode " + this.mode);
          }
        }, f.prototype._checkError = function() {
          switch (this.err) {
            case i.Z_OK:
            case i.Z_BUF_ERROR:
              if (this.strm.avail_out !== 0 && this.flush === i.Z_FINISH)
                return this._error("unexpected end of file"), false;
              break;
            case i.Z_STREAM_END:
              break;
            case i.Z_NEED_DICT:
              return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), false;
            default:
              return this._error("Zlib error"), false;
          }
          return true;
        }, f.prototype._after = function() {
          if (this._checkError()) {
            var e5 = this.strm.avail_out, t3 = this.strm.avail_in;
            this.write_in_progress = false, this.callback(t3, e5), this.pending_close && this.close();
          }
        }, f.prototype._error = function(e5) {
          this.strm.msg && (e5 = this.strm.msg), this.onerror(e5, this.err), this.write_in_progress = false, this.pending_close && this.close();
        }, f.prototype.init = function(e5, t3, r2, a2, o2) {
          n(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), n(e5 >= 8 && e5 <= 15, "invalid windowBits"), n(t3 >= -1 && t3 <= 9, "invalid compression level"), n(r2 >= 1 && r2 <= 9, "invalid memlevel"), n(a2 === i.Z_FILTERED || a2 === i.Z_HUFFMAN_ONLY || a2 === i.Z_RLE || a2 === i.Z_FIXED || a2 === i.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(t3, e5, r2, a2, o2), this._setDictionary();
        }, f.prototype.params = function() {
          throw new Error("deflateParams Not supported");
        }, f.prototype.reset = function() {
          this._reset(), this._setDictionary();
        }, f.prototype._init = function(e5, t3, r2, n2, l2) {
          switch (this.level = e5, this.windowBits = t3, this.memLevel = r2, this.strategy = n2, this.flush = i.Z_NO_FLUSH, this.err = i.Z_OK, this.mode !== i.GZIP && this.mode !== i.GUNZIP || (this.windowBits += 16), this.mode === i.UNZIP && (this.windowBits += 32), this.mode !== i.DEFLATERAW && this.mode !== i.INFLATERAW || (this.windowBits = -1 * this.windowBits), this.strm = new a, this.mode) {
            case i.DEFLATE:
            case i.GZIP:
            case i.DEFLATERAW:
              this.err = o.deflateInit2(this.strm, this.level, i.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
              break;
            case i.INFLATE:
            case i.GUNZIP:
            case i.INFLATERAW:
            case i.UNZIP:
              this.err = s.inflateInit2(this.strm, this.windowBits);
              break;
            default:
              throw new Error("Unknown mode " + this.mode);
          }
          this.err !== i.Z_OK && this._error("Init error"), this.dictionary = l2, this.write_in_progress = false, this.init_done = true;
        }, f.prototype._setDictionary = function() {
          if (this.dictionary != null) {
            switch (this.err = i.Z_OK, this.mode) {
              case i.DEFLATE:
              case i.DEFLATERAW:
                this.err = o.deflateSetDictionary(this.strm, this.dictionary);
            }
            this.err !== i.Z_OK && this._error("Failed to set dictionary");
          }
        }, f.prototype._reset = function() {
          switch (this.err = i.Z_OK, this.mode) {
            case i.DEFLATE:
            case i.DEFLATERAW:
            case i.GZIP:
              this.err = o.deflateReset(this.strm);
              break;
            case i.INFLATE:
            case i.INFLATERAW:
            case i.GUNZIP:
              this.err = s.inflateReset(this.strm);
          }
          this.err !== i.Z_OK && this._error("Failed to reset stream");
        }, i.Zlib = f;
      }).call(this);
    }).call(this, e4("_process"), e4("buffer").Buffer);
  }, { _process: 63, assert: 23, buffer: 32, "pako/lib/zlib/constants": 54, "pako/lib/zlib/deflate.js": 56, "pako/lib/zlib/inflate.js": 58, "pako/lib/zlib/zstream": 62 }], 31: [function(e4, t, i) {
    (function(t2) {
      (function() {
        var r = e4("buffer").Buffer, n = e4("stream").Transform, a = e4("./binding"), o = e4("util"), s = e4("assert").ok, l = e4("buffer").kMaxLength, u = "Cannot create final Buffer. It would be larger than 0x" + l.toString(16) + " bytes";
        a.Z_MIN_WINDOWBITS = 8, a.Z_MAX_WINDOWBITS = 15, a.Z_DEFAULT_WINDOWBITS = 15, a.Z_MIN_CHUNK = 64, a.Z_MAX_CHUNK = 1 / 0, a.Z_DEFAULT_CHUNK = 16384, a.Z_MIN_MEMLEVEL = 1, a.Z_MAX_MEMLEVEL = 9, a.Z_DEFAULT_MEMLEVEL = 8, a.Z_MIN_LEVEL = -1, a.Z_MAX_LEVEL = 9, a.Z_DEFAULT_LEVEL = a.Z_DEFAULT_COMPRESSION;
        for (var h = Object.keys(a), c = 0;c < h.length; c++) {
          var f = h[c];
          f.match(/^Z/) && Object.defineProperty(i, f, { enumerable: true, value: a[f], writable: false });
        }
        for (var d = { Z_OK: a.Z_OK, Z_STREAM_END: a.Z_STREAM_END, Z_NEED_DICT: a.Z_NEED_DICT, Z_ERRNO: a.Z_ERRNO, Z_STREAM_ERROR: a.Z_STREAM_ERROR, Z_DATA_ERROR: a.Z_DATA_ERROR, Z_MEM_ERROR: a.Z_MEM_ERROR, Z_BUF_ERROR: a.Z_BUF_ERROR, Z_VERSION_ERROR: a.Z_VERSION_ERROR }, p = Object.keys(d), m = 0;m < p.length; m++) {
          var _ = p[m];
          d[d[_]] = _;
        }
        function g(e5, t3, i2) {
          var n2 = [], a2 = 0;
          function o2() {
            for (var t4;(t4 = e5.read()) !== null; )
              n2.push(t4), a2 += t4.length;
            e5.once("readable", o2);
          }
          function s2(t4) {
            e5.removeListener("end", h2), e5.removeListener("readable", o2), i2(t4);
          }
          function h2() {
            var t4, o3 = null;
            a2 >= l ? o3 = new RangeError(u) : t4 = r.concat(n2, a2), n2 = [], e5.close(), i2(o3, t4);
          }
          e5.on("error", s2), e5.on("end", h2), e5.end(t3), o2();
        }
        function b2(e5, t3) {
          if (typeof t3 == "string" && (t3 = r.from(t3)), !r.isBuffer(t3))
            throw new TypeError("Not a string or buffer");
          var i2 = e5._finishFlushFlag;
          return e5._processChunk(t3, i2);
        }
        function y(e5) {
          if (!(this instanceof y))
            return new y(e5);
          I.call(this, e5, a.DEFLATE);
        }
        function w(e5) {
          if (!(this instanceof w))
            return new w(e5);
          I.call(this, e5, a.INFLATE);
        }
        function v(e5) {
          if (!(this instanceof v))
            return new v(e5);
          I.call(this, e5, a.GZIP);
        }
        function x(e5) {
          if (!(this instanceof x))
            return new x(e5);
          I.call(this, e5, a.GUNZIP);
        }
        function E(e5) {
          if (!(this instanceof E))
            return new E(e5);
          I.call(this, e5, a.DEFLATERAW);
        }
        function k(e5) {
          if (!(this instanceof k))
            return new k(e5);
          I.call(this, e5, a.INFLATERAW);
        }
        function S(e5) {
          if (!(this instanceof S))
            return new S(e5);
          I.call(this, e5, a.UNZIP);
        }
        function A(e5) {
          return e5 === a.Z_NO_FLUSH || e5 === a.Z_PARTIAL_FLUSH || e5 === a.Z_SYNC_FLUSH || e5 === a.Z_FULL_FLUSH || e5 === a.Z_FINISH || e5 === a.Z_BLOCK;
        }
        function I(e5, t3) {
          var o2 = this;
          if (this._opts = e5 = e5 || {}, this._chunkSize = e5.chunkSize || i.Z_DEFAULT_CHUNK, n.call(this, e5), e5.flush && !A(e5.flush))
            throw new Error("Invalid flush flag: " + e5.flush);
          if (e5.finishFlush && !A(e5.finishFlush))
            throw new Error("Invalid flush flag: " + e5.finishFlush);
          if (this._flushFlag = e5.flush || a.Z_NO_FLUSH, this._finishFlushFlag = e5.finishFlush !== undefined ? e5.finishFlush : a.Z_FINISH, e5.chunkSize && (e5.chunkSize < i.Z_MIN_CHUNK || e5.chunkSize > i.Z_MAX_CHUNK))
            throw new Error("Invalid chunk size: " + e5.chunkSize);
          if (e5.windowBits && (e5.windowBits < i.Z_MIN_WINDOWBITS || e5.windowBits > i.Z_MAX_WINDOWBITS))
            throw new Error("Invalid windowBits: " + e5.windowBits);
          if (e5.level && (e5.level < i.Z_MIN_LEVEL || e5.level > i.Z_MAX_LEVEL))
            throw new Error("Invalid compression level: " + e5.level);
          if (e5.memLevel && (e5.memLevel < i.Z_MIN_MEMLEVEL || e5.memLevel > i.Z_MAX_MEMLEVEL))
            throw new Error("Invalid memLevel: " + e5.memLevel);
          if (e5.strategy && e5.strategy != i.Z_FILTERED && e5.strategy != i.Z_HUFFMAN_ONLY && e5.strategy != i.Z_RLE && e5.strategy != i.Z_FIXED && e5.strategy != i.Z_DEFAULT_STRATEGY)
            throw new Error("Invalid strategy: " + e5.strategy);
          if (e5.dictionary && !r.isBuffer(e5.dictionary))
            throw new Error("Invalid dictionary: it should be a Buffer instance");
          this._handle = new a.Zlib(t3);
          var s2 = this;
          this._hadError = false, this._handle.onerror = function(e6, t4) {
            M(s2), s2._hadError = true;
            var r2 = new Error(e6);
            r2.errno = t4, r2.code = i.codes[t4], s2.emit("error", r2);
          };
          var l2 = i.Z_DEFAULT_COMPRESSION;
          typeof e5.level == "number" && (l2 = e5.level);
          var u2 = i.Z_DEFAULT_STRATEGY;
          typeof e5.strategy == "number" && (u2 = e5.strategy), this._handle.init(e5.windowBits || i.Z_DEFAULT_WINDOWBITS, l2, e5.memLevel || i.Z_DEFAULT_MEMLEVEL, u2, e5.dictionary), this._buffer = r.allocUnsafe(this._chunkSize), this._offset = 0, this._level = l2, this._strategy = u2, this.once("end", this.close), Object.defineProperty(this, "_closed", { get: function() {
            return !o2._handle;
          }, configurable: true, enumerable: true });
        }
        function M(e5, i2) {
          i2 && t2.nextTick(i2), e5._handle && (e5._handle.close(), e5._handle = null);
        }
        function T(e5) {
          e5.emit("close");
        }
        Object.defineProperty(i, "codes", { enumerable: true, value: Object.freeze(d), writable: false }), i.Deflate = y, i.Inflate = w, i.Gzip = v, i.Gunzip = x, i.DeflateRaw = E, i.InflateRaw = k, i.Unzip = S, i.createDeflate = function(e5) {
          return new y(e5);
        }, i.createInflate = function(e5) {
          return new w(e5);
        }, i.createDeflateRaw = function(e5) {
          return new E(e5);
        }, i.createInflateRaw = function(e5) {
          return new k(e5);
        }, i.createGzip = function(e5) {
          return new v(e5);
        }, i.createGunzip = function(e5) {
          return new x(e5);
        }, i.createUnzip = function(e5) {
          return new S(e5);
        }, i.deflate = function(e5, t3, i2) {
          return typeof t3 == "function" && (i2 = t3, t3 = {}), g(new y(t3), e5, i2);
        }, i.deflateSync = function(e5, t3) {
          return b2(new y(t3), e5);
        }, i.gzip = function(e5, t3, i2) {
          return typeof t3 == "function" && (i2 = t3, t3 = {}), g(new v(t3), e5, i2);
        }, i.gzipSync = function(e5, t3) {
          return b2(new v(t3), e5);
        }, i.deflateRaw = function(e5, t3, i2) {
          return typeof t3 == "function" && (i2 = t3, t3 = {}), g(new E(t3), e5, i2);
        }, i.deflateRawSync = function(e5, t3) {
          return b2(new E(t3), e5);
        }, i.unzip = function(e5, t3, i2) {
          return typeof t3 == "function" && (i2 = t3, t3 = {}), g(new S(t3), e5, i2);
        }, i.unzipSync = function(e5, t3) {
          return b2(new S(t3), e5);
        }, i.inflate = function(e5, t3, i2) {
          return typeof t3 == "function" && (i2 = t3, t3 = {}), g(new w(t3), e5, i2);
        }, i.inflateSync = function(e5, t3) {
          return b2(new w(t3), e5);
        }, i.gunzip = function(e5, t3, i2) {
          return typeof t3 == "function" && (i2 = t3, t3 = {}), g(new x(t3), e5, i2);
        }, i.gunzipSync = function(e5, t3) {
          return b2(new x(t3), e5);
        }, i.inflateRaw = function(e5, t3, i2) {
          return typeof t3 == "function" && (i2 = t3, t3 = {}), g(new k(t3), e5, i2);
        }, i.inflateRawSync = function(e5, t3) {
          return b2(new k(t3), e5);
        }, o.inherits(I, n), I.prototype.params = function(e5, r2, n2) {
          if (e5 < i.Z_MIN_LEVEL || e5 > i.Z_MAX_LEVEL)
            throw new RangeError("Invalid compression level: " + e5);
          if (r2 != i.Z_FILTERED && r2 != i.Z_HUFFMAN_ONLY && r2 != i.Z_RLE && r2 != i.Z_FIXED && r2 != i.Z_DEFAULT_STRATEGY)
            throw new TypeError("Invalid strategy: " + r2);
          if (this._level !== e5 || this._strategy !== r2) {
            var o2 = this;
            this.flush(a.Z_SYNC_FLUSH, function() {
              s(o2._handle, "zlib binding closed"), o2._handle.params(e5, r2), o2._hadError || (o2._level = e5, o2._strategy = r2, n2 && n2());
            });
          } else
            t2.nextTick(n2);
        }, I.prototype.reset = function() {
          return s(this._handle, "zlib binding closed"), this._handle.reset();
        }, I.prototype._flush = function(e5) {
          this._transform(r.alloc(0), "", e5);
        }, I.prototype.flush = function(e5, i2) {
          var n2 = this, o2 = this._writableState;
          (typeof e5 == "function" || e5 === undefined && !i2) && (i2 = e5, e5 = a.Z_FULL_FLUSH), o2.ended ? i2 && t2.nextTick(i2) : o2.ending ? i2 && this.once("end", i2) : o2.needDrain ? i2 && this.once("drain", function() {
            return n2.flush(e5, i2);
          }) : (this._flushFlag = e5, this.write(r.alloc(0), "", i2));
        }, I.prototype.close = function(e5) {
          M(this, e5), t2.nextTick(T, this);
        }, I.prototype._transform = function(e5, t3, i2) {
          var n2, o2 = this._writableState, s2 = (o2.ending || o2.ended) && (!e5 || o2.length === e5.length);
          return e5 === null || r.isBuffer(e5) ? this._handle ? (s2 ? n2 = this._finishFlushFlag : (n2 = this._flushFlag, e5.length >= o2.length && (this._flushFlag = this._opts.flush || a.Z_NO_FLUSH)), void this._processChunk(e5, n2, i2)) : i2(new Error("zlib binding closed")) : i2(new Error("invalid input"));
        }, I.prototype._processChunk = function(e5, t3, i2) {
          var n2 = e5 && e5.length, a2 = this._chunkSize - this._offset, o2 = 0, h2 = this, c2 = typeof i2 == "function";
          if (!c2) {
            var f2, d2 = [], p2 = 0;
            this.on("error", function(e6) {
              f2 = e6;
            }), s(this._handle, "zlib binding closed");
            do {
              var m2 = this._handle.writeSync(t3, e5, o2, n2, this._buffer, this._offset, a2);
            } while (!this._hadError && b3(m2[0], m2[1]));
            if (this._hadError)
              throw f2;
            if (p2 >= l)
              throw M(this), new RangeError(u);
            var _2 = r.concat(d2, p2);
            return M(this), _2;
          }
          s(this._handle, "zlib binding closed");
          var g2 = this._handle.write(t3, e5, o2, n2, this._buffer, this._offset, a2);
          function b3(l2, u2) {
            if (this && (this.buffer = null, this.callback = null), !h2._hadError) {
              var f3 = a2 - u2;
              if (s(f3 >= 0, "have should not go down"), f3 > 0) {
                var m3 = h2._buffer.slice(h2._offset, h2._offset + f3);
                h2._offset += f3, c2 ? h2.push(m3) : (d2.push(m3), p2 += m3.length);
              }
              if ((u2 === 0 || h2._offset >= h2._chunkSize) && (a2 = h2._chunkSize, h2._offset = 0, h2._buffer = r.allocUnsafe(h2._chunkSize)), u2 === 0) {
                if (o2 += n2 - l2, n2 = l2, !c2)
                  return true;
                var _3 = h2._handle.write(t3, e5, o2, n2, h2._buffer, h2._offset, h2._chunkSize);
                return _3.callback = b3, void (_3.buffer = e5);
              }
              if (!c2)
                return false;
              i2();
            }
          }
          g2.buffer = e5, g2.callback = b3;
        }, o.inherits(y, I), o.inherits(w, I), o.inherits(v, I), o.inherits(x, I), o.inherits(E, I), o.inherits(k, I), o.inherits(S, I);
      }).call(this);
    }).call(this, e4("_process"));
  }, { "./binding": 30, _process: 63, assert: 23, buffer: 32, stream: 65, util: 84 }], 32: [function(e4, t, i) {
    (function(t2) {
      (function() {
        var t3 = e4("base64-js"), r = e4("ieee754");
        i.Buffer = s, i.SlowBuffer = g, i.INSPECT_MAX_BYTES = 50;
        var n = 2147483647;
        function a() {
          try {
            var e5 = new Uint8Array(1);
            return e5.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
              return 42;
            } }, e5.foo() === 42;
          } catch (e6) {
            return false;
          }
        }
        function o(e5) {
          if (e5 > n)
            throw new RangeError('The value "' + e5 + '" is invalid for option "size"');
          var t4 = new Uint8Array(e5);
          return t4.__proto__ = s.prototype, t4;
        }
        function s(e5, t4, i2) {
          if (typeof e5 == "number") {
            if (typeof t4 == "string")
              throw new TypeError('The "string" argument must be of type string. Received type number');
            return c(e5);
          }
          return l(e5, t4, i2);
        }
        function l(e5, t4, i2) {
          if (typeof e5 == "string")
            return f(e5, t4);
          if (ArrayBuffer.isView(e5))
            return d(e5);
          if (e5 == null)
            throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e5);
          if (Y(e5, ArrayBuffer) || e5 && Y(e5.buffer, ArrayBuffer))
            return p(e5, t4, i2);
          if (typeof e5 == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
          var r2 = e5.valueOf && e5.valueOf();
          if (r2 != null && r2 !== e5)
            return s.from(r2, t4, i2);
          var n2 = m(e5);
          if (n2)
            return n2;
          if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof e5[Symbol.toPrimitive] == "function")
            return s.from(e5[Symbol.toPrimitive]("string"), t4, i2);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e5);
        }
        function u(e5) {
          if (typeof e5 != "number")
            throw new TypeError('"size" argument must be of type number');
          if (e5 < 0)
            throw new RangeError('The value "' + e5 + '" is invalid for option "size"');
        }
        function h(e5, t4, i2) {
          return u(e5), e5 <= 0 ? o(e5) : t4 !== undefined ? typeof i2 == "string" ? o(e5).fill(t4, i2) : o(e5).fill(t4) : o(e5);
        }
        function c(e5) {
          return u(e5), o(e5 < 0 ? 0 : 0 | _(e5));
        }
        function f(e5, t4) {
          if (typeof t4 == "string" && t4 !== "" || (t4 = "utf8"), !s.isEncoding(t4))
            throw new TypeError("Unknown encoding: " + t4);
          var i2 = 0 | b2(e5, t4), r2 = o(i2), n2 = r2.write(e5, t4);
          return n2 !== i2 && (r2 = r2.slice(0, n2)), r2;
        }
        function d(e5) {
          for (var t4 = e5.length < 0 ? 0 : 0 | _(e5.length), i2 = o(t4), r2 = 0;r2 < t4; r2 += 1)
            i2[r2] = 255 & e5[r2];
          return i2;
        }
        function p(e5, t4, i2) {
          if (t4 < 0 || e5.byteLength < t4)
            throw new RangeError('"offset" is outside of buffer bounds');
          if (e5.byteLength < t4 + (i2 || 0))
            throw new RangeError('"length" is outside of buffer bounds');
          var r2;
          return (r2 = t4 === undefined && i2 === undefined ? new Uint8Array(e5) : i2 === undefined ? new Uint8Array(e5, t4) : new Uint8Array(e5, t4, i2)).__proto__ = s.prototype, r2;
        }
        function m(e5) {
          if (s.isBuffer(e5)) {
            var t4 = 0 | _(e5.length), i2 = o(t4);
            return i2.length === 0 || e5.copy(i2, 0, 0, t4), i2;
          }
          return e5.length !== undefined ? typeof e5.length != "number" || K(e5.length) ? o(0) : d(e5) : e5.type === "Buffer" && Array.isArray(e5.data) ? d(e5.data) : undefined;
        }
        function _(e5) {
          if (e5 >= n)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n.toString(16) + " bytes");
          return 0 | e5;
        }
        function g(e5) {
          return +e5 != e5 && (e5 = 0), s.alloc(+e5);
        }
        function b2(e5, t4) {
          if (s.isBuffer(e5))
            return e5.length;
          if (ArrayBuffer.isView(e5) || Y(e5, ArrayBuffer))
            return e5.byteLength;
          if (typeof e5 != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e5);
          var i2 = e5.length, r2 = arguments.length > 2 && arguments[2] === true;
          if (!r2 && i2 === 0)
            return 0;
          for (var n2 = false;; )
            switch (t4) {
              case "ascii":
              case "latin1":
              case "binary":
                return i2;
              case "utf8":
              case "utf-8":
                return H(e5).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * i2;
              case "hex":
                return i2 >>> 1;
              case "base64":
                return q(e5).length;
              default:
                if (n2)
                  return r2 ? -1 : H(e5).length;
                t4 = ("" + t4).toLowerCase(), n2 = true;
            }
        }
        function y(e5, t4, i2) {
          var r2 = false;
          if ((t4 === undefined || t4 < 0) && (t4 = 0), t4 > this.length)
            return "";
          if ((i2 === undefined || i2 > this.length) && (i2 = this.length), i2 <= 0)
            return "";
          if ((i2 >>>= 0) <= (t4 >>>= 0))
            return "";
          for (e5 || (e5 = "utf8");; )
            switch (e5) {
              case "hex":
                return F(this, t4, i2);
              case "utf8":
              case "utf-8":
                return P(this, t4, i2);
              case "ascii":
                return R(this, t4, i2);
              case "latin1":
              case "binary":
                return z(this, t4, i2);
              case "base64":
                return T(this, t4, i2);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return N(this, t4, i2);
              default:
                if (r2)
                  throw new TypeError("Unknown encoding: " + e5);
                e5 = (e5 + "").toLowerCase(), r2 = true;
            }
        }
        function w(e5, t4, i2) {
          var r2 = e5[t4];
          e5[t4] = e5[i2], e5[i2] = r2;
        }
        function v(e5, t4, i2, r2, n2) {
          if (e5.length === 0)
            return -1;
          if (typeof i2 == "string" ? (r2 = i2, i2 = 0) : i2 > 2147483647 ? i2 = 2147483647 : i2 < -2147483648 && (i2 = -2147483648), K(i2 = +i2) && (i2 = n2 ? 0 : e5.length - 1), i2 < 0 && (i2 = e5.length + i2), i2 >= e5.length) {
            if (n2)
              return -1;
            i2 = e5.length - 1;
          } else if (i2 < 0) {
            if (!n2)
              return -1;
            i2 = 0;
          }
          if (typeof t4 == "string" && (t4 = s.from(t4, r2)), s.isBuffer(t4))
            return t4.length === 0 ? -1 : x(e5, t4, i2, r2, n2);
          if (typeof t4 == "number")
            return t4 &= 255, typeof Uint8Array.prototype.indexOf == "function" ? n2 ? Uint8Array.prototype.indexOf.call(e5, t4, i2) : Uint8Array.prototype.lastIndexOf.call(e5, t4, i2) : x(e5, [t4], i2, r2, n2);
          throw new TypeError("val must be string, number or Buffer");
        }
        function x(e5, t4, i2, r2, n2) {
          var a2, o2 = 1, s2 = e5.length, l2 = t4.length;
          if (r2 !== undefined && ((r2 = String(r2).toLowerCase()) === "ucs2" || r2 === "ucs-2" || r2 === "utf16le" || r2 === "utf-16le")) {
            if (e5.length < 2 || t4.length < 2)
              return -1;
            o2 = 2, s2 /= 2, l2 /= 2, i2 /= 2;
          }
          function u2(e6, t5) {
            return o2 === 1 ? e6[t5] : e6.readUInt16BE(t5 * o2);
          }
          if (n2) {
            var h2 = -1;
            for (a2 = i2;a2 < s2; a2++)
              if (u2(e5, a2) === u2(t4, h2 === -1 ? 0 : a2 - h2)) {
                if (h2 === -1 && (h2 = a2), a2 - h2 + 1 === l2)
                  return h2 * o2;
              } else
                h2 !== -1 && (a2 -= a2 - h2), h2 = -1;
          } else
            for (i2 + l2 > s2 && (i2 = s2 - l2), a2 = i2;a2 >= 0; a2--) {
              for (var c2 = true, f2 = 0;f2 < l2; f2++)
                if (u2(e5, a2 + f2) !== u2(t4, f2)) {
                  c2 = false;
                  break;
                }
              if (c2)
                return a2;
            }
          return -1;
        }
        function E(e5, t4, i2, r2) {
          i2 = Number(i2) || 0;
          var n2 = e5.length - i2;
          r2 ? (r2 = Number(r2)) > n2 && (r2 = n2) : r2 = n2;
          var a2 = t4.length;
          r2 > a2 / 2 && (r2 = a2 / 2);
          for (var o2 = 0;o2 < r2; ++o2) {
            var s2 = parseInt(t4.substr(2 * o2, 2), 16);
            if (K(s2))
              return o2;
            e5[i2 + o2] = s2;
          }
          return o2;
        }
        function k(e5, t4, i2, r2) {
          return V(H(t4, e5.length - i2), e5, i2, r2);
        }
        function S(e5, t4, i2, r2) {
          return V(Q(t4), e5, i2, r2);
        }
        function A(e5, t4, i2, r2) {
          return S(e5, t4, i2, r2);
        }
        function I(e5, t4, i2, r2) {
          return V(q(t4), e5, i2, r2);
        }
        function M(e5, t4, i2, r2) {
          return V(W(t4, e5.length - i2), e5, i2, r2);
        }
        function T(e5, i2, r2) {
          return i2 === 0 && r2 === e5.length ? t3.fromByteArray(e5) : t3.fromByteArray(e5.slice(i2, r2));
        }
        function P(e5, t4, i2) {
          i2 = Math.min(e5.length, i2);
          for (var r2 = [], n2 = t4;n2 < i2; ) {
            var a2, o2, s2, l2, u2 = e5[n2], h2 = null, c2 = u2 > 239 ? 4 : u2 > 223 ? 3 : u2 > 191 ? 2 : 1;
            if (n2 + c2 <= i2)
              switch (c2) {
                case 1:
                  u2 < 128 && (h2 = u2);
                  break;
                case 2:
                  (192 & (a2 = e5[n2 + 1])) == 128 && (l2 = (31 & u2) << 6 | 63 & a2) > 127 && (h2 = l2);
                  break;
                case 3:
                  a2 = e5[n2 + 1], o2 = e5[n2 + 2], (192 & a2) == 128 && (192 & o2) == 128 && (l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & o2) > 2047 && (l2 < 55296 || l2 > 57343) && (h2 = l2);
                  break;
                case 4:
                  a2 = e5[n2 + 1], o2 = e5[n2 + 2], s2 = e5[n2 + 3], (192 & a2) == 128 && (192 & o2) == 128 && (192 & s2) == 128 && (l2 = (15 & u2) << 18 | (63 & a2) << 12 | (63 & o2) << 6 | 63 & s2) > 65535 && l2 < 1114112 && (h2 = l2);
              }
            h2 === null ? (h2 = 65533, c2 = 1) : h2 > 65535 && (h2 -= 65536, r2.push(h2 >>> 10 & 1023 | 55296), h2 = 56320 | 1023 & h2), r2.push(h2), n2 += c2;
          }
          return C(r2);
        }
        i.kMaxLength = n, s.TYPED_ARRAY_SUPPORT = a(), s.TYPED_ARRAY_SUPPORT || typeof console == "undefined" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", { enumerable: true, get: function() {
          if (s.isBuffer(this))
            return this.buffer;
        } }), Object.defineProperty(s.prototype, "offset", { enumerable: true, get: function() {
          if (s.isBuffer(this))
            return this.byteOffset;
        } }), typeof Symbol != "undefined" && Symbol.species != null && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), s.poolSize = 8192, s.from = function(e5, t4, i2) {
          return l(e5, t4, i2);
        }, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function(e5, t4, i2) {
          return h(e5, t4, i2);
        }, s.allocUnsafe = function(e5) {
          return c(e5);
        }, s.allocUnsafeSlow = function(e5) {
          return c(e5);
        }, s.isBuffer = function(e5) {
          return e5 != null && e5._isBuffer === true && e5 !== s.prototype;
        }, s.compare = function(e5, t4) {
          if (Y(e5, Uint8Array) && (e5 = s.from(e5, e5.offset, e5.byteLength)), Y(t4, Uint8Array) && (t4 = s.from(t4, t4.offset, t4.byteLength)), !s.isBuffer(e5) || !s.isBuffer(t4))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (e5 === t4)
            return 0;
          for (var i2 = e5.length, r2 = t4.length, n2 = 0, a2 = Math.min(i2, r2);n2 < a2; ++n2)
            if (e5[n2] !== t4[n2]) {
              i2 = e5[n2], r2 = t4[n2];
              break;
            }
          return i2 < r2 ? -1 : r2 < i2 ? 1 : 0;
        }, s.isEncoding = function(e5) {
          switch (String(e5).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, s.concat = function(e5, t4) {
          if (!Array.isArray(e5))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (e5.length === 0)
            return s.alloc(0);
          var i2;
          if (t4 === undefined)
            for (t4 = 0, i2 = 0;i2 < e5.length; ++i2)
              t4 += e5[i2].length;
          var r2 = s.allocUnsafe(t4), n2 = 0;
          for (i2 = 0;i2 < e5.length; ++i2) {
            var a2 = e5[i2];
            if (Y(a2, Uint8Array) && (a2 = s.from(a2)), !s.isBuffer(a2))
              throw new TypeError('"list" argument must be an Array of Buffers');
            a2.copy(r2, n2), n2 += a2.length;
          }
          return r2;
        }, s.byteLength = b2, s.prototype._isBuffer = true, s.prototype.swap16 = function() {
          var e5 = this.length;
          if (e5 % 2 != 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var t4 = 0;t4 < e5; t4 += 2)
            w(this, t4, t4 + 1);
          return this;
        }, s.prototype.swap32 = function() {
          var e5 = this.length;
          if (e5 % 4 != 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var t4 = 0;t4 < e5; t4 += 4)
            w(this, t4, t4 + 3), w(this, t4 + 1, t4 + 2);
          return this;
        }, s.prototype.swap64 = function() {
          var e5 = this.length;
          if (e5 % 8 != 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var t4 = 0;t4 < e5; t4 += 8)
            w(this, t4, t4 + 7), w(this, t4 + 1, t4 + 6), w(this, t4 + 2, t4 + 5), w(this, t4 + 3, t4 + 4);
          return this;
        }, s.prototype.toString = function() {
          var e5 = this.length;
          return e5 === 0 ? "" : arguments.length === 0 ? P(this, 0, e5) : y.apply(this, arguments);
        }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e5) {
          if (!s.isBuffer(e5))
            throw new TypeError("Argument must be a Buffer");
          return this === e5 || s.compare(this, e5) === 0;
        }, s.prototype.inspect = function() {
          var e5 = "", t4 = i.INSPECT_MAX_BYTES;
          return e5 = this.toString("hex", 0, t4).replace(/(.{2})/g, "$1 ").trim(), this.length > t4 && (e5 += " ... "), "<Buffer " + e5 + ">";
        }, s.prototype.compare = function(e5, t4, i2, r2, n2) {
          if (Y(e5, Uint8Array) && (e5 = s.from(e5, e5.offset, e5.byteLength)), !s.isBuffer(e5))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e5);
          if (t4 === undefined && (t4 = 0), i2 === undefined && (i2 = e5 ? e5.length : 0), r2 === undefined && (r2 = 0), n2 === undefined && (n2 = this.length), t4 < 0 || i2 > e5.length || r2 < 0 || n2 > this.length)
            throw new RangeError("out of range index");
          if (r2 >= n2 && t4 >= i2)
            return 0;
          if (r2 >= n2)
            return -1;
          if (t4 >= i2)
            return 1;
          if (this === e5)
            return 0;
          for (var a2 = (n2 >>>= 0) - (r2 >>>= 0), o2 = (i2 >>>= 0) - (t4 >>>= 0), l2 = Math.min(a2, o2), u2 = this.slice(r2, n2), h2 = e5.slice(t4, i2), c2 = 0;c2 < l2; ++c2)
            if (u2[c2] !== h2[c2]) {
              a2 = u2[c2], o2 = h2[c2];
              break;
            }
          return a2 < o2 ? -1 : o2 < a2 ? 1 : 0;
        }, s.prototype.includes = function(e5, t4, i2) {
          return this.indexOf(e5, t4, i2) !== -1;
        }, s.prototype.indexOf = function(e5, t4, i2) {
          return v(this, e5, t4, i2, true);
        }, s.prototype.lastIndexOf = function(e5, t4, i2) {
          return v(this, e5, t4, i2, false);
        }, s.prototype.write = function(e5, t4, i2, r2) {
          if (t4 === undefined)
            r2 = "utf8", i2 = this.length, t4 = 0;
          else if (i2 === undefined && typeof t4 == "string")
            r2 = t4, i2 = this.length, t4 = 0;
          else {
            if (!isFinite(t4))
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            t4 >>>= 0, isFinite(i2) ? (i2 >>>= 0, r2 === undefined && (r2 = "utf8")) : (r2 = i2, i2 = undefined);
          }
          var n2 = this.length - t4;
          if ((i2 === undefined || i2 > n2) && (i2 = n2), e5.length > 0 && (i2 < 0 || t4 < 0) || t4 > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
          r2 || (r2 = "utf8");
          for (var a2 = false;; )
            switch (r2) {
              case "hex":
                return E(this, e5, t4, i2);
              case "utf8":
              case "utf-8":
                return k(this, e5, t4, i2);
              case "ascii":
                return S(this, e5, t4, i2);
              case "latin1":
              case "binary":
                return A(this, e5, t4, i2);
              case "base64":
                return I(this, e5, t4, i2);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return M(this, e5, t4, i2);
              default:
                if (a2)
                  throw new TypeError("Unknown encoding: " + r2);
                r2 = ("" + r2).toLowerCase(), a2 = true;
            }
        }, s.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        var B = 4096;
        function C(e5) {
          var t4 = e5.length;
          if (t4 <= B)
            return String.fromCharCode.apply(String, e5);
          for (var i2 = "", r2 = 0;r2 < t4; )
            i2 += String.fromCharCode.apply(String, e5.slice(r2, r2 += B));
          return i2;
        }
        function R(e5, t4, i2) {
          var r2 = "";
          i2 = Math.min(e5.length, i2);
          for (var n2 = t4;n2 < i2; ++n2)
            r2 += String.fromCharCode(127 & e5[n2]);
          return r2;
        }
        function z(e5, t4, i2) {
          var r2 = "";
          i2 = Math.min(e5.length, i2);
          for (var n2 = t4;n2 < i2; ++n2)
            r2 += String.fromCharCode(e5[n2]);
          return r2;
        }
        function F(e5, t4, i2) {
          var r2 = e5.length;
          (!t4 || t4 < 0) && (t4 = 0), (!i2 || i2 < 0 || i2 > r2) && (i2 = r2);
          for (var n2 = "", a2 = t4;a2 < i2; ++a2)
            n2 += G(e5[a2]);
          return n2;
        }
        function N(e5, t4, i2) {
          for (var r2 = e5.slice(t4, i2), n2 = "", a2 = 0;a2 < r2.length; a2 += 2)
            n2 += String.fromCharCode(r2[a2] + 256 * r2[a2 + 1]);
          return n2;
        }
        function O(e5, t4, i2) {
          if (e5 % 1 != 0 || e5 < 0)
            throw new RangeError("offset is not uint");
          if (e5 + t4 > i2)
            throw new RangeError("Trying to access beyond buffer length");
        }
        function D(e5, t4, i2, r2, n2, a2) {
          if (!s.isBuffer(e5))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (t4 > n2 || t4 < a2)
            throw new RangeError('"value" argument is out of bounds');
          if (i2 + r2 > e5.length)
            throw new RangeError("Index out of range");
        }
        function $(e5, t4, i2, r2, n2, a2) {
          if (i2 + r2 > e5.length)
            throw new RangeError("Index out of range");
          if (i2 < 0)
            throw new RangeError("Index out of range");
        }
        function L(e5, t4, i2, n2, a2) {
          return t4 = +t4, i2 >>>= 0, a2 || $(e5, t4, i2, 4), r.write(e5, t4, i2, n2, 23, 4), i2 + 4;
        }
        function U(e5, t4, i2, n2, a2) {
          return t4 = +t4, i2 >>>= 0, a2 || $(e5, t4, i2, 8), r.write(e5, t4, i2, n2, 52, 8), i2 + 8;
        }
        s.prototype.slice = function(e5, t4) {
          var i2 = this.length;
          (e5 = ~~e5) < 0 ? (e5 += i2) < 0 && (e5 = 0) : e5 > i2 && (e5 = i2), (t4 = t4 === undefined ? i2 : ~~t4) < 0 ? (t4 += i2) < 0 && (t4 = 0) : t4 > i2 && (t4 = i2), t4 < e5 && (t4 = e5);
          var r2 = this.subarray(e5, t4);
          return r2.__proto__ = s.prototype, r2;
        }, s.prototype.readUIntLE = function(e5, t4, i2) {
          e5 >>>= 0, t4 >>>= 0, i2 || O(e5, t4, this.length);
          for (var r2 = this[e5], n2 = 1, a2 = 0;++a2 < t4 && (n2 *= 256); )
            r2 += this[e5 + a2] * n2;
          return r2;
        }, s.prototype.readUIntBE = function(e5, t4, i2) {
          e5 >>>= 0, t4 >>>= 0, i2 || O(e5, t4, this.length);
          for (var r2 = this[e5 + --t4], n2 = 1;t4 > 0 && (n2 *= 256); )
            r2 += this[e5 + --t4] * n2;
          return r2;
        }, s.prototype.readUInt8 = function(e5, t4) {
          return e5 >>>= 0, t4 || O(e5, 1, this.length), this[e5];
        }, s.prototype.readUInt16LE = function(e5, t4) {
          return e5 >>>= 0, t4 || O(e5, 2, this.length), this[e5] | this[e5 + 1] << 8;
        }, s.prototype.readUInt16BE = function(e5, t4) {
          return e5 >>>= 0, t4 || O(e5, 2, this.length), this[e5] << 8 | this[e5 + 1];
        }, s.prototype.readUInt32LE = function(e5, t4) {
          return e5 >>>= 0, t4 || O(e5, 4, this.length), (this[e5] | this[e5 + 1] << 8 | this[e5 + 2] << 16) + 16777216 * this[e5 + 3];
        }, s.prototype.readUInt32BE = function(e5, t4) {
          return e5 >>>= 0, t4 || O(e5, 4, this.length), 16777216 * this[e5] + (this[e5 + 1] << 16 | this[e5 + 2] << 8 | this[e5 + 3]);
        }, s.prototype.readIntLE = function(e5, t4, i2) {
          e5 >>>= 0, t4 >>>= 0, i2 || O(e5, t4, this.length);
          for (var r2 = this[e5], n2 = 1, a2 = 0;++a2 < t4 && (n2 *= 256); )
            r2 += this[e5 + a2] * n2;
          return r2 >= (n2 *= 128) && (r2 -= Math.pow(2, 8 * t4)), r2;
        }, s.prototype.readIntBE = function(e5, t4, i2) {
          e5 >>>= 0, t4 >>>= 0, i2 || O(e5, t4, this.length);
          for (var r2 = t4, n2 = 1, a2 = this[e5 + --r2];r2 > 0 && (n2 *= 256); )
            a2 += this[e5 + --r2] * n2;
          return a2 >= (n2 *= 128) && (a2 -= Math.pow(2, 8 * t4)), a2;
        }, s.prototype.readInt8 = function(e5, t4) {
          return e5 >>>= 0, t4 || O(e5, 1, this.length), 128 & this[e5] ? -1 * (255 - this[e5] + 1) : this[e5];
        }, s.prototype.readInt16LE = function(e5, t4) {
          e5 >>>= 0, t4 || O(e5, 2, this.length);
          var i2 = this[e5] | this[e5 + 1] << 8;
          return 32768 & i2 ? 4294901760 | i2 : i2;
        }, s.prototype.readInt16BE = function(e5, t4) {
          e5 >>>= 0, t4 || O(e5, 2, this.length);
          var i2 = this[e5 + 1] | this[e5] << 8;
          return 32768 & i2 ? 4294901760 | i2 : i2;
        }, s.prototype.readInt32LE = function(e5, t4) {
          return e5 >>>= 0, t4 || O(e5, 4, this.length), this[e5] | this[e5 + 1] << 8 | this[e5 + 2] << 16 | this[e5 + 3] << 24;
        }, s.prototype.readInt32BE = function(e5, t4) {
          return e5 >>>= 0, t4 || O(e5, 4, this.length), this[e5] << 24 | this[e5 + 1] << 16 | this[e5 + 2] << 8 | this[e5 + 3];
        }, s.prototype.readFloatLE = function(e5, t4) {
          return e5 >>>= 0, t4 || O(e5, 4, this.length), r.read(this, e5, true, 23, 4);
        }, s.prototype.readFloatBE = function(e5, t4) {
          return e5 >>>= 0, t4 || O(e5, 4, this.length), r.read(this, e5, false, 23, 4);
        }, s.prototype.readDoubleLE = function(e5, t4) {
          return e5 >>>= 0, t4 || O(e5, 8, this.length), r.read(this, e5, true, 52, 8);
        }, s.prototype.readDoubleBE = function(e5, t4) {
          return e5 >>>= 0, t4 || O(e5, 8, this.length), r.read(this, e5, false, 52, 8);
        }, s.prototype.writeUIntLE = function(e5, t4, i2, r2) {
          e5 = +e5, t4 >>>= 0, i2 >>>= 0, r2 || D(this, e5, t4, i2, Math.pow(2, 8 * i2) - 1, 0);
          var n2 = 1, a2 = 0;
          for (this[t4] = 255 & e5;++a2 < i2 && (n2 *= 256); )
            this[t4 + a2] = e5 / n2 & 255;
          return t4 + i2;
        }, s.prototype.writeUIntBE = function(e5, t4, i2, r2) {
          e5 = +e5, t4 >>>= 0, i2 >>>= 0, r2 || D(this, e5, t4, i2, Math.pow(2, 8 * i2) - 1, 0);
          var n2 = i2 - 1, a2 = 1;
          for (this[t4 + n2] = 255 & e5;--n2 >= 0 && (a2 *= 256); )
            this[t4 + n2] = e5 / a2 & 255;
          return t4 + i2;
        }, s.prototype.writeUInt8 = function(e5, t4, i2) {
          return e5 = +e5, t4 >>>= 0, i2 || D(this, e5, t4, 1, 255, 0), this[t4] = 255 & e5, t4 + 1;
        }, s.prototype.writeUInt16LE = function(e5, t4, i2) {
          return e5 = +e5, t4 >>>= 0, i2 || D(this, e5, t4, 2, 65535, 0), this[t4] = 255 & e5, this[t4 + 1] = e5 >>> 8, t4 + 2;
        }, s.prototype.writeUInt16BE = function(e5, t4, i2) {
          return e5 = +e5, t4 >>>= 0, i2 || D(this, e5, t4, 2, 65535, 0), this[t4] = e5 >>> 8, this[t4 + 1] = 255 & e5, t4 + 2;
        }, s.prototype.writeUInt32LE = function(e5, t4, i2) {
          return e5 = +e5, t4 >>>= 0, i2 || D(this, e5, t4, 4, 4294967295, 0), this[t4 + 3] = e5 >>> 24, this[t4 + 2] = e5 >>> 16, this[t4 + 1] = e5 >>> 8, this[t4] = 255 & e5, t4 + 4;
        }, s.prototype.writeUInt32BE = function(e5, t4, i2) {
          return e5 = +e5, t4 >>>= 0, i2 || D(this, e5, t4, 4, 4294967295, 0), this[t4] = e5 >>> 24, this[t4 + 1] = e5 >>> 16, this[t4 + 2] = e5 >>> 8, this[t4 + 3] = 255 & e5, t4 + 4;
        }, s.prototype.writeIntLE = function(e5, t4, i2, r2) {
          if (e5 = +e5, t4 >>>= 0, !r2) {
            var n2 = Math.pow(2, 8 * i2 - 1);
            D(this, e5, t4, i2, n2 - 1, -n2);
          }
          var a2 = 0, o2 = 1, s2 = 0;
          for (this[t4] = 255 & e5;++a2 < i2 && (o2 *= 256); )
            e5 < 0 && s2 === 0 && this[t4 + a2 - 1] !== 0 && (s2 = 1), this[t4 + a2] = (e5 / o2 | 0) - s2 & 255;
          return t4 + i2;
        }, s.prototype.writeIntBE = function(e5, t4, i2, r2) {
          if (e5 = +e5, t4 >>>= 0, !r2) {
            var n2 = Math.pow(2, 8 * i2 - 1);
            D(this, e5, t4, i2, n2 - 1, -n2);
          }
          var a2 = i2 - 1, o2 = 1, s2 = 0;
          for (this[t4 + a2] = 255 & e5;--a2 >= 0 && (o2 *= 256); )
            e5 < 0 && s2 === 0 && this[t4 + a2 + 1] !== 0 && (s2 = 1), this[t4 + a2] = (e5 / o2 | 0) - s2 & 255;
          return t4 + i2;
        }, s.prototype.writeInt8 = function(e5, t4, i2) {
          return e5 = +e5, t4 >>>= 0, i2 || D(this, e5, t4, 1, 127, -128), e5 < 0 && (e5 = 255 + e5 + 1), this[t4] = 255 & e5, t4 + 1;
        }, s.prototype.writeInt16LE = function(e5, t4, i2) {
          return e5 = +e5, t4 >>>= 0, i2 || D(this, e5, t4, 2, 32767, -32768), this[t4] = 255 & e5, this[t4 + 1] = e5 >>> 8, t4 + 2;
        }, s.prototype.writeInt16BE = function(e5, t4, i2) {
          return e5 = +e5, t4 >>>= 0, i2 || D(this, e5, t4, 2, 32767, -32768), this[t4] = e5 >>> 8, this[t4 + 1] = 255 & e5, t4 + 2;
        }, s.prototype.writeInt32LE = function(e5, t4, i2) {
          return e5 = +e5, t4 >>>= 0, i2 || D(this, e5, t4, 4, 2147483647, -2147483648), this[t4] = 255 & e5, this[t4 + 1] = e5 >>> 8, this[t4 + 2] = e5 >>> 16, this[t4 + 3] = e5 >>> 24, t4 + 4;
        }, s.prototype.writeInt32BE = function(e5, t4, i2) {
          return e5 = +e5, t4 >>>= 0, i2 || D(this, e5, t4, 4, 2147483647, -2147483648), e5 < 0 && (e5 = 4294967295 + e5 + 1), this[t4] = e5 >>> 24, this[t4 + 1] = e5 >>> 16, this[t4 + 2] = e5 >>> 8, this[t4 + 3] = 255 & e5, t4 + 4;
        }, s.prototype.writeFloatLE = function(e5, t4, i2) {
          return L(this, e5, t4, true, i2);
        }, s.prototype.writeFloatBE = function(e5, t4, i2) {
          return L(this, e5, t4, false, i2);
        }, s.prototype.writeDoubleLE = function(e5, t4, i2) {
          return U(this, e5, t4, true, i2);
        }, s.prototype.writeDoubleBE = function(e5, t4, i2) {
          return U(this, e5, t4, false, i2);
        }, s.prototype.copy = function(e5, t4, i2, r2) {
          if (!s.isBuffer(e5))
            throw new TypeError("argument should be a Buffer");
          if (i2 || (i2 = 0), r2 || r2 === 0 || (r2 = this.length), t4 >= e5.length && (t4 = e5.length), t4 || (t4 = 0), r2 > 0 && r2 < i2 && (r2 = i2), r2 === i2)
            return 0;
          if (e5.length === 0 || this.length === 0)
            return 0;
          if (t4 < 0)
            throw new RangeError("targetStart out of bounds");
          if (i2 < 0 || i2 >= this.length)
            throw new RangeError("Index out of range");
          if (r2 < 0)
            throw new RangeError("sourceEnd out of bounds");
          r2 > this.length && (r2 = this.length), e5.length - t4 < r2 - i2 && (r2 = e5.length - t4 + i2);
          var n2 = r2 - i2;
          if (this === e5 && typeof Uint8Array.prototype.copyWithin == "function")
            this.copyWithin(t4, i2, r2);
          else if (this === e5 && i2 < t4 && t4 < r2)
            for (var a2 = n2 - 1;a2 >= 0; --a2)
              e5[a2 + t4] = this[a2 + i2];
          else
            Uint8Array.prototype.set.call(e5, this.subarray(i2, r2), t4);
          return n2;
        }, s.prototype.fill = function(e5, t4, i2, r2) {
          if (typeof e5 == "string") {
            if (typeof t4 == "string" ? (r2 = t4, t4 = 0, i2 = this.length) : typeof i2 == "string" && (r2 = i2, i2 = this.length), r2 !== undefined && typeof r2 != "string")
              throw new TypeError("encoding must be a string");
            if (typeof r2 == "string" && !s.isEncoding(r2))
              throw new TypeError("Unknown encoding: " + r2);
            if (e5.length === 1) {
              var n2 = e5.charCodeAt(0);
              (r2 === "utf8" && n2 < 128 || r2 === "latin1") && (e5 = n2);
            }
          } else
            typeof e5 == "number" && (e5 &= 255);
          if (t4 < 0 || this.length < t4 || this.length < i2)
            throw new RangeError("Out of range index");
          if (i2 <= t4)
            return this;
          var a2;
          if (t4 >>>= 0, i2 = i2 === undefined ? this.length : i2 >>> 0, e5 || (e5 = 0), typeof e5 == "number")
            for (a2 = t4;a2 < i2; ++a2)
              this[a2] = e5;
          else {
            var o2 = s.isBuffer(e5) ? e5 : s.from(e5, r2), l2 = o2.length;
            if (l2 === 0)
              throw new TypeError('The value "' + e5 + '" is invalid for argument "value"');
            for (a2 = 0;a2 < i2 - t4; ++a2)
              this[a2 + t4] = o2[a2 % l2];
          }
          return this;
        };
        var Z = /[^+/0-9A-Za-z-_]/g;
        function j(e5) {
          if ((e5 = (e5 = e5.split("=")[0]).trim().replace(Z, "")).length < 2)
            return "";
          for (;e5.length % 4 != 0; )
            e5 += "=";
          return e5;
        }
        function G(e5) {
          return e5 < 16 ? "0" + e5.toString(16) : e5.toString(16);
        }
        function H(e5, t4) {
          var i2;
          t4 = t4 || 1 / 0;
          for (var r2 = e5.length, n2 = null, a2 = [], o2 = 0;o2 < r2; ++o2) {
            if ((i2 = e5.charCodeAt(o2)) > 55295 && i2 < 57344) {
              if (!n2) {
                if (i2 > 56319) {
                  (t4 -= 3) > -1 && a2.push(239, 191, 189);
                  continue;
                }
                if (o2 + 1 === r2) {
                  (t4 -= 3) > -1 && a2.push(239, 191, 189);
                  continue;
                }
                n2 = i2;
                continue;
              }
              if (i2 < 56320) {
                (t4 -= 3) > -1 && a2.push(239, 191, 189), n2 = i2;
                continue;
              }
              i2 = 65536 + (n2 - 55296 << 10 | i2 - 56320);
            } else
              n2 && (t4 -= 3) > -1 && a2.push(239, 191, 189);
            if (n2 = null, i2 < 128) {
              if ((t4 -= 1) < 0)
                break;
              a2.push(i2);
            } else if (i2 < 2048) {
              if ((t4 -= 2) < 0)
                break;
              a2.push(i2 >> 6 | 192, 63 & i2 | 128);
            } else if (i2 < 65536) {
              if ((t4 -= 3) < 0)
                break;
              a2.push(i2 >> 12 | 224, i2 >> 6 & 63 | 128, 63 & i2 | 128);
            } else {
              if (!(i2 < 1114112))
                throw new Error("Invalid code point");
              if ((t4 -= 4) < 0)
                break;
              a2.push(i2 >> 18 | 240, i2 >> 12 & 63 | 128, i2 >> 6 & 63 | 128, 63 & i2 | 128);
            }
          }
          return a2;
        }
        function Q(e5) {
          for (var t4 = [], i2 = 0;i2 < e5.length; ++i2)
            t4.push(255 & e5.charCodeAt(i2));
          return t4;
        }
        function W(e5, t4) {
          for (var i2, r2, n2, a2 = [], o2 = 0;o2 < e5.length && !((t4 -= 2) < 0); ++o2)
            r2 = (i2 = e5.charCodeAt(o2)) >> 8, n2 = i2 % 256, a2.push(n2), a2.push(r2);
          return a2;
        }
        function q(e5) {
          return t3.toByteArray(j(e5));
        }
        function V(e5, t4, i2, r2) {
          for (var n2 = 0;n2 < r2 && !(n2 + i2 >= t4.length || n2 >= e5.length); ++n2)
            t4[n2 + i2] = e5[n2];
          return n2;
        }
        function Y(e5, t4) {
          return e5 instanceof t4 || e5 != null && e5.constructor != null && e5.constructor.name != null && e5.constructor.name === t4.name;
        }
        function K(e5) {
          return e5 != e5;
        }
      }).call(this);
    }).call(this, e4("buffer").Buffer);
  }, { "base64-js": 28, buffer: 32, ieee754: 45 }], 33: [function(e4, t, i) {
    var r = e4("get-intrinsic"), n = e4("./"), a = n(r("String.prototype.indexOf"));
    t.exports = function(e5, t2) {
      var i2 = r(e5, !!t2);
      return typeof i2 == "function" && a(e5, ".prototype.") > -1 ? n(i2) : i2;
    };
  }, { "./": 34, "get-intrinsic": 39 }], 34: [function(e4, t, i) {
    var r = e4("function-bind"), n = e4("get-intrinsic"), a = n("%Function.prototype.apply%"), o = n("%Function.prototype.call%"), s = n("%Reflect.apply%", true) || r.call(o, a), l = n("%Object.getOwnPropertyDescriptor%", true), u = n("%Object.defineProperty%", true), h = n("%Math.max%");
    if (u)
      try {
        u({}, "a", { value: 1 });
      } catch (e5) {
        u = null;
      }
    t.exports = function(e5) {
      var t2 = s(r, o, arguments);
      return l && u && l(t2, "length").configurable && u(t2, "length", { value: 1 + h(0, e5.length - (arguments.length - 1)) }), t2;
    };
    var c = function() {
      return s(r, a, arguments);
    };
    u ? u(t.exports, "apply", { value: c }) : t.exports.apply = c;
  }, { "function-bind": 38, "get-intrinsic": 39 }], 35: [function(e4, t, i) {
    var r, n = typeof Reflect == "object" ? Reflect : null, a = n && typeof n.apply == "function" ? n.apply : function(e5, t2, i2) {
      return Function.prototype.apply.call(e5, t2, i2);
    };
    function o(e5) {
      console && console.warn && console.warn(e5);
    }
    r = n && typeof n.ownKeys == "function" ? n.ownKeys : Object.getOwnPropertySymbols ? function(e5) {
      return Object.getOwnPropertyNames(e5).concat(Object.getOwnPropertySymbols(e5));
    } : function(e5) {
      return Object.getOwnPropertyNames(e5);
    };
    var s = Number.isNaN || function(e5) {
      return e5 != e5;
    };
    function l() {
      l.init.call(this);
    }
    t.exports = l, t.exports.once = w, l.EventEmitter = l, l.prototype._events = undefined, l.prototype._eventsCount = 0, l.prototype._maxListeners = undefined;
    var u = 10;
    function h(e5) {
      if (typeof e5 != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e5);
    }
    function c(e5) {
      return e5._maxListeners === undefined ? l.defaultMaxListeners : e5._maxListeners;
    }
    function f(e5, t2, i2, r2) {
      var n2, a2, s2;
      if (h(i2), (a2 = e5._events) === undefined ? (a2 = e5._events = Object.create(null), e5._eventsCount = 0) : (a2.newListener !== undefined && (e5.emit("newListener", t2, i2.listener ? i2.listener : i2), a2 = e5._events), s2 = a2[t2]), s2 === undefined)
        s2 = a2[t2] = i2, ++e5._eventsCount;
      else if (typeof s2 == "function" ? s2 = a2[t2] = r2 ? [i2, s2] : [s2, i2] : r2 ? s2.unshift(i2) : s2.push(i2), (n2 = c(e5)) > 0 && s2.length > n2 && !s2.warned) {
        s2.warned = true;
        var l2 = new Error("Possible EventEmitter memory leak detected. " + s2.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        l2.name = "MaxListenersExceededWarning", l2.emitter = e5, l2.type = t2, l2.count = s2.length, o(l2);
      }
      return e5;
    }
    function d() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function p(e5, t2, i2) {
      var r2 = { fired: false, wrapFn: undefined, target: e5, type: t2, listener: i2 }, n2 = d.bind(r2);
      return n2.listener = i2, r2.wrapFn = n2, n2;
    }
    function m(e5, t2, i2) {
      var r2 = e5._events;
      if (r2 === undefined)
        return [];
      var n2 = r2[t2];
      return n2 === undefined ? [] : typeof n2 == "function" ? i2 ? [n2.listener || n2] : [n2] : i2 ? y(n2) : g(n2, n2.length);
    }
    function _(e5) {
      var t2 = this._events;
      if (t2 !== undefined) {
        var i2 = t2[e5];
        if (typeof i2 == "function")
          return 1;
        if (i2 !== undefined)
          return i2.length;
      }
      return 0;
    }
    function g(e5, t2) {
      for (var i2 = new Array(t2), r2 = 0;r2 < t2; ++r2)
        i2[r2] = e5[r2];
      return i2;
    }
    function b2(e5, t2) {
      for (;t2 + 1 < e5.length; t2++)
        e5[t2] = e5[t2 + 1];
      e5.pop();
    }
    function y(e5) {
      for (var t2 = new Array(e5.length), i2 = 0;i2 < t2.length; ++i2)
        t2[i2] = e5[i2].listener || e5[i2];
      return t2;
    }
    function w(e5, t2) {
      return new Promise(function(i2, r2) {
        function n2(i3) {
          e5.removeListener(t2, a2), r2(i3);
        }
        function a2() {
          typeof e5.removeListener == "function" && e5.removeListener("error", n2), i2([].slice.call(arguments));
        }
        x(e5, t2, a2, { once: true }), t2 !== "error" && v(e5, n2, { once: true });
      });
    }
    function v(e5, t2, i2) {
      typeof e5.on == "function" && x(e5, "error", t2, i2);
    }
    function x(e5, t2, i2, r2) {
      if (typeof e5.on == "function")
        r2.once ? e5.once(t2, i2) : e5.on(t2, i2);
      else {
        if (typeof e5.addEventListener != "function")
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e5);
        e5.addEventListener(t2, function n(a2) {
          r2.once && e5.removeEventListener(t2, n), i2(a2);
        });
      }
    }
    Object.defineProperty(l, "defaultMaxListeners", { enumerable: true, get: function() {
      return u;
    }, set: function(e5) {
      if (typeof e5 != "number" || e5 < 0 || s(e5))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e5 + ".");
      u = e5;
    } }), l.init = function() {
      this._events !== undefined && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    }, l.prototype.setMaxListeners = function(e5) {
      if (typeof e5 != "number" || e5 < 0 || s(e5))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e5 + ".");
      return this._maxListeners = e5, this;
    }, l.prototype.getMaxListeners = function() {
      return c(this);
    }, l.prototype.emit = function(e5) {
      for (var t2 = [], i2 = 1;i2 < arguments.length; i2++)
        t2.push(arguments[i2]);
      var r2 = e5 === "error", n2 = this._events;
      if (n2 !== undefined)
        r2 = r2 && n2.error === undefined;
      else if (!r2)
        return false;
      if (r2) {
        var o2;
        if (t2.length > 0 && (o2 = t2[0]), o2 instanceof Error)
          throw o2;
        var s2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
        throw s2.context = o2, s2;
      }
      var l2 = n2[e5];
      if (l2 === undefined)
        return false;
      if (typeof l2 == "function")
        a(l2, this, t2);
      else {
        var u2 = l2.length, h2 = g(l2, u2);
        for (i2 = 0;i2 < u2; ++i2)
          a(h2[i2], this, t2);
      }
      return true;
    }, l.prototype.addListener = function(e5, t2) {
      return f(this, e5, t2, false);
    }, l.prototype.on = l.prototype.addListener, l.prototype.prependListener = function(e5, t2) {
      return f(this, e5, t2, true);
    }, l.prototype.once = function(e5, t2) {
      return h(t2), this.on(e5, p(this, e5, t2)), this;
    }, l.prototype.prependOnceListener = function(e5, t2) {
      return h(t2), this.prependListener(e5, p(this, e5, t2)), this;
    }, l.prototype.removeListener = function(e5, t2) {
      var i2, r2, n2, a2, o2;
      if (h(t2), (r2 = this._events) === undefined)
        return this;
      if ((i2 = r2[e5]) === undefined)
        return this;
      if (i2 === t2 || i2.listener === t2)
        --this._eventsCount == 0 ? this._events = Object.create(null) : (delete r2[e5], r2.removeListener && this.emit("removeListener", e5, i2.listener || t2));
      else if (typeof i2 != "function") {
        for (n2 = -1, a2 = i2.length - 1;a2 >= 0; a2--)
          if (i2[a2] === t2 || i2[a2].listener === t2) {
            o2 = i2[a2].listener, n2 = a2;
            break;
          }
        if (n2 < 0)
          return this;
        n2 === 0 ? i2.shift() : b2(i2, n2), i2.length === 1 && (r2[e5] = i2[0]), r2.removeListener !== undefined && this.emit("removeListener", e5, o2 || t2);
      }
      return this;
    }, l.prototype.off = l.prototype.removeListener, l.prototype.removeAllListeners = function(e5) {
      var t2, i2, r2;
      if ((i2 = this._events) === undefined)
        return this;
      if (i2.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : i2[e5] !== undefined && (--this._eventsCount == 0 ? this._events = Object.create(null) : delete i2[e5]), this;
      if (arguments.length === 0) {
        var n2, a2 = Object.keys(i2);
        for (r2 = 0;r2 < a2.length; ++r2)
          (n2 = a2[r2]) !== "removeListener" && this.removeAllListeners(n2);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (typeof (t2 = i2[e5]) == "function")
        this.removeListener(e5, t2);
      else if (t2 !== undefined)
        for (r2 = t2.length - 1;r2 >= 0; r2--)
          this.removeListener(e5, t2[r2]);
      return this;
    }, l.prototype.listeners = function(e5) {
      return m(this, e5, true);
    }, l.prototype.rawListeners = function(e5) {
      return m(this, e5, false);
    }, l.listenerCount = function(e5, t2) {
      return typeof e5.listenerCount == "function" ? e5.listenerCount(t2) : _.call(e5, t2);
    }, l.prototype.listenerCount = _, l.prototype.eventNames = function() {
      return this._eventsCount > 0 ? r(this._events) : [];
    };
  }, {}], 36: [function(e4, t, i) {
    var r = e4("is-callable"), n = Object.prototype.toString, a = Object.prototype.hasOwnProperty, o = function(e5, t2, i2) {
      for (var r2 = 0, n2 = e5.length;r2 < n2; r2++)
        a.call(e5, r2) && (i2 == null ? t2(e5[r2], r2, e5) : t2.call(i2, e5[r2], r2, e5));
    }, s = function(e5, t2, i2) {
      for (var r2 = 0, n2 = e5.length;r2 < n2; r2++)
        i2 == null ? t2(e5.charAt(r2), r2, e5) : t2.call(i2, e5.charAt(r2), r2, e5);
    }, l = function(e5, t2, i2) {
      for (var r2 in e5)
        a.call(e5, r2) && (i2 == null ? t2(e5[r2], r2, e5) : t2.call(i2, e5[r2], r2, e5));
    }, u = function(e5, t2, i2) {
      if (!r(t2))
        throw new TypeError("iterator must be a function");
      var a2;
      arguments.length >= 3 && (a2 = i2), n.call(e5) === "[object Array]" ? o(e5, t2, a2) : typeof e5 == "string" ? s(e5, t2, a2) : l(e5, t2, a2);
    };
    t.exports = u;
  }, { "is-callable": 48 }], 37: [function(e4, t, i) {
    var r = "Function.prototype.bind called on incompatible ", n = Array.prototype.slice, a = Object.prototype.toString, o = "[object Function]";
    t.exports = function(e5) {
      var t2 = this;
      if (typeof t2 != "function" || a.call(t2) !== o)
        throw new TypeError(r + t2);
      for (var i2, s = n.call(arguments, 1), l = function() {
        if (this instanceof i2) {
          var r2 = t2.apply(this, s.concat(n.call(arguments)));
          return Object(r2) === r2 ? r2 : this;
        }
        return t2.apply(e5, s.concat(n.call(arguments)));
      }, u = Math.max(0, t2.length - s.length), h = [], c = 0;c < u; c++)
        h.push("$" + c);
      if (i2 = Function("binder", "return function (" + h.join(",") + "){ return binder.apply(this,arguments); }")(l), t2.prototype) {
        var f = function() {
        };
        f.prototype = t2.prototype, i2.prototype = new f, f.prototype = null;
      }
      return i2;
    };
  }, {}], 38: [function(e4, t, i) {
    var r = e4("./implementation");
    t.exports = Function.prototype.bind || r;
  }, { "./implementation": 37 }], 39: [function(e4, t, i) {
    var r, n = SyntaxError, a = Function, o = TypeError, s = function(e5) {
      try {
        return a('"use strict"; return (' + e5 + ").constructor;")();
      } catch (e6) {
      }
    }, l = Object.getOwnPropertyDescriptor;
    if (l)
      try {
        l({}, "");
      } catch (e5) {
        l = null;
      }
    var u = function() {
      throw new o;
    }, h = l ? function() {
      try {
        return u;
      } catch (e5) {
        try {
          return l(arguments, "callee").get;
        } catch (e6) {
          return u;
        }
      }
    }() : u, c = e4("has-symbols")(), f = Object.getPrototypeOf || function(e5) {
      return e5.__proto__;
    }, d = {}, p = typeof Uint8Array == "undefined" ? r : f(Uint8Array), m = { "%AggregateError%": typeof AggregateError == "undefined" ? r : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? r : ArrayBuffer, "%ArrayIteratorPrototype%": c ? f([][Symbol.iterator]()) : r, "%AsyncFromSyncIteratorPrototype%": r, "%AsyncFunction%": d, "%AsyncGenerator%": d, "%AsyncGeneratorFunction%": d, "%AsyncIteratorPrototype%": d, "%Atomics%": typeof Atomics == "undefined" ? r : Atomics, "%BigInt%": typeof BigInt == "undefined" ? r : BigInt, "%BigInt64Array%": typeof BigInt64Array == "undefined" ? r : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array == "undefined" ? r : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView == "undefined" ? r : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array == "undefined" ? r : Float32Array, "%Float64Array%": typeof Float64Array == "undefined" ? r : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? r : FinalizationRegistry, "%Function%": a, "%GeneratorFunction%": d, "%Int8Array%": typeof Int8Array == "undefined" ? r : Int8Array, "%Int16Array%": typeof Int16Array == "undefined" ? r : Int16Array, "%Int32Array%": typeof Int32Array == "undefined" ? r : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": c ? f(f([][Symbol.iterator]())) : r, "%JSON%": typeof JSON == "object" ? JSON : r, "%Map%": typeof Map == "undefined" ? r : Map, "%MapIteratorPrototype%": typeof Map != "undefined" && c ? f(new Map()[Symbol.iterator]()) : r, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise == "undefined" ? r : Promise, "%Proxy%": typeof Proxy == "undefined" ? r : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect == "undefined" ? r : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set == "undefined" ? r : Set, "%SetIteratorPrototype%": typeof Set != "undefined" && c ? f(new Set()[Symbol.iterator]()) : r, "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? r : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": c ? f(""[Symbol.iterator]()) : r, "%Symbol%": c ? Symbol : r, "%SyntaxError%": n, "%ThrowTypeError%": h, "%TypedArray%": p, "%TypeError%": o, "%Uint8Array%": typeof Uint8Array == "undefined" ? r : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? r : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array == "undefined" ? r : Uint16Array, "%Uint32Array%": typeof Uint32Array == "undefined" ? r : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap == "undefined" ? r : WeakMap, "%WeakRef%": typeof WeakRef == "undefined" ? r : WeakRef, "%WeakSet%": typeof WeakSet == "undefined" ? r : WeakSet };
    try {
      null.error;
    } catch (e5) {
      var _ = f(f(e5));
      m["%Error.prototype%"] = _;
    }
    var g = function e(t2) {
      var i2;
      if (t2 === "%AsyncFunction%")
        i2 = s("async function () {}");
      else if (t2 === "%GeneratorFunction%")
        i2 = s("function* () {}");
      else if (t2 === "%AsyncGeneratorFunction%")
        i2 = s("async function* () {}");
      else if (t2 === "%AsyncGenerator%") {
        var r2 = e("%AsyncGeneratorFunction%");
        r2 && (i2 = r2.prototype);
      } else if (t2 === "%AsyncIteratorPrototype%") {
        var n2 = e("%AsyncGenerator%");
        n2 && (i2 = f(n2.prototype));
      }
      return m[t2] = i2, i2;
    }, b2 = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, y = e4("function-bind"), w = e4("has"), v = y.call(Function.call, Array.prototype.concat), x = y.call(Function.apply, Array.prototype.splice), E = y.call(Function.call, String.prototype.replace), k = y.call(Function.call, String.prototype.slice), S = y.call(Function.call, RegExp.prototype.exec), A = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, I = /\\(\\)?/g, M = function(e5) {
      var t2 = k(e5, 0, 1), i2 = k(e5, -1);
      if (t2 === "%" && i2 !== "%")
        throw new n("invalid intrinsic syntax, expected closing `%`");
      if (i2 === "%" && t2 !== "%")
        throw new n("invalid intrinsic syntax, expected opening `%`");
      var r2 = [];
      return E(e5, A, function(e6, t3, i3, n2) {
        r2[r2.length] = i3 ? E(n2, I, "$1") : t3 || e6;
      }), r2;
    }, T = function(e5, t2) {
      var i2, r2 = e5;
      if (w(b2, r2) && (r2 = "%" + (i2 = b2[r2])[0] + "%"), w(m, r2)) {
        var a2 = m[r2];
        if (a2 === d && (a2 = g(r2)), a2 === undefined && !t2)
          throw new o("intrinsic " + e5 + " exists, but is not available. Please file an issue!");
        return { alias: i2, name: r2, value: a2 };
      }
      throw new n("intrinsic " + e5 + " does not exist!");
    };
    t.exports = function(e5, t2) {
      if (typeof e5 != "string" || e5.length === 0)
        throw new o("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof t2 != "boolean")
        throw new o('"allowMissing" argument must be a boolean');
      if (S(/^%?[^%]*%?$/, e5) === null)
        throw new n("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var i2 = M(e5), r2 = i2.length > 0 ? i2[0] : "", a2 = T("%" + r2 + "%", t2), s2 = a2.name, u2 = a2.value, h2 = false, c2 = a2.alias;
      c2 && (r2 = c2[0], x(i2, v([0, 1], c2)));
      for (var f2 = 1, d2 = true;f2 < i2.length; f2 += 1) {
        var p2 = i2[f2], _2 = k(p2, 0, 1), g2 = k(p2, -1);
        if ((_2 === '"' || _2 === "'" || _2 === "`" || g2 === '"' || g2 === "'" || g2 === "`") && _2 !== g2)
          throw new n("property names with quotes must have matching quotes");
        if (p2 !== "constructor" && d2 || (h2 = true), w(m, s2 = "%" + (r2 += "." + p2) + "%"))
          u2 = m[s2];
        else if (u2 != null) {
          if (!(p2 in u2)) {
            if (!t2)
              throw new o("base intrinsic for " + e5 + " exists, but the property is not available.");
            return;
          }
          if (l && f2 + 1 >= i2.length) {
            var b3 = l(u2, p2);
            u2 = (d2 = !!b3) && "get" in b3 && !("originalValue" in b3.get) ? b3.get : u2[p2];
          } else
            d2 = w(u2, p2), u2 = u2[p2];
          d2 && !h2 && (m[s2] = u2);
        }
      }
      return u2;
    };
  }, { "function-bind": 38, has: 44, "has-symbols": 41 }], 40: [function(e4, t, i) {
    var r = e4("get-intrinsic")("%Object.getOwnPropertyDescriptor%", true);
    if (r)
      try {
        r([], "length");
      } catch (e5) {
        r = null;
      }
    t.exports = r;
  }, { "get-intrinsic": 39 }], 41: [function(e4, t, i) {
    var r = typeof Symbol != "undefined" && Symbol, n = e4("./shams");
    t.exports = function() {
      return typeof r == "function" && typeof Symbol == "function" && typeof r("foo") == "symbol" && typeof Symbol("bar") == "symbol" && n();
    };
  }, { "./shams": 42 }], 42: [function(e4, t, i) {
    t.exports = function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return false;
      if (typeof Symbol.iterator == "symbol")
        return true;
      var e5 = {}, t2 = Symbol("test"), i2 = Object(t2);
      if (typeof t2 == "string")
        return false;
      if (Object.prototype.toString.call(t2) !== "[object Symbol]")
        return false;
      if (Object.prototype.toString.call(i2) !== "[object Symbol]")
        return false;
      var r = 42;
      for (t2 in e5[t2] = r, e5)
        return false;
      if (typeof Object.keys == "function" && Object.keys(e5).length !== 0)
        return false;
      if (typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e5).length !== 0)
        return false;
      var n = Object.getOwnPropertySymbols(e5);
      if (n.length !== 1 || n[0] !== t2)
        return false;
      if (!Object.prototype.propertyIsEnumerable.call(e5, t2))
        return false;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var a = Object.getOwnPropertyDescriptor(e5, t2);
        if (a.value !== r || a.enumerable !== true)
          return false;
      }
      return true;
    };
  }, {}], 43: [function(e4, t, i) {
    var r = e4("has-symbols/shams");
    t.exports = function() {
      return r() && !!Symbol.toStringTag;
    };
  }, { "has-symbols/shams": 42 }], 44: [function(e4, t, i) {
    var r = e4("function-bind");
    t.exports = r.call(Function.call, Object.prototype.hasOwnProperty);
  }, { "function-bind": 38 }], 45: [function(e4, t, i) {
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    i.read = function(e5, t2, i2, r, n) {
      var a, o, s = 8 * n - r - 1, l = (1 << s) - 1, u = l >> 1, h = -7, c = i2 ? n - 1 : 0, f = i2 ? -1 : 1, d = e5[t2 + c];
      for (c += f, a = d & (1 << -h) - 1, d >>= -h, h += s;h > 0; a = 256 * a + e5[t2 + c], c += f, h -= 8)
        ;
      for (o = a & (1 << -h) - 1, a >>= -h, h += r;h > 0; o = 256 * o + e5[t2 + c], c += f, h -= 8)
        ;
      if (a === 0)
        a = 1 - u;
      else {
        if (a === l)
          return o ? NaN : 1 / 0 * (d ? -1 : 1);
        o += Math.pow(2, r), a -= u;
      }
      return (d ? -1 : 1) * o * Math.pow(2, a - r);
    }, i.write = function(e5, t2, i2, r, n, a) {
      var o, s, l, u = 8 * a - n - 1, h = (1 << u) - 1, c = h >> 1, f = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : a - 1, p = r ? 1 : -1, m = t2 < 0 || t2 === 0 && 1 / t2 < 0 ? 1 : 0;
      for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (s = isNaN(t2) ? 1 : 0, o = h) : (o = Math.floor(Math.log(t2) / Math.LN2), t2 * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), (t2 += o + c >= 1 ? f / l : f * Math.pow(2, 1 - c)) * l >= 2 && (o++, l /= 2), o + c >= h ? (s = 0, o = h) : o + c >= 1 ? (s = (t2 * l - 1) * Math.pow(2, n), o += c) : (s = t2 * Math.pow(2, c - 1) * Math.pow(2, n), o = 0));n >= 8; e5[i2 + d] = 255 & s, d += p, s /= 256, n -= 8)
        ;
      for (o = o << n | s, u += n;u > 0; e5[i2 + d] = 255 & o, d += p, o /= 256, u -= 8)
        ;
      e5[i2 + d - p] |= 128 * m;
    };
  }, {}], 46: [function(e4, t, i) {
    typeof Object.create == "function" ? t.exports = function(e5, t2) {
      t2 && (e5.super_ = t2, e5.prototype = Object.create(t2.prototype, { constructor: { value: e5, enumerable: false, writable: true, configurable: true } }));
    } : t.exports = function(e5, t2) {
      if (t2) {
        e5.super_ = t2;
        var i2 = function() {
        };
        i2.prototype = t2.prototype, e5.prototype = new i2, e5.prototype.constructor = e5;
      }
    };
  }, {}], 47: [function(e4, t, i) {
    var r = e4("has-tostringtag/shams")(), n = e4("call-bind/callBound")("Object.prototype.toString"), a = function(e5) {
      return !(r && e5 && typeof e5 == "object" && (Symbol.toStringTag in e5)) && n(e5) === "[object Arguments]";
    }, o = function(e5) {
      return !!a(e5) || e5 !== null && typeof e5 == "object" && typeof e5.length == "number" && e5.length >= 0 && n(e5) !== "[object Array]" && n(e5.callee) === "[object Function]";
    }, s = function() {
      return a(arguments);
    }();
    a.isLegacyArguments = o, t.exports = s ? a : o;
  }, { "call-bind/callBound": 33, "has-tostringtag/shams": 43 }], 48: [function(e4, t, i) {
    var r, n, a = Function.prototype.toString, o = typeof Reflect == "object" && Reflect !== null && Reflect.apply;
    if (typeof o == "function" && typeof Object.defineProperty == "function")
      try {
        r = Object.defineProperty({}, "length", { get: function() {
          throw n;
        } }), n = {}, o(function() {
          throw 42;
        }, null, r);
      } catch (e5) {
        e5 !== n && (o = null);
      }
    else
      o = null;
    var s = /^\s*class\b/, l = function(e5) {
      try {
        var t2 = a.call(e5);
        return s.test(t2);
      } catch (e6) {
        return false;
      }
    }, u = function(e5) {
      try {
        return !l(e5) && (a.call(e5), true);
      } catch (e6) {
        return false;
      }
    }, h = Object.prototype.toString, c = "[object Object]", f = "[object Function]", d = "[object GeneratorFunction]", p = "[object HTMLAllCollection]", m = "[object HTML document.all class]", _ = "[object HTMLCollection]", g = typeof Symbol == "function" && !!Symbol.toStringTag, b2 = !(0 in [,]), y = function() {
      return false;
    };
    if (typeof document == "object") {
      var w = document.all;
      h.call(w) === h.call(document.all) && (y = function(e5) {
        if ((b2 || !e5) && (e5 === undefined || typeof e5 == "object"))
          try {
            var t2 = h.call(e5);
            return (t2 === p || t2 === m || t2 === _ || t2 === c) && e5("") == null;
          } catch (e6) {
          }
        return false;
      });
    }
    t.exports = o ? function(e5) {
      if (y(e5))
        return true;
      if (!e5)
        return false;
      if (typeof e5 != "function" && typeof e5 != "object")
        return false;
      try {
        o(e5, null, r);
      } catch (e6) {
        if (e6 !== n)
          return false;
      }
      return !l(e5) && u(e5);
    } : function(e5) {
      if (y(e5))
        return true;
      if (!e5)
        return false;
      if (typeof e5 != "function" && typeof e5 != "object")
        return false;
      if (g)
        return u(e5);
      if (l(e5))
        return false;
      var t2 = h.call(e5);
      return !(t2 !== f && t2 !== d && !/^\[object HTML/.test(t2)) && u(e5);
    };
  }, {}], 49: [function(e4, t, i) {
    var r, n = Object.prototype.toString, a = Function.prototype.toString, o = /^\s*(?:function)?\*/, s = e4("has-tostringtag/shams")(), l = Object.getPrototypeOf, u = function() {
      if (!s)
        return false;
      try {
        return Function("return function*() {}")();
      } catch (e5) {
      }
    };
    t.exports = function(e5) {
      if (typeof e5 != "function")
        return false;
      if (o.test(a.call(e5)))
        return true;
      if (!s)
        return n.call(e5) === "[object GeneratorFunction]";
      if (!l)
        return false;
      if (r === undefined) {
        var t2 = u();
        r = !!t2 && l(t2);
      }
      return l(e5) === r;
    };
  }, { "has-tostringtag/shams": 43 }], 50: [function(e4, t, i) {
    (function(i2) {
      (function() {
        var r = e4("for-each"), n = e4("available-typed-arrays"), a = e4("call-bind/callBound"), o = a("Object.prototype.toString"), s = e4("has-tostringtag/shams")(), l = e4("gopd"), u = typeof globalThis == "undefined" ? i2 : globalThis, h = n(), c = a("Array.prototype.indexOf", true) || function(e5, t2) {
          for (var i3 = 0;i3 < e5.length; i3 += 1)
            if (e5[i3] === t2)
              return i3;
          return -1;
        }, f = a("String.prototype.slice"), d = {}, p = Object.getPrototypeOf;
        s && l && p && r(h, function(e5) {
          var t2 = new u[e5];
          if (Symbol.toStringTag in t2) {
            var i3 = p(t2), r2 = l(i3, Symbol.toStringTag);
            if (!r2) {
              var n2 = p(i3);
              r2 = l(n2, Symbol.toStringTag);
            }
            d[e5] = r2.get;
          }
        });
        var m = function(e5) {
          var t2 = false;
          return r(d, function(i3, r2) {
            if (!t2)
              try {
                t2 = i3.call(e5) === r2;
              } catch (e6) {
              }
          }), t2;
        };
        t.exports = function(e5) {
          if (!e5 || typeof e5 != "object")
            return false;
          if (!s || !(Symbol.toStringTag in e5)) {
            var t2 = f(o(e5), 8, -1);
            return c(h, t2) > -1;
          }
          return !!l && m(e5);
        };
      }).call(this);
    }).call(this, commonjsGlobal !== undefined ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { "available-typed-arrays": 27, "call-bind/callBound": 33, "for-each": 36, gopd: 40, "has-tostringtag/shams": 43 }], 51: [function(e4, t, i) {
    var r = Object.getOwnPropertySymbols, n = Object.prototype.hasOwnProperty, a = Object.prototype.propertyIsEnumerable;
    function o(e5) {
      if (e5 == null)
        throw new TypeError("Object.assign cannot be called with null or undefined");
      return Object(e5);
    }
    function s() {
      try {
        if (!Object.assign)
          return false;
        var e5 = new String("abc");
        if (e5[5] = "de", Object.getOwnPropertyNames(e5)[0] === "5")
          return false;
        for (var t2 = {}, i2 = 0;i2 < 10; i2++)
          t2["_" + String.fromCharCode(i2)] = i2;
        var r2 = Object.getOwnPropertyNames(t2).map(function(e6) {
          return t2[e6];
        });
        if (r2.join("") !== "0123456789")
          return false;
        var n2 = {};
        return "abcdefghijklmnopqrst".split("").forEach(function(e6) {
          n2[e6] = e6;
        }), Object.keys(Object.assign({}, n2)).join("") === "abcdefghijklmnopqrst";
      } catch (e6) {
        return false;
      }
    }
    t.exports = s() ? Object.assign : function(e5, t2) {
      for (var i2, s2, l = o(e5), u = 1;u < arguments.length; u++) {
        for (var h in i2 = Object(arguments[u]))
          n.call(i2, h) && (l[h] = i2[h]);
        if (r) {
          s2 = r(i2);
          for (var c = 0;c < s2.length; c++)
            a.call(i2, s2[c]) && (l[s2[c]] = i2[s2[c]]);
        }
      }
      return l;
    };
  }, {}], 52: [function(e4, t, i) {
    var r = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
    function n(e5, t2) {
      return Object.prototype.hasOwnProperty.call(e5, t2);
    }
    i.assign = function(e5) {
      for (var t2 = Array.prototype.slice.call(arguments, 1);t2.length; ) {
        var i2 = t2.shift();
        if (i2) {
          if (typeof i2 != "object")
            throw new TypeError(i2 + "must be non-object");
          for (var r2 in i2)
            n(i2, r2) && (e5[r2] = i2[r2]);
        }
      }
      return e5;
    }, i.shrinkBuf = function(e5, t2) {
      return e5.length === t2 ? e5 : e5.subarray ? e5.subarray(0, t2) : (e5.length = t2, e5);
    };
    var a = { arraySet: function(e5, t2, i2, r2, n2) {
      if (t2.subarray && e5.subarray)
        e5.set(t2.subarray(i2, i2 + r2), n2);
      else
        for (var a2 = 0;a2 < r2; a2++)
          e5[n2 + a2] = t2[i2 + a2];
    }, flattenChunks: function(e5) {
      var t2, i2, r2, n2, a2, o2;
      for (r2 = 0, t2 = 0, i2 = e5.length;t2 < i2; t2++)
        r2 += e5[t2].length;
      for (o2 = new Uint8Array(r2), n2 = 0, t2 = 0, i2 = e5.length;t2 < i2; t2++)
        a2 = e5[t2], o2.set(a2, n2), n2 += a2.length;
      return o2;
    } }, o = { arraySet: function(e5, t2, i2, r2, n2) {
      for (var a2 = 0;a2 < r2; a2++)
        e5[n2 + a2] = t2[i2 + a2];
    }, flattenChunks: function(e5) {
      return [].concat.apply([], e5);
    } };
    i.setTyped = function(e5) {
      e5 ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, a)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, o));
    }, i.setTyped(r);
  }, {}], 53: [function(e4, t, i) {
    function r(e5, t2, i2, r2) {
      for (var n = 65535 & e5, a = e5 >>> 16 & 65535, o = 0;i2 !== 0; ) {
        i2 -= o = i2 > 2000 ? 2000 : i2;
        do {
          a = a + (n = n + t2[r2++] | 0) | 0;
        } while (--o);
        n %= 65521, a %= 65521;
      }
      return n | a << 16;
    }
    t.exports = r;
  }, {}], 54: [function(e4, t, i) {
    t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
  }, {}], 55: [function(e4, t, i) {
    function r() {
      for (var e5, t2 = [], i2 = 0;i2 < 256; i2++) {
        e5 = i2;
        for (var r2 = 0;r2 < 8; r2++)
          e5 = 1 & e5 ? 3988292384 ^ e5 >>> 1 : e5 >>> 1;
        t2[i2] = e5;
      }
      return t2;
    }
    var n = r();
    function a(e5, t2, i2, r2) {
      var a2 = n, o = r2 + i2;
      e5 ^= -1;
      for (var s = r2;s < o; s++)
        e5 = e5 >>> 8 ^ a2[255 & (e5 ^ t2[s])];
      return ~e5;
    }
    t.exports = a;
  }, {}], 56: [function(e4, t, i) {
    var r, n = e4("../utils/common"), a = e4("./trees"), o = e4("./adler32"), s = e4("./crc32"), l = e4("./messages"), u = 0, h = 1, c = 3, f = 4, d = 5, p = 0, m = 1, _ = -2, g = -3, b2 = -5, y = -1, w = 1, v = 2, x = 3, E = 4, k = 0, S = 2, A = 8, I = 9, M = 15, T = 8, P = 286, B = 30, C = 19, R = 2 * P + 1, z = 15, F = 3, N = 258, O = N + F + 1, D = 32, $ = 42, L = 69, U = 73, Z = 91, j = 103, G = 113, H = 666, Q = 1, W = 2, q = 3, V = 4, Y = 3;
    function K(e5, t2) {
      return e5.msg = l[t2], t2;
    }
    function J(e5) {
      return (e5 << 1) - (e5 > 4 ? 9 : 0);
    }
    function X(e5) {
      for (var t2 = e5.length;--t2 >= 0; )
        e5[t2] = 0;
    }
    function ee(e5) {
      var t2 = e5.state, i2 = t2.pending;
      i2 > e5.avail_out && (i2 = e5.avail_out), i2 !== 0 && (n.arraySet(e5.output, t2.pending_buf, t2.pending_out, i2, e5.next_out), e5.next_out += i2, t2.pending_out += i2, e5.total_out += i2, e5.avail_out -= i2, t2.pending -= i2, t2.pending === 0 && (t2.pending_out = 0));
    }
    function te(e5, t2) {
      a._tr_flush_block(e5, e5.block_start >= 0 ? e5.block_start : -1, e5.strstart - e5.block_start, t2), e5.block_start = e5.strstart, ee(e5.strm);
    }
    function ie(e5, t2) {
      e5.pending_buf[e5.pending++] = t2;
    }
    function re(e5, t2) {
      e5.pending_buf[e5.pending++] = t2 >>> 8 & 255, e5.pending_buf[e5.pending++] = 255 & t2;
    }
    function ne(e5, t2, i2, r2) {
      var a2 = e5.avail_in;
      return a2 > r2 && (a2 = r2), a2 === 0 ? 0 : (e5.avail_in -= a2, n.arraySet(t2, e5.input, e5.next_in, a2, i2), e5.state.wrap === 1 ? e5.adler = o(e5.adler, t2, a2, i2) : e5.state.wrap === 2 && (e5.adler = s(e5.adler, t2, a2, i2)), e5.next_in += a2, e5.total_in += a2, a2);
    }
    function ae(e5, t2) {
      var i2, r2, n2 = e5.max_chain_length, a2 = e5.strstart, o2 = e5.prev_length, s2 = e5.nice_match, l2 = e5.strstart > e5.w_size - O ? e5.strstart - (e5.w_size - O) : 0, u2 = e5.window, h2 = e5.w_mask, c2 = e5.prev, f2 = e5.strstart + N, d2 = u2[a2 + o2 - 1], p2 = u2[a2 + o2];
      e5.prev_length >= e5.good_match && (n2 >>= 2), s2 > e5.lookahead && (s2 = e5.lookahead);
      do {
        if (u2[(i2 = t2) + o2] === p2 && u2[i2 + o2 - 1] === d2 && u2[i2] === u2[a2] && u2[++i2] === u2[a2 + 1]) {
          a2 += 2, i2++;
          do {
          } while (u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && u2[++a2] === u2[++i2] && a2 < f2);
          if (r2 = N - (f2 - a2), a2 = f2 - N, r2 > o2) {
            if (e5.match_start = t2, o2 = r2, r2 >= s2)
              break;
            d2 = u2[a2 + o2 - 1], p2 = u2[a2 + o2];
          }
        }
      } while ((t2 = c2[t2 & h2]) > l2 && --n2 != 0);
      return o2 <= e5.lookahead ? o2 : e5.lookahead;
    }
    function oe(e5) {
      var t2, i2, r2, a2, o2, s2 = e5.w_size;
      do {
        if (a2 = e5.window_size - e5.lookahead - e5.strstart, e5.strstart >= s2 + (s2 - O)) {
          n.arraySet(e5.window, e5.window, s2, s2, 0), e5.match_start -= s2, e5.strstart -= s2, e5.block_start -= s2, t2 = i2 = e5.hash_size;
          do {
            r2 = e5.head[--t2], e5.head[t2] = r2 >= s2 ? r2 - s2 : 0;
          } while (--i2);
          t2 = i2 = s2;
          do {
            r2 = e5.prev[--t2], e5.prev[t2] = r2 >= s2 ? r2 - s2 : 0;
          } while (--i2);
          a2 += s2;
        }
        if (e5.strm.avail_in === 0)
          break;
        if (i2 = ne(e5.strm, e5.window, e5.strstart + e5.lookahead, a2), e5.lookahead += i2, e5.lookahead + e5.insert >= F)
          for (o2 = e5.strstart - e5.insert, e5.ins_h = e5.window[o2], e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[o2 + 1]) & e5.hash_mask;e5.insert && (e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[o2 + F - 1]) & e5.hash_mask, e5.prev[o2 & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = o2, o2++, e5.insert--, !(e5.lookahead + e5.insert < F)); )
            ;
      } while (e5.lookahead < O && e5.strm.avail_in !== 0);
    }
    function se(e5, t2) {
      var i2 = 65535;
      for (i2 > e5.pending_buf_size - 5 && (i2 = e5.pending_buf_size - 5);; ) {
        if (e5.lookahead <= 1) {
          if (oe(e5), e5.lookahead === 0 && t2 === u)
            return Q;
          if (e5.lookahead === 0)
            break;
        }
        e5.strstart += e5.lookahead, e5.lookahead = 0;
        var r2 = e5.block_start + i2;
        if ((e5.strstart === 0 || e5.strstart >= r2) && (e5.lookahead = e5.strstart - r2, e5.strstart = r2, te(e5, false), e5.strm.avail_out === 0))
          return Q;
        if (e5.strstart - e5.block_start >= e5.w_size - O && (te(e5, false), e5.strm.avail_out === 0))
          return Q;
      }
      return e5.insert = 0, t2 === f ? (te(e5, true), e5.strm.avail_out === 0 ? q : V) : (e5.strstart > e5.block_start && (te(e5, false), e5.strm.avail_out), Q);
    }
    function le(e5, t2) {
      for (var i2, r2;; ) {
        if (e5.lookahead < O) {
          if (oe(e5), e5.lookahead < O && t2 === u)
            return Q;
          if (e5.lookahead === 0)
            break;
        }
        if (i2 = 0, e5.lookahead >= F && (e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + F - 1]) & e5.hash_mask, i2 = e5.prev[e5.strstart & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = e5.strstart), i2 !== 0 && e5.strstart - i2 <= e5.w_size - O && (e5.match_length = ae(e5, i2)), e5.match_length >= F)
          if (r2 = a._tr_tally(e5, e5.strstart - e5.match_start, e5.match_length - F), e5.lookahead -= e5.match_length, e5.match_length <= e5.max_lazy_match && e5.lookahead >= F) {
            e5.match_length--;
            do {
              e5.strstart++, e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + F - 1]) & e5.hash_mask, i2 = e5.prev[e5.strstart & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = e5.strstart;
            } while (--e5.match_length != 0);
            e5.strstart++;
          } else
            e5.strstart += e5.match_length, e5.match_length = 0, e5.ins_h = e5.window[e5.strstart], e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + 1]) & e5.hash_mask;
        else
          r2 = a._tr_tally(e5, 0, e5.window[e5.strstart]), e5.lookahead--, e5.strstart++;
        if (r2 && (te(e5, false), e5.strm.avail_out === 0))
          return Q;
      }
      return e5.insert = e5.strstart < F - 1 ? e5.strstart : F - 1, t2 === f ? (te(e5, true), e5.strm.avail_out === 0 ? q : V) : e5.last_lit && (te(e5, false), e5.strm.avail_out === 0) ? Q : W;
    }
    function ue(e5, t2) {
      for (var i2, r2, n2;; ) {
        if (e5.lookahead < O) {
          if (oe(e5), e5.lookahead < O && t2 === u)
            return Q;
          if (e5.lookahead === 0)
            break;
        }
        if (i2 = 0, e5.lookahead >= F && (e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + F - 1]) & e5.hash_mask, i2 = e5.prev[e5.strstart & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = e5.strstart), e5.prev_length = e5.match_length, e5.prev_match = e5.match_start, e5.match_length = F - 1, i2 !== 0 && e5.prev_length < e5.max_lazy_match && e5.strstart - i2 <= e5.w_size - O && (e5.match_length = ae(e5, i2), e5.match_length <= 5 && (e5.strategy === w || e5.match_length === F && e5.strstart - e5.match_start > 4096) && (e5.match_length = F - 1)), e5.prev_length >= F && e5.match_length <= e5.prev_length) {
          n2 = e5.strstart + e5.lookahead - F, r2 = a._tr_tally(e5, e5.strstart - 1 - e5.prev_match, e5.prev_length - F), e5.lookahead -= e5.prev_length - 1, e5.prev_length -= 2;
          do {
            ++e5.strstart <= n2 && (e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + F - 1]) & e5.hash_mask, i2 = e5.prev[e5.strstart & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = e5.strstart);
          } while (--e5.prev_length != 0);
          if (e5.match_available = 0, e5.match_length = F - 1, e5.strstart++, r2 && (te(e5, false), e5.strm.avail_out === 0))
            return Q;
        } else if (e5.match_available) {
          if ((r2 = a._tr_tally(e5, 0, e5.window[e5.strstart - 1])) && te(e5, false), e5.strstart++, e5.lookahead--, e5.strm.avail_out === 0)
            return Q;
        } else
          e5.match_available = 1, e5.strstart++, e5.lookahead--;
      }
      return e5.match_available && (r2 = a._tr_tally(e5, 0, e5.window[e5.strstart - 1]), e5.match_available = 0), e5.insert = e5.strstart < F - 1 ? e5.strstart : F - 1, t2 === f ? (te(e5, true), e5.strm.avail_out === 0 ? q : V) : e5.last_lit && (te(e5, false), e5.strm.avail_out === 0) ? Q : W;
    }
    function he(e5, t2) {
      for (var i2, r2, n2, o2, s2 = e5.window;; ) {
        if (e5.lookahead <= N) {
          if (oe(e5), e5.lookahead <= N && t2 === u)
            return Q;
          if (e5.lookahead === 0)
            break;
        }
        if (e5.match_length = 0, e5.lookahead >= F && e5.strstart > 0 && (r2 = s2[n2 = e5.strstart - 1]) === s2[++n2] && r2 === s2[++n2] && r2 === s2[++n2]) {
          o2 = e5.strstart + N;
          do {
          } while (r2 === s2[++n2] && r2 === s2[++n2] && r2 === s2[++n2] && r2 === s2[++n2] && r2 === s2[++n2] && r2 === s2[++n2] && r2 === s2[++n2] && r2 === s2[++n2] && n2 < o2);
          e5.match_length = N - (o2 - n2), e5.match_length > e5.lookahead && (e5.match_length = e5.lookahead);
        }
        if (e5.match_length >= F ? (i2 = a._tr_tally(e5, 1, e5.match_length - F), e5.lookahead -= e5.match_length, e5.strstart += e5.match_length, e5.match_length = 0) : (i2 = a._tr_tally(e5, 0, e5.window[e5.strstart]), e5.lookahead--, e5.strstart++), i2 && (te(e5, false), e5.strm.avail_out === 0))
          return Q;
      }
      return e5.insert = 0, t2 === f ? (te(e5, true), e5.strm.avail_out === 0 ? q : V) : e5.last_lit && (te(e5, false), e5.strm.avail_out === 0) ? Q : W;
    }
    function ce(e5, t2) {
      for (var i2;; ) {
        if (e5.lookahead === 0 && (oe(e5), e5.lookahead === 0)) {
          if (t2 === u)
            return Q;
          break;
        }
        if (e5.match_length = 0, i2 = a._tr_tally(e5, 0, e5.window[e5.strstart]), e5.lookahead--, e5.strstart++, i2 && (te(e5, false), e5.strm.avail_out === 0))
          return Q;
      }
      return e5.insert = 0, t2 === f ? (te(e5, true), e5.strm.avail_out === 0 ? q : V) : e5.last_lit && (te(e5, false), e5.strm.avail_out === 0) ? Q : W;
    }
    function fe(e5, t2, i2, r2, n2) {
      this.good_length = e5, this.max_lazy = t2, this.nice_length = i2, this.max_chain = r2, this.func = n2;
    }
    function de(e5) {
      e5.window_size = 2 * e5.w_size, X(e5.head), e5.max_lazy_match = r[e5.level].max_lazy, e5.good_match = r[e5.level].good_length, e5.nice_match = r[e5.level].nice_length, e5.max_chain_length = r[e5.level].max_chain, e5.strstart = 0, e5.block_start = 0, e5.lookahead = 0, e5.insert = 0, e5.match_length = e5.prev_length = F - 1, e5.match_available = 0, e5.ins_h = 0;
    }
    function pe() {
      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = A, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new n.Buf16(2 * R), this.dyn_dtree = new n.Buf16(2 * (2 * B + 1)), this.bl_tree = new n.Buf16(2 * (2 * C + 1)), X(this.dyn_ltree), X(this.dyn_dtree), X(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new n.Buf16(z + 1), this.heap = new n.Buf16(2 * P + 1), X(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new n.Buf16(2 * P + 1), X(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
    }
    function me(e5) {
      var t2;
      return e5 && e5.state ? (e5.total_in = e5.total_out = 0, e5.data_type = S, (t2 = e5.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? $ : G, e5.adler = t2.wrap === 2 ? 0 : 1, t2.last_flush = u, a._tr_init(t2), p) : K(e5, _);
    }
    function _e(e5) {
      var t2 = me(e5);
      return t2 === p && de(e5.state), t2;
    }
    function ge(e5, t2) {
      return e5 && e5.state ? e5.state.wrap !== 2 ? _ : (e5.state.gzhead = t2, p) : _;
    }
    function be(e5, t2, i2, r2, a2, o2) {
      if (!e5)
        return _;
      var s2 = 1;
      if (t2 === y && (t2 = 6), r2 < 0 ? (s2 = 0, r2 = -r2) : r2 > 15 && (s2 = 2, r2 -= 16), a2 < 1 || a2 > I || i2 !== A || r2 < 8 || r2 > 15 || t2 < 0 || t2 > 9 || o2 < 0 || o2 > E)
        return K(e5, _);
      r2 === 8 && (r2 = 9);
      var l2 = new pe;
      return e5.state = l2, l2.strm = e5, l2.wrap = s2, l2.gzhead = null, l2.w_bits = r2, l2.w_size = 1 << l2.w_bits, l2.w_mask = l2.w_size - 1, l2.hash_bits = a2 + 7, l2.hash_size = 1 << l2.hash_bits, l2.hash_mask = l2.hash_size - 1, l2.hash_shift = ~~((l2.hash_bits + F - 1) / F), l2.window = new n.Buf8(2 * l2.w_size), l2.head = new n.Buf16(l2.hash_size), l2.prev = new n.Buf16(l2.w_size), l2.lit_bufsize = 1 << a2 + 6, l2.pending_buf_size = 4 * l2.lit_bufsize, l2.pending_buf = new n.Buf8(l2.pending_buf_size), l2.d_buf = 1 * l2.lit_bufsize, l2.l_buf = 3 * l2.lit_bufsize, l2.level = t2, l2.strategy = o2, l2.method = i2, _e(e5);
    }
    function ye(e5, t2) {
      return be(e5, t2, A, M, T, k);
    }
    function we(e5, t2) {
      var i2, n2, o2, l2;
      if (!e5 || !e5.state || t2 > d || t2 < 0)
        return e5 ? K(e5, _) : _;
      if (n2 = e5.state, !e5.output || !e5.input && e5.avail_in !== 0 || n2.status === H && t2 !== f)
        return K(e5, e5.avail_out === 0 ? b2 : _);
      if (n2.strm = e5, i2 = n2.last_flush, n2.last_flush = t2, n2.status === $)
        if (n2.wrap === 2)
          e5.adler = 0, ie(n2, 31), ie(n2, 139), ie(n2, 8), n2.gzhead ? (ie(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), ie(n2, 255 & n2.gzhead.time), ie(n2, n2.gzhead.time >> 8 & 255), ie(n2, n2.gzhead.time >> 16 & 255), ie(n2, n2.gzhead.time >> 24 & 255), ie(n2, n2.level === 9 ? 2 : n2.strategy >= v || n2.level < 2 ? 4 : 0), ie(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (ie(n2, 255 & n2.gzhead.extra.length), ie(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e5.adler = s(e5.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = L) : (ie(n2, 0), ie(n2, 0), ie(n2, 0), ie(n2, 0), ie(n2, 0), ie(n2, n2.level === 9 ? 2 : n2.strategy >= v || n2.level < 2 ? 4 : 0), ie(n2, Y), n2.status = G);
        else {
          var g2 = A + (n2.w_bits - 8 << 4) << 8;
          g2 |= (n2.strategy >= v || n2.level < 2 ? 0 : n2.level < 6 ? 1 : n2.level === 6 ? 2 : 3) << 6, n2.strstart !== 0 && (g2 |= D), g2 += 31 - g2 % 31, n2.status = G, re(n2, g2), n2.strstart !== 0 && (re(n2, e5.adler >>> 16), re(n2, 65535 & e5.adler)), e5.adler = 1;
        }
      if (n2.status === L)
        if (n2.gzhead.extra) {
          for (o2 = n2.pending;n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > o2 && (e5.adler = s(e5.adler, n2.pending_buf, n2.pending - o2, o2)), ee(e5), o2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
            ie(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
          n2.gzhead.hcrc && n2.pending > o2 && (e5.adler = s(e5.adler, n2.pending_buf, n2.pending - o2, o2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = U);
        } else
          n2.status = U;
      if (n2.status === U)
        if (n2.gzhead.name) {
          o2 = n2.pending;
          do {
            if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > o2 && (e5.adler = s(e5.adler, n2.pending_buf, n2.pending - o2, o2)), ee(e5), o2 = n2.pending, n2.pending === n2.pending_buf_size)) {
              l2 = 1;
              break;
            }
            l2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, ie(n2, l2);
          } while (l2 !== 0);
          n2.gzhead.hcrc && n2.pending > o2 && (e5.adler = s(e5.adler, n2.pending_buf, n2.pending - o2, o2)), l2 === 0 && (n2.gzindex = 0, n2.status = Z);
        } else
          n2.status = Z;
      if (n2.status === Z)
        if (n2.gzhead.comment) {
          o2 = n2.pending;
          do {
            if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > o2 && (e5.adler = s(e5.adler, n2.pending_buf, n2.pending - o2, o2)), ee(e5), o2 = n2.pending, n2.pending === n2.pending_buf_size)) {
              l2 = 1;
              break;
            }
            l2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, ie(n2, l2);
          } while (l2 !== 0);
          n2.gzhead.hcrc && n2.pending > o2 && (e5.adler = s(e5.adler, n2.pending_buf, n2.pending - o2, o2)), l2 === 0 && (n2.status = j);
        } else
          n2.status = j;
      if (n2.status === j && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && ee(e5), n2.pending + 2 <= n2.pending_buf_size && (ie(n2, 255 & e5.adler), ie(n2, e5.adler >> 8 & 255), e5.adler = 0, n2.status = G)) : n2.status = G), n2.pending !== 0) {
        if (ee(e5), e5.avail_out === 0)
          return n2.last_flush = -1, p;
      } else if (e5.avail_in === 0 && J(t2) <= J(i2) && t2 !== f)
        return K(e5, b2);
      if (n2.status === H && e5.avail_in !== 0)
        return K(e5, b2);
      if (e5.avail_in !== 0 || n2.lookahead !== 0 || t2 !== u && n2.status !== H) {
        var y2 = n2.strategy === v ? ce(n2, t2) : n2.strategy === x ? he(n2, t2) : r[n2.level].func(n2, t2);
        if (y2 !== q && y2 !== V || (n2.status = H), y2 === Q || y2 === q)
          return e5.avail_out === 0 && (n2.last_flush = -1), p;
        if (y2 === W && (t2 === h ? a._tr_align(n2) : t2 !== d && (a._tr_stored_block(n2, 0, 0, false), t2 === c && (X(n2.head), n2.lookahead === 0 && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), ee(e5), e5.avail_out === 0))
          return n2.last_flush = -1, p;
      }
      return t2 !== f ? p : n2.wrap <= 0 ? m : (n2.wrap === 2 ? (ie(n2, 255 & e5.adler), ie(n2, e5.adler >> 8 & 255), ie(n2, e5.adler >> 16 & 255), ie(n2, e5.adler >> 24 & 255), ie(n2, 255 & e5.total_in), ie(n2, e5.total_in >> 8 & 255), ie(n2, e5.total_in >> 16 & 255), ie(n2, e5.total_in >> 24 & 255)) : (re(n2, e5.adler >>> 16), re(n2, 65535 & e5.adler)), ee(e5), n2.wrap > 0 && (n2.wrap = -n2.wrap), n2.pending !== 0 ? p : m);
    }
    function ve(e5) {
      var t2;
      return e5 && e5.state ? (t2 = e5.state.status) !== $ && t2 !== L && t2 !== U && t2 !== Z && t2 !== j && t2 !== G && t2 !== H ? K(e5, _) : (e5.state = null, t2 === G ? K(e5, g) : p) : _;
    }
    function xe(e5, t2) {
      var i2, r2, a2, s2, l2, u2, h2, c2, f2 = t2.length;
      if (!e5 || !e5.state)
        return _;
      if ((s2 = (i2 = e5.state).wrap) === 2 || s2 === 1 && i2.status !== $ || i2.lookahead)
        return _;
      for (s2 === 1 && (e5.adler = o(e5.adler, t2, f2, 0)), i2.wrap = 0, f2 >= i2.w_size && (s2 === 0 && (X(i2.head), i2.strstart = 0, i2.block_start = 0, i2.insert = 0), c2 = new n.Buf8(i2.w_size), n.arraySet(c2, t2, f2 - i2.w_size, i2.w_size, 0), t2 = c2, f2 = i2.w_size), l2 = e5.avail_in, u2 = e5.next_in, h2 = e5.input, e5.avail_in = f2, e5.next_in = 0, e5.input = t2, oe(i2);i2.lookahead >= F; ) {
        r2 = i2.strstart, a2 = i2.lookahead - (F - 1);
        do {
          i2.ins_h = (i2.ins_h << i2.hash_shift ^ i2.window[r2 + F - 1]) & i2.hash_mask, i2.prev[r2 & i2.w_mask] = i2.head[i2.ins_h], i2.head[i2.ins_h] = r2, r2++;
        } while (--a2);
        i2.strstart = r2, i2.lookahead = F - 1, oe(i2);
      }
      return i2.strstart += i2.lookahead, i2.block_start = i2.strstart, i2.insert = i2.lookahead, i2.lookahead = 0, i2.match_length = i2.prev_length = F - 1, i2.match_available = 0, e5.next_in = u2, e5.input = h2, e5.avail_in = l2, i2.wrap = s2, p;
    }
    r = [new fe(0, 0, 0, 0, se), new fe(4, 4, 8, 4, le), new fe(4, 5, 16, 8, le), new fe(4, 6, 32, 32, le), new fe(4, 4, 16, 16, ue), new fe(8, 16, 32, 32, ue), new fe(8, 16, 128, 128, ue), new fe(8, 32, 128, 256, ue), new fe(32, 128, 258, 1024, ue), new fe(32, 258, 258, 4096, ue)], i.deflateInit = ye, i.deflateInit2 = be, i.deflateReset = _e, i.deflateResetKeep = me, i.deflateSetHeader = ge, i.deflate = we, i.deflateEnd = ve, i.deflateSetDictionary = xe, i.deflateInfo = "pako deflate (from Nodeca project)";
  }, { "../utils/common": 52, "./adler32": 53, "./crc32": 55, "./messages": 60, "./trees": 61 }], 57: [function(e4, t, i) {
    var r = 30, n = 12;
    t.exports = function(e5, t2) {
      var i2, a, o, s, l, u, h, c, f, d, p, m, _, g, b2, y, w, v, x, E, k, S, A, I, M;
      i2 = e5.state, a = e5.next_in, I = e5.input, o = a + (e5.avail_in - 5), s = e5.next_out, M = e5.output, l = s - (t2 - e5.avail_out), u = s + (e5.avail_out - 257), h = i2.dmax, c = i2.wsize, f = i2.whave, d = i2.wnext, p = i2.window, m = i2.hold, _ = i2.bits, g = i2.lencode, b2 = i2.distcode, y = (1 << i2.lenbits) - 1, w = (1 << i2.distbits) - 1;
      e:
        do {
          _ < 15 && (m += I[a++] << _, _ += 8, m += I[a++] << _, _ += 8), v = g[m & y];
          t:
            for (;; ) {
              if (m >>>= x = v >>> 24, _ -= x, (x = v >>> 16 & 255) == 0)
                M[s++] = 65535 & v;
              else {
                if (!(16 & x)) {
                  if (64 & x) {
                    if (32 & x) {
                      i2.mode = n;
                      break e;
                    }
                    e5.msg = "invalid literal/length code", i2.mode = r;
                    break e;
                  }
                  v = g[(65535 & v) + (m & (1 << x) - 1)];
                  continue t;
                }
                for (E = 65535 & v, (x &= 15) && (_ < x && (m += I[a++] << _, _ += 8), E += m & (1 << x) - 1, m >>>= x, _ -= x), _ < 15 && (m += I[a++] << _, _ += 8, m += I[a++] << _, _ += 8), v = b2[m & w];; ) {
                  if (m >>>= x = v >>> 24, _ -= x, 16 & (x = v >>> 16 & 255)) {
                    if (k = 65535 & v, _ < (x &= 15) && (m += I[a++] << _, (_ += 8) < x && (m += I[a++] << _, _ += 8)), (k += m & (1 << x) - 1) > h) {
                      e5.msg = "invalid distance too far back", i2.mode = r;
                      break e;
                    }
                    if (m >>>= x, _ -= x, k > (x = s - l)) {
                      if ((x = k - x) > f && i2.sane) {
                        e5.msg = "invalid distance too far back", i2.mode = r;
                        break e;
                      }
                      if (S = 0, A = p, d === 0) {
                        if (S += c - x, x < E) {
                          E -= x;
                          do {
                            M[s++] = p[S++];
                          } while (--x);
                          S = s - k, A = M;
                        }
                      } else if (d < x) {
                        if (S += c + d - x, (x -= d) < E) {
                          E -= x;
                          do {
                            M[s++] = p[S++];
                          } while (--x);
                          if (S = 0, d < E) {
                            E -= x = d;
                            do {
                              M[s++] = p[S++];
                            } while (--x);
                            S = s - k, A = M;
                          }
                        }
                      } else if (S += d - x, x < E) {
                        E -= x;
                        do {
                          M[s++] = p[S++];
                        } while (--x);
                        S = s - k, A = M;
                      }
                      for (;E > 2; )
                        M[s++] = A[S++], M[s++] = A[S++], M[s++] = A[S++], E -= 3;
                      E && (M[s++] = A[S++], E > 1 && (M[s++] = A[S++]));
                    } else {
                      S = s - k;
                      do {
                        M[s++] = M[S++], M[s++] = M[S++], M[s++] = M[S++], E -= 3;
                      } while (E > 2);
                      E && (M[s++] = M[S++], E > 1 && (M[s++] = M[S++]));
                    }
                    break;
                  }
                  if (64 & x) {
                    e5.msg = "invalid distance code", i2.mode = r;
                    break e;
                  }
                  v = b2[(65535 & v) + (m & (1 << x) - 1)];
                }
              }
              break;
            }
        } while (a < o && s < u);
      a -= E = _ >> 3, m &= (1 << (_ -= E << 3)) - 1, e5.next_in = a, e5.next_out = s, e5.avail_in = a < o ? o - a + 5 : 5 - (a - o), e5.avail_out = s < u ? u - s + 257 : 257 - (s - u), i2.hold = m, i2.bits = _;
    };
  }, {}], 58: [function(e4, t, i) {
    var r = e4("../utils/common"), n = e4("./adler32"), a = e4("./crc32"), o = e4("./inffast"), s = e4("./inftrees"), l = 0, u = 1, h = 2, c = 4, f = 5, d = 6, p = 0, m = 1, _ = 2, g = -2, b2 = -3, y = -4, w = -5, v = 8, x = 1, E = 2, k = 3, S = 4, A = 5, I = 6, M = 7, T = 8, P = 9, B = 10, C = 11, R = 12, z = 13, F = 14, N = 15, O = 16, D = 17, $ = 18, L = 19, U = 20, Z = 21, j = 22, G = 23, H = 24, Q = 25, W = 26, q = 27, V = 28, Y = 29, K = 30, J = 31, X = 852, ee = 592, te = 15;
    function ie(e5) {
      return (e5 >>> 24 & 255) + (e5 >>> 8 & 65280) + ((65280 & e5) << 8) + ((255 & e5) << 24);
    }
    function re() {
      this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
    }
    function ne(e5) {
      var t2;
      return e5 && e5.state ? (t2 = e5.state, e5.total_in = e5.total_out = t2.total = 0, e5.msg = "", t2.wrap && (e5.adler = 1 & t2.wrap), t2.mode = x, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new r.Buf32(X), t2.distcode = t2.distdyn = new r.Buf32(ee), t2.sane = 1, t2.back = -1, p) : g;
    }
    function ae(e5) {
      var t2;
      return e5 && e5.state ? ((t2 = e5.state).wsize = 0, t2.whave = 0, t2.wnext = 0, ne(e5)) : g;
    }
    function oe(e5, t2) {
      var i2, r2;
      return e5 && e5.state ? (r2 = e5.state, t2 < 0 ? (i2 = 0, t2 = -t2) : (i2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || t2 > 15) ? g : (r2.window !== null && r2.wbits !== t2 && (r2.window = null), r2.wrap = i2, r2.wbits = t2, ae(e5))) : g;
    }
    function se(e5, t2) {
      var i2, r2;
      return e5 ? (r2 = new re, e5.state = r2, r2.window = null, (i2 = oe(e5, t2)) !== p && (e5.state = null), i2) : g;
    }
    function le(e5) {
      return se(e5, te);
    }
    var ue, he, ce = true;
    function fe(e5) {
      if (ce) {
        var t2;
        for (ue = new r.Buf32(512), he = new r.Buf32(32), t2 = 0;t2 < 144; )
          e5.lens[t2++] = 8;
        for (;t2 < 256; )
          e5.lens[t2++] = 9;
        for (;t2 < 280; )
          e5.lens[t2++] = 7;
        for (;t2 < 288; )
          e5.lens[t2++] = 8;
        for (s(u, e5.lens, 0, 288, ue, 0, e5.work, { bits: 9 }), t2 = 0;t2 < 32; )
          e5.lens[t2++] = 5;
        s(h, e5.lens, 0, 32, he, 0, e5.work, { bits: 5 }), ce = false;
      }
      e5.lencode = ue, e5.lenbits = 9, e5.distcode = he, e5.distbits = 5;
    }
    function de(e5, t2, i2, n2) {
      var a2, o2 = e5.state;
      return o2.window === null && (o2.wsize = 1 << o2.wbits, o2.wnext = 0, o2.whave = 0, o2.window = new r.Buf8(o2.wsize)), n2 >= o2.wsize ? (r.arraySet(o2.window, t2, i2 - o2.wsize, o2.wsize, 0), o2.wnext = 0, o2.whave = o2.wsize) : ((a2 = o2.wsize - o2.wnext) > n2 && (a2 = n2), r.arraySet(o2.window, t2, i2 - n2, a2, o2.wnext), (n2 -= a2) ? (r.arraySet(o2.window, t2, i2 - n2, n2, 0), o2.wnext = n2, o2.whave = o2.wsize) : (o2.wnext += a2, o2.wnext === o2.wsize && (o2.wnext = 0), o2.whave < o2.wsize && (o2.whave += a2))), 0;
    }
    function pe(e5, t2) {
      var i2, X2, ee2, te2, re2, ne2, ae2, oe2, se2, le2, ue2, he2, ce2, pe2, me2, _e2, ge2, be, ye, we, ve, xe, Ee, ke, Se = 0, Ae = new r.Buf8(4), Ie = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!e5 || !e5.state || !e5.output || !e5.input && e5.avail_in !== 0)
        return g;
      (i2 = e5.state).mode === R && (i2.mode = z), re2 = e5.next_out, ee2 = e5.output, ae2 = e5.avail_out, te2 = e5.next_in, X2 = e5.input, ne2 = e5.avail_in, oe2 = i2.hold, se2 = i2.bits, le2 = ne2, ue2 = ae2, xe = p;
      e:
        for (;; )
          switch (i2.mode) {
            case x:
              if (i2.wrap === 0) {
                i2.mode = z;
                break;
              }
              for (;se2 < 16; ) {
                if (ne2 === 0)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              if (2 & i2.wrap && oe2 === 35615) {
                i2.check = 0, Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, i2.check = a(i2.check, Ae, 2, 0), oe2 = 0, se2 = 0, i2.mode = E;
                break;
              }
              if (i2.flags = 0, i2.head && (i2.head.done = false), !(1 & i2.wrap) || (((255 & oe2) << 8) + (oe2 >> 8)) % 31) {
                e5.msg = "incorrect header check", i2.mode = K;
                break;
              }
              if ((15 & oe2) !== v) {
                e5.msg = "unknown compression method", i2.mode = K;
                break;
              }
              if (se2 -= 4, ve = 8 + (15 & (oe2 >>>= 4)), i2.wbits === 0)
                i2.wbits = ve;
              else if (ve > i2.wbits) {
                e5.msg = "invalid window size", i2.mode = K;
                break;
              }
              i2.dmax = 1 << ve, e5.adler = i2.check = 1, i2.mode = 512 & oe2 ? B : R, oe2 = 0, se2 = 0;
              break;
            case E:
              for (;se2 < 16; ) {
                if (ne2 === 0)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              if (i2.flags = oe2, (255 & i2.flags) !== v) {
                e5.msg = "unknown compression method", i2.mode = K;
                break;
              }
              if (57344 & i2.flags) {
                e5.msg = "unknown header flags set", i2.mode = K;
                break;
              }
              i2.head && (i2.head.text = oe2 >> 8 & 1), 512 & i2.flags && (Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, i2.check = a(i2.check, Ae, 2, 0)), oe2 = 0, se2 = 0, i2.mode = k;
            case k:
              for (;se2 < 32; ) {
                if (ne2 === 0)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              i2.head && (i2.head.time = oe2), 512 & i2.flags && (Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, Ae[2] = oe2 >>> 16 & 255, Ae[3] = oe2 >>> 24 & 255, i2.check = a(i2.check, Ae, 4, 0)), oe2 = 0, se2 = 0, i2.mode = S;
            case S:
              for (;se2 < 16; ) {
                if (ne2 === 0)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              i2.head && (i2.head.xflags = 255 & oe2, i2.head.os = oe2 >> 8), 512 & i2.flags && (Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, i2.check = a(i2.check, Ae, 2, 0)), oe2 = 0, se2 = 0, i2.mode = A;
            case A:
              if (1024 & i2.flags) {
                for (;se2 < 16; ) {
                  if (ne2 === 0)
                    break e;
                  ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                }
                i2.length = oe2, i2.head && (i2.head.extra_len = oe2), 512 & i2.flags && (Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, i2.check = a(i2.check, Ae, 2, 0)), oe2 = 0, se2 = 0;
              } else
                i2.head && (i2.head.extra = null);
              i2.mode = I;
            case I:
              if (1024 & i2.flags && ((he2 = i2.length) > ne2 && (he2 = ne2), he2 && (i2.head && (ve = i2.head.extra_len - i2.length, i2.head.extra || (i2.head.extra = new Array(i2.head.extra_len)), r.arraySet(i2.head.extra, X2, te2, he2, ve)), 512 & i2.flags && (i2.check = a(i2.check, X2, he2, te2)), ne2 -= he2, te2 += he2, i2.length -= he2), i2.length))
                break e;
              i2.length = 0, i2.mode = M;
            case M:
              if (2048 & i2.flags) {
                if (ne2 === 0)
                  break e;
                he2 = 0;
                do {
                  ve = X2[te2 + he2++], i2.head && ve && i2.length < 65536 && (i2.head.name += String.fromCharCode(ve));
                } while (ve && he2 < ne2);
                if (512 & i2.flags && (i2.check = a(i2.check, X2, he2, te2)), ne2 -= he2, te2 += he2, ve)
                  break e;
              } else
                i2.head && (i2.head.name = null);
              i2.length = 0, i2.mode = T;
            case T:
              if (4096 & i2.flags) {
                if (ne2 === 0)
                  break e;
                he2 = 0;
                do {
                  ve = X2[te2 + he2++], i2.head && ve && i2.length < 65536 && (i2.head.comment += String.fromCharCode(ve));
                } while (ve && he2 < ne2);
                if (512 & i2.flags && (i2.check = a(i2.check, X2, he2, te2)), ne2 -= he2, te2 += he2, ve)
                  break e;
              } else
                i2.head && (i2.head.comment = null);
              i2.mode = P;
            case P:
              if (512 & i2.flags) {
                for (;se2 < 16; ) {
                  if (ne2 === 0)
                    break e;
                  ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                }
                if (oe2 !== (65535 & i2.check)) {
                  e5.msg = "header crc mismatch", i2.mode = K;
                  break;
                }
                oe2 = 0, se2 = 0;
              }
              i2.head && (i2.head.hcrc = i2.flags >> 9 & 1, i2.head.done = true), e5.adler = i2.check = 0, i2.mode = R;
              break;
            case B:
              for (;se2 < 32; ) {
                if (ne2 === 0)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              e5.adler = i2.check = ie(oe2), oe2 = 0, se2 = 0, i2.mode = C;
            case C:
              if (i2.havedict === 0)
                return e5.next_out = re2, e5.avail_out = ae2, e5.next_in = te2, e5.avail_in = ne2, i2.hold = oe2, i2.bits = se2, _;
              e5.adler = i2.check = 1, i2.mode = R;
            case R:
              if (t2 === f || t2 === d)
                break e;
            case z:
              if (i2.last) {
                oe2 >>>= 7 & se2, se2 -= 7 & se2, i2.mode = q;
                break;
              }
              for (;se2 < 3; ) {
                if (ne2 === 0)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              switch (i2.last = 1 & oe2, se2 -= 1, 3 & (oe2 >>>= 1)) {
                case 0:
                  i2.mode = F;
                  break;
                case 1:
                  if (fe(i2), i2.mode = U, t2 === d) {
                    oe2 >>>= 2, se2 -= 2;
                    break e;
                  }
                  break;
                case 2:
                  i2.mode = D;
                  break;
                case 3:
                  e5.msg = "invalid block type", i2.mode = K;
              }
              oe2 >>>= 2, se2 -= 2;
              break;
            case F:
              for (oe2 >>>= 7 & se2, se2 -= 7 & se2;se2 < 32; ) {
                if (ne2 === 0)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              if ((65535 & oe2) != (oe2 >>> 16 ^ 65535)) {
                e5.msg = "invalid stored block lengths", i2.mode = K;
                break;
              }
              if (i2.length = 65535 & oe2, oe2 = 0, se2 = 0, i2.mode = N, t2 === d)
                break e;
            case N:
              i2.mode = O;
            case O:
              if (he2 = i2.length) {
                if (he2 > ne2 && (he2 = ne2), he2 > ae2 && (he2 = ae2), he2 === 0)
                  break e;
                r.arraySet(ee2, X2, te2, he2, re2), ne2 -= he2, te2 += he2, ae2 -= he2, re2 += he2, i2.length -= he2;
                break;
              }
              i2.mode = R;
              break;
            case D:
              for (;se2 < 14; ) {
                if (ne2 === 0)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              if (i2.nlen = 257 + (31 & oe2), oe2 >>>= 5, se2 -= 5, i2.ndist = 1 + (31 & oe2), oe2 >>>= 5, se2 -= 5, i2.ncode = 4 + (15 & oe2), oe2 >>>= 4, se2 -= 4, i2.nlen > 286 || i2.ndist > 30) {
                e5.msg = "too many length or distance symbols", i2.mode = K;
                break;
              }
              i2.have = 0, i2.mode = $;
            case $:
              for (;i2.have < i2.ncode; ) {
                for (;se2 < 3; ) {
                  if (ne2 === 0)
                    break e;
                  ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                }
                i2.lens[Ie[i2.have++]] = 7 & oe2, oe2 >>>= 3, se2 -= 3;
              }
              for (;i2.have < 19; )
                i2.lens[Ie[i2.have++]] = 0;
              if (i2.lencode = i2.lendyn, i2.lenbits = 7, Ee = { bits: i2.lenbits }, xe = s(l, i2.lens, 0, 19, i2.lencode, 0, i2.work, Ee), i2.lenbits = Ee.bits, xe) {
                e5.msg = "invalid code lengths set", i2.mode = K;
                break;
              }
              i2.have = 0, i2.mode = L;
            case L:
              for (;i2.have < i2.nlen + i2.ndist; ) {
                for (;_e2 = (Se = i2.lencode[oe2 & (1 << i2.lenbits) - 1]) >>> 16 & 255, ge2 = 65535 & Se, !((me2 = Se >>> 24) <= se2); ) {
                  if (ne2 === 0)
                    break e;
                  ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                }
                if (ge2 < 16)
                  oe2 >>>= me2, se2 -= me2, i2.lens[i2.have++] = ge2;
                else {
                  if (ge2 === 16) {
                    for (ke = me2 + 2;se2 < ke; ) {
                      if (ne2 === 0)
                        break e;
                      ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                    }
                    if (oe2 >>>= me2, se2 -= me2, i2.have === 0) {
                      e5.msg = "invalid bit length repeat", i2.mode = K;
                      break;
                    }
                    ve = i2.lens[i2.have - 1], he2 = 3 + (3 & oe2), oe2 >>>= 2, se2 -= 2;
                  } else if (ge2 === 17) {
                    for (ke = me2 + 3;se2 < ke; ) {
                      if (ne2 === 0)
                        break e;
                      ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                    }
                    se2 -= me2, ve = 0, he2 = 3 + (7 & (oe2 >>>= me2)), oe2 >>>= 3, se2 -= 3;
                  } else {
                    for (ke = me2 + 7;se2 < ke; ) {
                      if (ne2 === 0)
                        break e;
                      ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                    }
                    se2 -= me2, ve = 0, he2 = 11 + (127 & (oe2 >>>= me2)), oe2 >>>= 7, se2 -= 7;
                  }
                  if (i2.have + he2 > i2.nlen + i2.ndist) {
                    e5.msg = "invalid bit length repeat", i2.mode = K;
                    break;
                  }
                  for (;he2--; )
                    i2.lens[i2.have++] = ve;
                }
              }
              if (i2.mode === K)
                break;
              if (i2.lens[256] === 0) {
                e5.msg = "invalid code -- missing end-of-block", i2.mode = K;
                break;
              }
              if (i2.lenbits = 9, Ee = { bits: i2.lenbits }, xe = s(u, i2.lens, 0, i2.nlen, i2.lencode, 0, i2.work, Ee), i2.lenbits = Ee.bits, xe) {
                e5.msg = "invalid literal/lengths set", i2.mode = K;
                break;
              }
              if (i2.distbits = 6, i2.distcode = i2.distdyn, Ee = { bits: i2.distbits }, xe = s(h, i2.lens, i2.nlen, i2.ndist, i2.distcode, 0, i2.work, Ee), i2.distbits = Ee.bits, xe) {
                e5.msg = "invalid distances set", i2.mode = K;
                break;
              }
              if (i2.mode = U, t2 === d)
                break e;
            case U:
              i2.mode = Z;
            case Z:
              if (ne2 >= 6 && ae2 >= 258) {
                e5.next_out = re2, e5.avail_out = ae2, e5.next_in = te2, e5.avail_in = ne2, i2.hold = oe2, i2.bits = se2, o(e5, ue2), re2 = e5.next_out, ee2 = e5.output, ae2 = e5.avail_out, te2 = e5.next_in, X2 = e5.input, ne2 = e5.avail_in, oe2 = i2.hold, se2 = i2.bits, i2.mode === R && (i2.back = -1);
                break;
              }
              for (i2.back = 0;_e2 = (Se = i2.lencode[oe2 & (1 << i2.lenbits) - 1]) >>> 16 & 255, ge2 = 65535 & Se, !((me2 = Se >>> 24) <= se2); ) {
                if (ne2 === 0)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              if (_e2 && !(240 & _e2)) {
                for (be = me2, ye = _e2, we = ge2;_e2 = (Se = i2.lencode[we + ((oe2 & (1 << be + ye) - 1) >> be)]) >>> 16 & 255, ge2 = 65535 & Se, !(be + (me2 = Se >>> 24) <= se2); ) {
                  if (ne2 === 0)
                    break e;
                  ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                }
                oe2 >>>= be, se2 -= be, i2.back += be;
              }
              if (oe2 >>>= me2, se2 -= me2, i2.back += me2, i2.length = ge2, _e2 === 0) {
                i2.mode = W;
                break;
              }
              if (32 & _e2) {
                i2.back = -1, i2.mode = R;
                break;
              }
              if (64 & _e2) {
                e5.msg = "invalid literal/length code", i2.mode = K;
                break;
              }
              i2.extra = 15 & _e2, i2.mode = j;
            case j:
              if (i2.extra) {
                for (ke = i2.extra;se2 < ke; ) {
                  if (ne2 === 0)
                    break e;
                  ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                }
                i2.length += oe2 & (1 << i2.extra) - 1, oe2 >>>= i2.extra, se2 -= i2.extra, i2.back += i2.extra;
              }
              i2.was = i2.length, i2.mode = G;
            case G:
              for (;_e2 = (Se = i2.distcode[oe2 & (1 << i2.distbits) - 1]) >>> 16 & 255, ge2 = 65535 & Se, !((me2 = Se >>> 24) <= se2); ) {
                if (ne2 === 0)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              if (!(240 & _e2)) {
                for (be = me2, ye = _e2, we = ge2;_e2 = (Se = i2.distcode[we + ((oe2 & (1 << be + ye) - 1) >> be)]) >>> 16 & 255, ge2 = 65535 & Se, !(be + (me2 = Se >>> 24) <= se2); ) {
                  if (ne2 === 0)
                    break e;
                  ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                }
                oe2 >>>= be, se2 -= be, i2.back += be;
              }
              if (oe2 >>>= me2, se2 -= me2, i2.back += me2, 64 & _e2) {
                e5.msg = "invalid distance code", i2.mode = K;
                break;
              }
              i2.offset = ge2, i2.extra = 15 & _e2, i2.mode = H;
            case H:
              if (i2.extra) {
                for (ke = i2.extra;se2 < ke; ) {
                  if (ne2 === 0)
                    break e;
                  ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                }
                i2.offset += oe2 & (1 << i2.extra) - 1, oe2 >>>= i2.extra, se2 -= i2.extra, i2.back += i2.extra;
              }
              if (i2.offset > i2.dmax) {
                e5.msg = "invalid distance too far back", i2.mode = K;
                break;
              }
              i2.mode = Q;
            case Q:
              if (ae2 === 0)
                break e;
              if (he2 = ue2 - ae2, i2.offset > he2) {
                if ((he2 = i2.offset - he2) > i2.whave && i2.sane) {
                  e5.msg = "invalid distance too far back", i2.mode = K;
                  break;
                }
                he2 > i2.wnext ? (he2 -= i2.wnext, ce2 = i2.wsize - he2) : ce2 = i2.wnext - he2, he2 > i2.length && (he2 = i2.length), pe2 = i2.window;
              } else
                pe2 = ee2, ce2 = re2 - i2.offset, he2 = i2.length;
              he2 > ae2 && (he2 = ae2), ae2 -= he2, i2.length -= he2;
              do {
                ee2[re2++] = pe2[ce2++];
              } while (--he2);
              i2.length === 0 && (i2.mode = Z);
              break;
            case W:
              if (ae2 === 0)
                break e;
              ee2[re2++] = i2.length, ae2--, i2.mode = Z;
              break;
            case q:
              if (i2.wrap) {
                for (;se2 < 32; ) {
                  if (ne2 === 0)
                    break e;
                  ne2--, oe2 |= X2[te2++] << se2, se2 += 8;
                }
                if (ue2 -= ae2, e5.total_out += ue2, i2.total += ue2, ue2 && (e5.adler = i2.check = i2.flags ? a(i2.check, ee2, ue2, re2 - ue2) : n(i2.check, ee2, ue2, re2 - ue2)), ue2 = ae2, (i2.flags ? oe2 : ie(oe2)) !== i2.check) {
                  e5.msg = "incorrect data check", i2.mode = K;
                  break;
                }
                oe2 = 0, se2 = 0;
              }
              i2.mode = V;
            case V:
              if (i2.wrap && i2.flags) {
                for (;se2 < 32; ) {
                  if (ne2 === 0)
                    break e;
                  ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                }
                if (oe2 !== (4294967295 & i2.total)) {
                  e5.msg = "incorrect length check", i2.mode = K;
                  break;
                }
                oe2 = 0, se2 = 0;
              }
              i2.mode = Y;
            case Y:
              xe = m;
              break e;
            case K:
              xe = b2;
              break e;
            case J:
              return y;
            default:
              return g;
          }
      return e5.next_out = re2, e5.avail_out = ae2, e5.next_in = te2, e5.avail_in = ne2, i2.hold = oe2, i2.bits = se2, (i2.wsize || ue2 !== e5.avail_out && i2.mode < K && (i2.mode < q || t2 !== c)) && de(e5, e5.output, e5.next_out, ue2 - e5.avail_out), le2 -= e5.avail_in, ue2 -= e5.avail_out, e5.total_in += le2, e5.total_out += ue2, i2.total += ue2, i2.wrap && ue2 && (e5.adler = i2.check = i2.flags ? a(i2.check, ee2, ue2, e5.next_out - ue2) : n(i2.check, ee2, ue2, e5.next_out - ue2)), e5.data_type = i2.bits + (i2.last ? 64 : 0) + (i2.mode === R ? 128 : 0) + (i2.mode === U || i2.mode === N ? 256 : 0), (le2 === 0 && ue2 === 0 || t2 === c) && xe === p && (xe = w), xe;
    }
    function me(e5) {
      if (!e5 || !e5.state)
        return g;
      var t2 = e5.state;
      return t2.window && (t2.window = null), e5.state = null, p;
    }
    function _e(e5, t2) {
      var i2;
      return e5 && e5.state && 2 & (i2 = e5.state).wrap ? (i2.head = t2, t2.done = false, p) : g;
    }
    function ge(e5, t2) {
      var i2, r2 = t2.length;
      return e5 && e5.state ? (i2 = e5.state).wrap !== 0 && i2.mode !== C ? g : i2.mode === C && n(1, t2, r2, 0) !== i2.check ? b2 : de(e5, t2, r2, r2) ? (i2.mode = J, y) : (i2.havedict = 1, p) : g;
    }
    i.inflateReset = ae, i.inflateReset2 = oe, i.inflateResetKeep = ne, i.inflateInit = le, i.inflateInit2 = se, i.inflate = pe, i.inflateEnd = me, i.inflateGetHeader = _e, i.inflateSetDictionary = ge, i.inflateInfo = "pako inflate (from Nodeca project)";
  }, { "../utils/common": 52, "./adler32": 53, "./crc32": 55, "./inffast": 57, "./inftrees": 59 }], 59: [function(e4, t, i) {
    var r = e4("../utils/common"), n = 15, a = 852, o = 592, s = 0, l = 1, u = 2, h = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], c = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], f = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], d = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
    t.exports = function(e5, t2, i2, p, m, _, g, b2) {
      var y, w, v, x, E, k, S, A, I, M = b2.bits, T = 0, P = 0, B = 0, C = 0, R = 0, z = 0, F = 0, N = 0, O = 0, D = 0, $ = null, L = 0, U = new r.Buf16(n + 1), Z = new r.Buf16(n + 1), j = null, G = 0;
      for (T = 0;T <= n; T++)
        U[T] = 0;
      for (P = 0;P < p; P++)
        U[t2[i2 + P]]++;
      for (R = M, C = n;C >= 1 && U[C] === 0; C--)
        ;
      if (R > C && (R = C), C === 0)
        return m[_++] = 20971520, m[_++] = 20971520, b2.bits = 1, 0;
      for (B = 1;B < C && U[B] === 0; B++)
        ;
      for (R < B && (R = B), N = 1, T = 1;T <= n; T++)
        if (N <<= 1, (N -= U[T]) < 0)
          return -1;
      if (N > 0 && (e5 === s || C !== 1))
        return -1;
      for (Z[1] = 0, T = 1;T < n; T++)
        Z[T + 1] = Z[T] + U[T];
      for (P = 0;P < p; P++)
        t2[i2 + P] !== 0 && (g[Z[t2[i2 + P]]++] = P);
      if (e5 === s ? ($ = j = g, k = 19) : e5 === l ? ($ = h, L -= 257, j = c, G -= 257, k = 256) : ($ = f, j = d, k = -1), D = 0, P = 0, T = B, E = _, z = R, F = 0, v = -1, x = (O = 1 << R) - 1, e5 === l && O > a || e5 === u && O > o)
        return 1;
      for (;; ) {
        S = T - F, g[P] < k ? (A = 0, I = g[P]) : g[P] > k ? (A = j[G + g[P]], I = $[L + g[P]]) : (A = 96, I = 0), y = 1 << T - F, B = w = 1 << z;
        do {
          m[E + (D >> F) + (w -= y)] = S << 24 | A << 16 | I;
        } while (w !== 0);
        for (y = 1 << T - 1;D & y; )
          y >>= 1;
        if (y !== 0 ? (D &= y - 1, D += y) : D = 0, P++, --U[T] == 0) {
          if (T === C)
            break;
          T = t2[i2 + g[P]];
        }
        if (T > R && (D & x) !== v) {
          for (F === 0 && (F = R), E += B, N = 1 << (z = T - F);z + F < C && !((N -= U[z + F]) <= 0); )
            z++, N <<= 1;
          if (O += 1 << z, e5 === l && O > a || e5 === u && O > o)
            return 1;
          m[v = D & x] = R << 24 | z << 16 | E - _;
        }
      }
      return D !== 0 && (m[E + D] = T - F << 24 | 64 << 16), b2.bits = R, 0;
    };
  }, { "../utils/common": 52 }], 60: [function(e4, t, i) {
    t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
  }, {}], 61: [function(e4, t, i) {
    var r = e4("../utils/common"), n = 4, a = 0, o = 1, s = 2;
    function l(e5) {
      for (var t2 = e5.length;--t2 >= 0; )
        e5[t2] = 0;
    }
    var u = 0, h = 1, c = 2, f = 3, d = 258, p = 29, m = 256, _ = m + 1 + p, g = 30, b2 = 19, y = 2 * _ + 1, w = 15, v = 16, x = 7, E = 256, k = 16, S = 17, A = 18, I = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], M = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], T = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], P = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], B = 512, C = new Array(2 * (_ + 2));
    l(C);
    var R = new Array(2 * g);
    l(R);
    var z = new Array(B);
    l(z);
    var F = new Array(d - f + 1);
    l(F);
    var N = new Array(p);
    l(N);
    var O, D, $, L = new Array(g);
    function U(e5, t2, i2, r2, n2) {
      this.static_tree = e5, this.extra_bits = t2, this.extra_base = i2, this.elems = r2, this.max_length = n2, this.has_stree = e5 && e5.length;
    }
    function Z(e5, t2) {
      this.dyn_tree = e5, this.max_code = 0, this.stat_desc = t2;
    }
    function j(e5) {
      return e5 < 256 ? z[e5] : z[256 + (e5 >>> 7)];
    }
    function G(e5, t2) {
      e5.pending_buf[e5.pending++] = 255 & t2, e5.pending_buf[e5.pending++] = t2 >>> 8 & 255;
    }
    function H(e5, t2, i2) {
      e5.bi_valid > v - i2 ? (e5.bi_buf |= t2 << e5.bi_valid & 65535, G(e5, e5.bi_buf), e5.bi_buf = t2 >> v - e5.bi_valid, e5.bi_valid += i2 - v) : (e5.bi_buf |= t2 << e5.bi_valid & 65535, e5.bi_valid += i2);
    }
    function Q(e5, t2, i2) {
      H(e5, i2[2 * t2], i2[2 * t2 + 1]);
    }
    function W(e5, t2) {
      var i2 = 0;
      do {
        i2 |= 1 & e5, e5 >>>= 1, i2 <<= 1;
      } while (--t2 > 0);
      return i2 >>> 1;
    }
    function q(e5) {
      e5.bi_valid === 16 ? (G(e5, e5.bi_buf), e5.bi_buf = 0, e5.bi_valid = 0) : e5.bi_valid >= 8 && (e5.pending_buf[e5.pending++] = 255 & e5.bi_buf, e5.bi_buf >>= 8, e5.bi_valid -= 8);
    }
    function V(e5, t2) {
      var i2, r2, n2, a2, o2, s2, l2 = t2.dyn_tree, u2 = t2.max_code, h2 = t2.stat_desc.static_tree, c2 = t2.stat_desc.has_stree, f2 = t2.stat_desc.extra_bits, d2 = t2.stat_desc.extra_base, p2 = t2.stat_desc.max_length, m2 = 0;
      for (a2 = 0;a2 <= w; a2++)
        e5.bl_count[a2] = 0;
      for (l2[2 * e5.heap[e5.heap_max] + 1] = 0, i2 = e5.heap_max + 1;i2 < y; i2++)
        (a2 = l2[2 * l2[2 * (r2 = e5.heap[i2]) + 1] + 1] + 1) > p2 && (a2 = p2, m2++), l2[2 * r2 + 1] = a2, r2 > u2 || (e5.bl_count[a2]++, o2 = 0, r2 >= d2 && (o2 = f2[r2 - d2]), s2 = l2[2 * r2], e5.opt_len += s2 * (a2 + o2), c2 && (e5.static_len += s2 * (h2[2 * r2 + 1] + o2)));
      if (m2 !== 0) {
        do {
          for (a2 = p2 - 1;e5.bl_count[a2] === 0; )
            a2--;
          e5.bl_count[a2]--, e5.bl_count[a2 + 1] += 2, e5.bl_count[p2]--, m2 -= 2;
        } while (m2 > 0);
        for (a2 = p2;a2 !== 0; a2--)
          for (r2 = e5.bl_count[a2];r2 !== 0; )
            (n2 = e5.heap[--i2]) > u2 || (l2[2 * n2 + 1] !== a2 && (e5.opt_len += (a2 - l2[2 * n2 + 1]) * l2[2 * n2], l2[2 * n2 + 1] = a2), r2--);
      }
    }
    function Y(e5, t2, i2) {
      var r2, n2, a2 = new Array(w + 1), o2 = 0;
      for (r2 = 1;r2 <= w; r2++)
        a2[r2] = o2 = o2 + i2[r2 - 1] << 1;
      for (n2 = 0;n2 <= t2; n2++) {
        var s2 = e5[2 * n2 + 1];
        s2 !== 0 && (e5[2 * n2] = W(a2[s2]++, s2));
      }
    }
    function K() {
      var e5, t2, i2, r2, n2, a2 = new Array(w + 1);
      for (i2 = 0, r2 = 0;r2 < p - 1; r2++)
        for (N[r2] = i2, e5 = 0;e5 < 1 << I[r2]; e5++)
          F[i2++] = r2;
      for (F[i2 - 1] = r2, n2 = 0, r2 = 0;r2 < 16; r2++)
        for (L[r2] = n2, e5 = 0;e5 < 1 << M[r2]; e5++)
          z[n2++] = r2;
      for (n2 >>= 7;r2 < g; r2++)
        for (L[r2] = n2 << 7, e5 = 0;e5 < 1 << M[r2] - 7; e5++)
          z[256 + n2++] = r2;
      for (t2 = 0;t2 <= w; t2++)
        a2[t2] = 0;
      for (e5 = 0;e5 <= 143; )
        C[2 * e5 + 1] = 8, e5++, a2[8]++;
      for (;e5 <= 255; )
        C[2 * e5 + 1] = 9, e5++, a2[9]++;
      for (;e5 <= 279; )
        C[2 * e5 + 1] = 7, e5++, a2[7]++;
      for (;e5 <= 287; )
        C[2 * e5 + 1] = 8, e5++, a2[8]++;
      for (Y(C, _ + 1, a2), e5 = 0;e5 < g; e5++)
        R[2 * e5 + 1] = 5, R[2 * e5] = W(e5, 5);
      O = new U(C, I, m + 1, _, w), D = new U(R, M, 0, g, w), $ = new U(new Array(0), T, 0, b2, x);
    }
    function J(e5) {
      var t2;
      for (t2 = 0;t2 < _; t2++)
        e5.dyn_ltree[2 * t2] = 0;
      for (t2 = 0;t2 < g; t2++)
        e5.dyn_dtree[2 * t2] = 0;
      for (t2 = 0;t2 < b2; t2++)
        e5.bl_tree[2 * t2] = 0;
      e5.dyn_ltree[2 * E] = 1, e5.opt_len = e5.static_len = 0, e5.last_lit = e5.matches = 0;
    }
    function X(e5) {
      e5.bi_valid > 8 ? G(e5, e5.bi_buf) : e5.bi_valid > 0 && (e5.pending_buf[e5.pending++] = e5.bi_buf), e5.bi_buf = 0, e5.bi_valid = 0;
    }
    function ee(e5, t2, i2, n2) {
      X(e5), G(e5, i2), G(e5, ~i2), r.arraySet(e5.pending_buf, e5.window, t2, i2, e5.pending), e5.pending += i2;
    }
    function te(e5, t2, i2, r2) {
      var n2 = 2 * t2, a2 = 2 * i2;
      return e5[n2] < e5[a2] || e5[n2] === e5[a2] && r2[t2] <= r2[i2];
    }
    function ie(e5, t2, i2) {
      for (var r2 = e5.heap[i2], n2 = i2 << 1;n2 <= e5.heap_len && (n2 < e5.heap_len && te(t2, e5.heap[n2 + 1], e5.heap[n2], e5.depth) && n2++, !te(t2, r2, e5.heap[n2], e5.depth)); )
        e5.heap[i2] = e5.heap[n2], i2 = n2, n2 <<= 1;
      e5.heap[i2] = r2;
    }
    function re(e5, t2, i2) {
      var r2, n2, a2, o2, s2 = 0;
      if (e5.last_lit !== 0)
        do {
          r2 = e5.pending_buf[e5.d_buf + 2 * s2] << 8 | e5.pending_buf[e5.d_buf + 2 * s2 + 1], n2 = e5.pending_buf[e5.l_buf + s2], s2++, r2 === 0 ? Q(e5, n2, t2) : (Q(e5, (a2 = F[n2]) + m + 1, t2), (o2 = I[a2]) !== 0 && H(e5, n2 -= N[a2], o2), Q(e5, a2 = j(--r2), i2), (o2 = M[a2]) !== 0 && H(e5, r2 -= L[a2], o2));
        } while (s2 < e5.last_lit);
      Q(e5, E, t2);
    }
    function ne(e5, t2) {
      var i2, r2, n2, a2 = t2.dyn_tree, o2 = t2.stat_desc.static_tree, s2 = t2.stat_desc.has_stree, l2 = t2.stat_desc.elems, u2 = -1;
      for (e5.heap_len = 0, e5.heap_max = y, i2 = 0;i2 < l2; i2++)
        a2[2 * i2] !== 0 ? (e5.heap[++e5.heap_len] = u2 = i2, e5.depth[i2] = 0) : a2[2 * i2 + 1] = 0;
      for (;e5.heap_len < 2; )
        a2[2 * (n2 = e5.heap[++e5.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e5.depth[n2] = 0, e5.opt_len--, s2 && (e5.static_len -= o2[2 * n2 + 1]);
      for (t2.max_code = u2, i2 = e5.heap_len >> 1;i2 >= 1; i2--)
        ie(e5, a2, i2);
      n2 = l2;
      do {
        i2 = e5.heap[1], e5.heap[1] = e5.heap[e5.heap_len--], ie(e5, a2, 1), r2 = e5.heap[1], e5.heap[--e5.heap_max] = i2, e5.heap[--e5.heap_max] = r2, a2[2 * n2] = a2[2 * i2] + a2[2 * r2], e5.depth[n2] = (e5.depth[i2] >= e5.depth[r2] ? e5.depth[i2] : e5.depth[r2]) + 1, a2[2 * i2 + 1] = a2[2 * r2 + 1] = n2, e5.heap[1] = n2++, ie(e5, a2, 1);
      } while (e5.heap_len >= 2);
      e5.heap[--e5.heap_max] = e5.heap[1], V(e5, t2), Y(a2, u2, e5.bl_count);
    }
    function ae(e5, t2, i2) {
      var r2, n2, a2 = -1, o2 = t2[1], s2 = 0, l2 = 7, u2 = 4;
      for (o2 === 0 && (l2 = 138, u2 = 3), t2[2 * (i2 + 1) + 1] = 65535, r2 = 0;r2 <= i2; r2++)
        n2 = o2, o2 = t2[2 * (r2 + 1) + 1], ++s2 < l2 && n2 === o2 || (s2 < u2 ? e5.bl_tree[2 * n2] += s2 : n2 !== 0 ? (n2 !== a2 && e5.bl_tree[2 * n2]++, e5.bl_tree[2 * k]++) : s2 <= 10 ? e5.bl_tree[2 * S]++ : e5.bl_tree[2 * A]++, s2 = 0, a2 = n2, o2 === 0 ? (l2 = 138, u2 = 3) : n2 === o2 ? (l2 = 6, u2 = 3) : (l2 = 7, u2 = 4));
    }
    function oe(e5, t2, i2) {
      var r2, n2, a2 = -1, o2 = t2[1], s2 = 0, l2 = 7, u2 = 4;
      for (o2 === 0 && (l2 = 138, u2 = 3), r2 = 0;r2 <= i2; r2++)
        if (n2 = o2, o2 = t2[2 * (r2 + 1) + 1], !(++s2 < l2 && n2 === o2)) {
          if (s2 < u2)
            do {
              Q(e5, n2, e5.bl_tree);
            } while (--s2 != 0);
          else
            n2 !== 0 ? (n2 !== a2 && (Q(e5, n2, e5.bl_tree), s2--), Q(e5, k, e5.bl_tree), H(e5, s2 - 3, 2)) : s2 <= 10 ? (Q(e5, S, e5.bl_tree), H(e5, s2 - 3, 3)) : (Q(e5, A, e5.bl_tree), H(e5, s2 - 11, 7));
          s2 = 0, a2 = n2, o2 === 0 ? (l2 = 138, u2 = 3) : n2 === o2 ? (l2 = 6, u2 = 3) : (l2 = 7, u2 = 4);
        }
    }
    function se(e5) {
      var t2;
      for (ae(e5, e5.dyn_ltree, e5.l_desc.max_code), ae(e5, e5.dyn_dtree, e5.d_desc.max_code), ne(e5, e5.bl_desc), t2 = b2 - 1;t2 >= 3 && e5.bl_tree[2 * P[t2] + 1] === 0; t2--)
        ;
      return e5.opt_len += 3 * (t2 + 1) + 5 + 5 + 4, t2;
    }
    function le(e5, t2, i2, r2) {
      var n2;
      for (H(e5, t2 - 257, 5), H(e5, i2 - 1, 5), H(e5, r2 - 4, 4), n2 = 0;n2 < r2; n2++)
        H(e5, e5.bl_tree[2 * P[n2] + 1], 3);
      oe(e5, e5.dyn_ltree, t2 - 1), oe(e5, e5.dyn_dtree, i2 - 1);
    }
    function ue(e5) {
      var t2, i2 = 4093624447;
      for (t2 = 0;t2 <= 31; t2++, i2 >>>= 1)
        if (1 & i2 && e5.dyn_ltree[2 * t2] !== 0)
          return a;
      if (e5.dyn_ltree[18] !== 0 || e5.dyn_ltree[20] !== 0 || e5.dyn_ltree[26] !== 0)
        return o;
      for (t2 = 32;t2 < m; t2++)
        if (e5.dyn_ltree[2 * t2] !== 0)
          return o;
      return a;
    }
    l(L);
    var he = false;
    function ce(e5) {
      he || (K(), he = true), e5.l_desc = new Z(e5.dyn_ltree, O), e5.d_desc = new Z(e5.dyn_dtree, D), e5.bl_desc = new Z(e5.bl_tree, $), e5.bi_buf = 0, e5.bi_valid = 0, J(e5);
    }
    function fe(e5, t2, i2, r2) {
      H(e5, (u << 1) + (r2 ? 1 : 0), 3), ee(e5, t2, i2);
    }
    function de(e5) {
      H(e5, h << 1, 3), Q(e5, E, C), q(e5);
    }
    function pe(e5, t2, i2, r2) {
      var a2, o2, l2 = 0;
      e5.level > 0 ? (e5.strm.data_type === s && (e5.strm.data_type = ue(e5)), ne(e5, e5.l_desc), ne(e5, e5.d_desc), l2 = se(e5), a2 = e5.opt_len + 3 + 7 >>> 3, (o2 = e5.static_len + 3 + 7 >>> 3) <= a2 && (a2 = o2)) : a2 = o2 = i2 + 5, i2 + 4 <= a2 && t2 !== -1 ? fe(e5, t2, i2, r2) : e5.strategy === n || o2 === a2 ? (H(e5, (h << 1) + (r2 ? 1 : 0), 3), re(e5, C, R)) : (H(e5, (c << 1) + (r2 ? 1 : 0), 3), le(e5, e5.l_desc.max_code + 1, e5.d_desc.max_code + 1, l2 + 1), re(e5, e5.dyn_ltree, e5.dyn_dtree)), J(e5), r2 && X(e5);
    }
    function me(e5, t2, i2) {
      return e5.pending_buf[e5.d_buf + 2 * e5.last_lit] = t2 >>> 8 & 255, e5.pending_buf[e5.d_buf + 2 * e5.last_lit + 1] = 255 & t2, e5.pending_buf[e5.l_buf + e5.last_lit] = 255 & i2, e5.last_lit++, t2 === 0 ? e5.dyn_ltree[2 * i2]++ : (e5.matches++, t2--, e5.dyn_ltree[2 * (F[i2] + m + 1)]++, e5.dyn_dtree[2 * j(t2)]++), e5.last_lit === e5.lit_bufsize - 1;
    }
    i._tr_init = ce, i._tr_stored_block = fe, i._tr_flush_block = pe, i._tr_tally = me, i._tr_align = de;
  }, { "../utils/common": 52 }], 62: [function(e4, t, i) {
    function r() {
      this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
    }
    t.exports = r;
  }, {}], 63: [function(e4, t, i) {
    var r, n, a = t.exports = {};
    function o() {
      throw new Error("setTimeout has not been defined");
    }
    function s() {
      throw new Error("clearTimeout has not been defined");
    }
    function l(e5) {
      if (r === setTimeout)
        return setTimeout(e5, 0);
      if ((r === o || !r) && setTimeout)
        return r = setTimeout, setTimeout(e5, 0);
      try {
        return r(e5, 0);
      } catch (t2) {
        try {
          return r.call(null, e5, 0);
        } catch (t3) {
          return r.call(this, e5, 0);
        }
      }
    }
    function u(e5) {
      if (n === clearTimeout)
        return clearTimeout(e5);
      if ((n === s || !n) && clearTimeout)
        return n = clearTimeout, clearTimeout(e5);
      try {
        return n(e5);
      } catch (t2) {
        try {
          return n.call(null, e5);
        } catch (t3) {
          return n.call(this, e5);
        }
      }
    }
    (function() {
      try {
        r = typeof setTimeout == "function" ? setTimeout : o;
      } catch (e5) {
        r = o;
      }
      try {
        n = typeof clearTimeout == "function" ? clearTimeout : s;
      } catch (e5) {
        n = s;
      }
    })();
    var h, c = [], f = false, d = -1;
    function p() {
      f && h && (f = false, h.length ? c = h.concat(c) : d = -1, c.length && m());
    }
    function m() {
      if (!f) {
        var e5 = l(p);
        f = true;
        for (var t2 = c.length;t2; ) {
          for (h = c, c = [];++d < t2; )
            h && h[d].run();
          d = -1, t2 = c.length;
        }
        h = null, f = false, u(e5);
      }
    }
    function _(e5, t2) {
      this.fun = e5, this.array = t2;
    }
    function g() {
    }
    a.nextTick = function(e5) {
      var t2 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var i2 = 1;i2 < arguments.length; i2++)
          t2[i2 - 1] = arguments[i2];
      c.push(new _(e5, t2)), c.length !== 1 || f || l(m);
    }, _.prototype.run = function() {
      this.fun.apply(null, this.array);
    }, a.title = "browser", a.browser = true, a.env = {}, a.argv = [], a.version = "", a.versions = {}, a.on = g, a.addListener = g, a.once = g, a.off = g, a.removeListener = g, a.removeAllListeners = g, a.emit = g, a.prependListener = g, a.prependOnceListener = g, a.listeners = function(e5) {
      return [];
    }, a.binding = function(e5) {
      throw new Error("process.binding is not supported");
    }, a.cwd = function() {
      return "/";
    }, a.chdir = function(e5) {
      throw new Error("process.chdir is not supported");
    }, a.umask = function() {
      return 0;
    };
  }, {}], 64: [function(e4, t, i) {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var r = e4("buffer"), n = r.Buffer;
    function a(e5, t2) {
      for (var i2 in e5)
        t2[i2] = e5[i2];
    }
    function o(e5, t2, i2) {
      return n(e5, t2, i2);
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = r : (a(r, i), i.Buffer = o), o.prototype = Object.create(n.prototype), a(n, o), o.from = function(e5, t2, i2) {
      if (typeof e5 == "number")
        throw new TypeError("Argument must not be a number");
      return n(e5, t2, i2);
    }, o.alloc = function(e5, t2, i2) {
      if (typeof e5 != "number")
        throw new TypeError("Argument must be a number");
      var r2 = n(e5);
      return t2 !== undefined ? typeof i2 == "string" ? r2.fill(t2, i2) : r2.fill(t2) : r2.fill(0), r2;
    }, o.allocUnsafe = function(e5) {
      if (typeof e5 != "number")
        throw new TypeError("Argument must be a number");
      return n(e5);
    }, o.allocUnsafeSlow = function(e5) {
      if (typeof e5 != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(e5);
    };
  }, { buffer: 32 }], 65: [function(e4, t, i) {
    t.exports = n;
    var r = e4("events").EventEmitter;
    function n() {
      r.call(this);
    }
    e4("inherits")(n, r), n.Readable = e4("readable-stream/lib/_stream_readable.js"), n.Writable = e4("readable-stream/lib/_stream_writable.js"), n.Duplex = e4("readable-stream/lib/_stream_duplex.js"), n.Transform = e4("readable-stream/lib/_stream_transform.js"), n.PassThrough = e4("readable-stream/lib/_stream_passthrough.js"), n.finished = e4("readable-stream/lib/internal/streams/end-of-stream.js"), n.pipeline = e4("readable-stream/lib/internal/streams/pipeline.js"), n.Stream = n, n.prototype.pipe = function(e5, t2) {
      var i2 = this;
      function n2(t3) {
        e5.writable && e5.write(t3) === false && i2.pause && i2.pause();
      }
      function a() {
        i2.readable && i2.resume && i2.resume();
      }
      i2.on("data", n2), e5.on("drain", a), e5._isStdio || t2 && t2.end === false || (i2.on("end", s), i2.on("close", l));
      var o = false;
      function s() {
        o || (o = true, e5.end());
      }
      function l() {
        o || (o = true, typeof e5.destroy == "function" && e5.destroy());
      }
      function u(e6) {
        if (h(), r.listenerCount(this, "error") === 0)
          throw e6;
      }
      function h() {
        i2.removeListener("data", n2), e5.removeListener("drain", a), i2.removeListener("end", s), i2.removeListener("close", l), i2.removeListener("error", u), e5.removeListener("error", u), i2.removeListener("end", h), i2.removeListener("close", h), e5.removeListener("close", h);
      }
      return i2.on("error", u), e5.on("error", u), i2.on("end", h), i2.on("close", h), e5.on("close", h), e5.emit("pipe", i2), e5;
    };
  }, { events: 35, inherits: 46, "readable-stream/lib/_stream_duplex.js": 67, "readable-stream/lib/_stream_passthrough.js": 68, "readable-stream/lib/_stream_readable.js": 69, "readable-stream/lib/_stream_transform.js": 70, "readable-stream/lib/_stream_writable.js": 71, "readable-stream/lib/internal/streams/end-of-stream.js": 75, "readable-stream/lib/internal/streams/pipeline.js": 77 }], 66: [function(e4, t, i) {
    function r(e5, t2) {
      e5.prototype = Object.create(t2.prototype), e5.prototype.constructor = e5, e5.__proto__ = t2;
    }
    var n = {};
    function a(e5, t2, i2) {
      function a2(e6, i3, r2) {
        return typeof t2 == "string" ? t2 : t2(e6, i3, r2);
      }
      i2 || (i2 = Error);
      var o2 = function(e6) {
        function t3(t4, i3, r2) {
          return e6.call(this, a2(t4, i3, r2)) || this;
        }
        return r(t3, e6), t3;
      }(i2);
      o2.prototype.name = i2.name, o2.prototype.code = e5, n[e5] = o2;
    }
    function o(e5, t2) {
      if (Array.isArray(e5)) {
        var i2 = e5.length;
        return e5 = e5.map(function(e6) {
          return String(e6);
        }), i2 > 2 ? "one of ".concat(t2, " ").concat(e5.slice(0, i2 - 1).join(", "), ", or ") + e5[i2 - 1] : i2 === 2 ? "one of ".concat(t2, " ").concat(e5[0], " or ").concat(e5[1]) : "of ".concat(t2, " ").concat(e5[0]);
      }
      return "of ".concat(t2, " ").concat(String(e5));
    }
    function s(e5, t2, i2) {
      return e5.substr(0, t2.length) === t2;
    }
    function l(e5, t2, i2) {
      return (i2 === undefined || i2 > e5.length) && (i2 = e5.length), e5.substring(i2 - t2.length, i2) === t2;
    }
    function u(e5, t2, i2) {
      return typeof i2 != "number" && (i2 = 0), !(i2 + t2.length > e5.length) && e5.indexOf(t2, i2) !== -1;
    }
    a("ERR_INVALID_OPT_VALUE", function(e5, t2) {
      return 'The value "' + t2 + '" is invalid for option "' + e5 + '"';
    }, TypeError), a("ERR_INVALID_ARG_TYPE", function(e5, t2, i2) {
      var r2, n2;
      if (typeof t2 == "string" && s(t2, "not ") ? (r2 = "must not be", t2 = t2.replace(/^not /, "")) : r2 = "must be", l(e5, " argument"))
        n2 = "The ".concat(e5, " ").concat(r2, " ").concat(o(t2, "type"));
      else {
        var a2 = u(e5, ".") ? "property" : "argument";
        n2 = 'The "'.concat(e5, '" ').concat(a2, " ").concat(r2, " ").concat(o(t2, "type"));
      }
      return n2 += ". Received type ".concat(typeof i2);
    }, TypeError), a("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), a("ERR_METHOD_NOT_IMPLEMENTED", function(e5) {
      return "The " + e5 + " method is not implemented";
    }), a("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), a("ERR_STREAM_DESTROYED", function(e5) {
      return "Cannot call " + e5 + " after a stream was destroyed";
    }), a("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), a("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), a("ERR_STREAM_WRITE_AFTER_END", "write after end"), a("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), a("ERR_UNKNOWN_ENCODING", function(e5) {
      return "Unknown encoding: " + e5;
    }, TypeError), a("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t.exports.codes = n;
  }, {}], 67: [function(e4, t, i) {
    (function(i2) {
      (function() {
        var r = Object.keys || function(e5) {
          var t2 = [];
          for (var i3 in e5)
            t2.push(i3);
          return t2;
        };
        t.exports = u;
        var n = e4("./_stream_readable"), a = e4("./_stream_writable");
        e4("inherits")(u, n);
        for (var o = r(a.prototype), s = 0;s < o.length; s++) {
          var l = o[s];
          u.prototype[l] || (u.prototype[l] = a.prototype[l]);
        }
        function u(e5) {
          if (!(this instanceof u))
            return new u(e5);
          n.call(this, e5), a.call(this, e5), this.allowHalfOpen = true, e5 && (e5.readable === false && (this.readable = false), e5.writable === false && (this.writable = false), e5.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", h)));
        }
        function h() {
          this._writableState.ended || i2.nextTick(c, this);
        }
        function c(e5) {
          e5.end();
        }
        Object.defineProperty(u.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
          return this._writableState.highWaterMark;
        } }), Object.defineProperty(u.prototype, "writableBuffer", { enumerable: false, get: function() {
          return this._writableState && this._writableState.getBuffer();
        } }), Object.defineProperty(u.prototype, "writableLength", { enumerable: false, get: function() {
          return this._writableState.length;
        } }), Object.defineProperty(u.prototype, "destroyed", { enumerable: false, get: function() {
          return this._readableState !== undefined && this._writableState !== undefined && this._readableState.destroyed && this._writableState.destroyed;
        }, set: function(e5) {
          this._readableState !== undefined && this._writableState !== undefined && (this._readableState.destroyed = e5, this._writableState.destroyed = e5);
        } });
      }).call(this);
    }).call(this, e4("_process"));
  }, { "./_stream_readable": 69, "./_stream_writable": 71, _process: 63, inherits: 46 }], 68: [function(e4, t, i) {
    t.exports = n;
    var r = e4("./_stream_transform");
    function n(e5) {
      if (!(this instanceof n))
        return new n(e5);
      r.call(this, e5);
    }
    e4("inherits")(n, r), n.prototype._transform = function(e5, t2, i2) {
      i2(null, e5);
    };
  }, { "./_stream_transform": 70, inherits: 46 }], 69: [function(e4, t, i) {
    (function(i2, r) {
      (function() {
        var n;
        t.exports = M, M.ReadableState = I, e4("events").EventEmitter;
        var a = function(e5, t2) {
          return e5.listeners(t2).length;
        }, o = e4("./internal/streams/stream"), s = e4("buffer").Buffer, l = r.Uint8Array || function() {
        };
        function u(e5) {
          return s.from(e5);
        }
        function h(e5) {
          return s.isBuffer(e5) || e5 instanceof l;
        }
        var c, f = e4("util");
        c = f && f.debuglog ? f.debuglog("stream") : function() {
        };
        var d, p, m, _ = e4("./internal/streams/buffer_list"), g = e4("./internal/streams/destroy"), b2 = e4("./internal/streams/state").getHighWaterMark, y = e4("../errors").codes, w = y.ERR_INVALID_ARG_TYPE, v = y.ERR_STREAM_PUSH_AFTER_EOF, x = y.ERR_METHOD_NOT_IMPLEMENTED, E = y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
        e4("inherits")(M, o);
        var k = g.errorOrDestroy, S = ["error", "close", "destroy", "pause", "resume"];
        function A(e5, t2, i3) {
          if (typeof e5.prependListener == "function")
            return e5.prependListener(t2, i3);
          e5._events && e5._events[t2] ? Array.isArray(e5._events[t2]) ? e5._events[t2].unshift(i3) : e5._events[t2] = [i3, e5._events[t2]] : e5.on(t2, i3);
        }
        function I(t2, i3, r2) {
          n = n || e4("./_stream_duplex"), t2 = t2 || {}, typeof r2 != "boolean" && (r2 = i3 instanceof n), this.objectMode = !!t2.objectMode, r2 && (this.objectMode = this.objectMode || !!t2.readableObjectMode), this.highWaterMark = b2(this, t2, "readableHighWaterMark", r2), this.buffer = new _, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t2.emitClose !== false, this.autoDestroy = !!t2.autoDestroy, this.destroyed = false, this.defaultEncoding = t2.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t2.encoding && (d || (d = e4("string_decoder/").StringDecoder), this.decoder = new d(t2.encoding), this.encoding = t2.encoding);
        }
        function M(t2) {
          if (n = n || e4("./_stream_duplex"), !(this instanceof M))
            return new M(t2);
          var i3 = this instanceof n;
          this._readableState = new I(t2, this, i3), this.readable = true, t2 && (typeof t2.read == "function" && (this._read = t2.read), typeof t2.destroy == "function" && (this._destroy = t2.destroy)), o.call(this);
        }
        function T(e5, t2, i3, r2, n2) {
          c("readableAddChunk", t2);
          var a2, o2 = e5._readableState;
          if (t2 === null)
            o2.reading = false, F(e5, o2);
          else if (n2 || (a2 = B(o2, t2)), a2)
            k(e5, a2);
          else if (o2.objectMode || t2 && t2.length > 0)
            if (typeof t2 == "string" || o2.objectMode || Object.getPrototypeOf(t2) === s.prototype || (t2 = u(t2)), r2)
              o2.endEmitted ? k(e5, new E) : P(e5, o2, t2, true);
            else if (o2.ended)
              k(e5, new v);
            else {
              if (o2.destroyed)
                return false;
              o2.reading = false, o2.decoder && !i3 ? (t2 = o2.decoder.write(t2), o2.objectMode || t2.length !== 0 ? P(e5, o2, t2, false) : D(e5, o2)) : P(e5, o2, t2, false);
            }
          else
            r2 || (o2.reading = false, D(e5, o2));
          return !o2.ended && (o2.length < o2.highWaterMark || o2.length === 0);
        }
        function P(e5, t2, i3, r2) {
          t2.flowing && t2.length === 0 && !t2.sync ? (t2.awaitDrain = 0, e5.emit("data", i3)) : (t2.length += t2.objectMode ? 1 : i3.length, r2 ? t2.buffer.unshift(i3) : t2.buffer.push(i3), t2.needReadable && N(e5)), D(e5, t2);
        }
        function B(e5, t2) {
          var i3;
          return h(t2) || typeof t2 == "string" || t2 === undefined || e5.objectMode || (i3 = new w("chunk", ["string", "Buffer", "Uint8Array"], t2)), i3;
        }
        Object.defineProperty(M.prototype, "destroyed", { enumerable: false, get: function() {
          return this._readableState !== undefined && this._readableState.destroyed;
        }, set: function(e5) {
          this._readableState && (this._readableState.destroyed = e5);
        } }), M.prototype.destroy = g.destroy, M.prototype._undestroy = g.undestroy, M.prototype._destroy = function(e5, t2) {
          t2(e5);
        }, M.prototype.push = function(e5, t2) {
          var i3, r2 = this._readableState;
          return r2.objectMode ? i3 = true : typeof e5 == "string" && ((t2 = t2 || r2.defaultEncoding) !== r2.encoding && (e5 = s.from(e5, t2), t2 = ""), i3 = true), T(this, e5, t2, false, i3);
        }, M.prototype.unshift = function(e5) {
          return T(this, e5, null, true, false);
        }, M.prototype.isPaused = function() {
          return this._readableState.flowing === false;
        }, M.prototype.setEncoding = function(t2) {
          d || (d = e4("string_decoder/").StringDecoder);
          var i3 = new d(t2);
          this._readableState.decoder = i3, this._readableState.encoding = this._readableState.decoder.encoding;
          for (var r2 = this._readableState.buffer.head, n2 = "";r2 !== null; )
            n2 += i3.write(r2.data), r2 = r2.next;
          return this._readableState.buffer.clear(), n2 !== "" && this._readableState.buffer.push(n2), this._readableState.length = n2.length, this;
        };
        var C = 1073741824;
        function R(e5) {
          return e5 >= C ? e5 = C : (e5--, e5 |= e5 >>> 1, e5 |= e5 >>> 2, e5 |= e5 >>> 4, e5 |= e5 >>> 8, e5 |= e5 >>> 16, e5++), e5;
        }
        function z(e5, t2) {
          return e5 <= 0 || t2.length === 0 && t2.ended ? 0 : t2.objectMode ? 1 : e5 != e5 ? t2.flowing && t2.length ? t2.buffer.head.data.length : t2.length : (e5 > t2.highWaterMark && (t2.highWaterMark = R(e5)), e5 <= t2.length ? e5 : t2.ended ? t2.length : (t2.needReadable = true, 0));
        }
        function F(e5, t2) {
          if (c("onEofChunk"), !t2.ended) {
            if (t2.decoder) {
              var i3 = t2.decoder.end();
              i3 && i3.length && (t2.buffer.push(i3), t2.length += t2.objectMode ? 1 : i3.length);
            }
            t2.ended = true, t2.sync ? N(e5) : (t2.needReadable = false, t2.emittedReadable || (t2.emittedReadable = true, O(e5)));
          }
        }
        function N(e5) {
          var t2 = e5._readableState;
          c("emitReadable", t2.needReadable, t2.emittedReadable), t2.needReadable = false, t2.emittedReadable || (c("emitReadable", t2.flowing), t2.emittedReadable = true, i2.nextTick(O, e5));
        }
        function O(e5) {
          var t2 = e5._readableState;
          c("emitReadable_", t2.destroyed, t2.length, t2.ended), t2.destroyed || !t2.length && !t2.ended || (e5.emit("readable"), t2.emittedReadable = false), t2.needReadable = !t2.flowing && !t2.ended && t2.length <= t2.highWaterMark, H(e5);
        }
        function D(e5, t2) {
          t2.readingMore || (t2.readingMore = true, i2.nextTick($, e5, t2));
        }
        function $(e5, t2) {
          for (;!t2.reading && !t2.ended && (t2.length < t2.highWaterMark || t2.flowing && t2.length === 0); ) {
            var i3 = t2.length;
            if (c("maybeReadMore read 0"), e5.read(0), i3 === t2.length)
              break;
          }
          t2.readingMore = false;
        }
        function L(e5) {
          return function() {
            var t2 = e5._readableState;
            c("pipeOnDrain", t2.awaitDrain), t2.awaitDrain && t2.awaitDrain--, t2.awaitDrain === 0 && a(e5, "data") && (t2.flowing = true, H(e5));
          };
        }
        function U(e5) {
          var t2 = e5._readableState;
          t2.readableListening = e5.listenerCount("readable") > 0, t2.resumeScheduled && !t2.paused ? t2.flowing = true : e5.listenerCount("data") > 0 && e5.resume();
        }
        function Z(e5) {
          c("readable nexttick read 0"), e5.read(0);
        }
        function j(e5, t2) {
          t2.resumeScheduled || (t2.resumeScheduled = true, i2.nextTick(G, e5, t2));
        }
        function G(e5, t2) {
          c("resume", t2.reading), t2.reading || e5.read(0), t2.resumeScheduled = false, e5.emit("resume"), H(e5), t2.flowing && !t2.reading && e5.read(0);
        }
        function H(e5) {
          var t2 = e5._readableState;
          for (c("flow", t2.flowing);t2.flowing && e5.read() !== null; )
            ;
        }
        function Q(e5, t2) {
          return t2.length === 0 ? null : (t2.objectMode ? i3 = t2.buffer.shift() : !e5 || e5 >= t2.length ? (i3 = t2.decoder ? t2.buffer.join("") : t2.buffer.length === 1 ? t2.buffer.first() : t2.buffer.concat(t2.length), t2.buffer.clear()) : i3 = t2.buffer.consume(e5, t2.decoder), i3);
          var i3;
        }
        function W(e5) {
          var t2 = e5._readableState;
          c("endReadable", t2.endEmitted), t2.endEmitted || (t2.ended = true, i2.nextTick(q, t2, e5));
        }
        function q(e5, t2) {
          if (c("endReadableNT", e5.endEmitted, e5.length), !e5.endEmitted && e5.length === 0 && (e5.endEmitted = true, t2.readable = false, t2.emit("end"), e5.autoDestroy)) {
            var i3 = t2._writableState;
            (!i3 || i3.autoDestroy && i3.finished) && t2.destroy();
          }
        }
        function V(e5, t2) {
          for (var i3 = 0, r2 = e5.length;i3 < r2; i3++)
            if (e5[i3] === t2)
              return i3;
          return -1;
        }
        M.prototype.read = function(e5) {
          c("read", e5), e5 = parseInt(e5, 10);
          var t2 = this._readableState, i3 = e5;
          if (e5 !== 0 && (t2.emittedReadable = false), e5 === 0 && t2.needReadable && ((t2.highWaterMark !== 0 ? t2.length >= t2.highWaterMark : t2.length > 0) || t2.ended))
            return c("read: emitReadable", t2.length, t2.ended), t2.length === 0 && t2.ended ? W(this) : N(this), null;
          if ((e5 = z(e5, t2)) === 0 && t2.ended)
            return t2.length === 0 && W(this), null;
          var r2, n2 = t2.needReadable;
          return c("need readable", n2), (t2.length === 0 || t2.length - e5 < t2.highWaterMark) && c("length less than watermark", n2 = true), t2.ended || t2.reading ? c("reading or ended", n2 = false) : n2 && (c("do read"), t2.reading = true, t2.sync = true, t2.length === 0 && (t2.needReadable = true), this._read(t2.highWaterMark), t2.sync = false, t2.reading || (e5 = z(i3, t2))), (r2 = e5 > 0 ? Q(e5, t2) : null) === null ? (t2.needReadable = t2.length <= t2.highWaterMark, e5 = 0) : (t2.length -= e5, t2.awaitDrain = 0), t2.length === 0 && (t2.ended || (t2.needReadable = true), i3 !== e5 && t2.ended && W(this)), r2 !== null && this.emit("data", r2), r2;
        }, M.prototype._read = function(e5) {
          k(this, new x("_read()"));
        }, M.prototype.pipe = function(e5, t2) {
          var r2 = this, n2 = this._readableState;
          switch (n2.pipesCount) {
            case 0:
              n2.pipes = e5;
              break;
            case 1:
              n2.pipes = [n2.pipes, e5];
              break;
            default:
              n2.pipes.push(e5);
          }
          n2.pipesCount += 1, c("pipe count=%d opts=%j", n2.pipesCount, t2);
          var o2 = t2 && t2.end === false || e5 === i2.stdout || e5 === i2.stderr ? g2 : l2;
          function s2(e6, t3) {
            c("onunpipe"), e6 === r2 && t3 && t3.hasUnpiped === false && (t3.hasUnpiped = true, f2());
          }
          function l2() {
            c("onend"), e5.end();
          }
          n2.endEmitted ? i2.nextTick(o2) : r2.once("end", o2), e5.on("unpipe", s2);
          var u2 = L(r2);
          e5.on("drain", u2);
          var h2 = false;
          function f2() {
            c("cleanup"), e5.removeListener("close", m2), e5.removeListener("finish", _2), e5.removeListener("drain", u2), e5.removeListener("error", p2), e5.removeListener("unpipe", s2), r2.removeListener("end", l2), r2.removeListener("end", g2), r2.removeListener("data", d2), h2 = true, !n2.awaitDrain || e5._writableState && !e5._writableState.needDrain || u2();
          }
          function d2(t3) {
            c("ondata");
            var i3 = e5.write(t3);
            c("dest.write", i3), i3 === false && ((n2.pipesCount === 1 && n2.pipes === e5 || n2.pipesCount > 1 && V(n2.pipes, e5) !== -1) && !h2 && (c("false write response, pause", n2.awaitDrain), n2.awaitDrain++), r2.pause());
          }
          function p2(t3) {
            c("onerror", t3), g2(), e5.removeListener("error", p2), a(e5, "error") === 0 && k(e5, t3);
          }
          function m2() {
            e5.removeListener("finish", _2), g2();
          }
          function _2() {
            c("onfinish"), e5.removeListener("close", m2), g2();
          }
          function g2() {
            c("unpipe"), r2.unpipe(e5);
          }
          return r2.on("data", d2), A(e5, "error", p2), e5.once("close", m2), e5.once("finish", _2), e5.emit("pipe", r2), n2.flowing || (c("pipe resume"), r2.resume()), e5;
        }, M.prototype.unpipe = function(e5) {
          var t2 = this._readableState, i3 = { hasUnpiped: false };
          if (t2.pipesCount === 0)
            return this;
          if (t2.pipesCount === 1)
            return e5 && e5 !== t2.pipes || (e5 || (e5 = t2.pipes), t2.pipes = null, t2.pipesCount = 0, t2.flowing = false, e5 && e5.emit("unpipe", this, i3)), this;
          if (!e5) {
            var { pipes: r2, pipesCount: n2 } = t2;
            t2.pipes = null, t2.pipesCount = 0, t2.flowing = false;
            for (var a2 = 0;a2 < n2; a2++)
              r2[a2].emit("unpipe", this, { hasUnpiped: false });
            return this;
          }
          var o2 = V(t2.pipes, e5);
          return o2 === -1 || (t2.pipes.splice(o2, 1), t2.pipesCount -= 1, t2.pipesCount === 1 && (t2.pipes = t2.pipes[0]), e5.emit("unpipe", this, i3)), this;
        }, M.prototype.on = function(e5, t2) {
          var r2 = o.prototype.on.call(this, e5, t2), n2 = this._readableState;
          return e5 === "data" ? (n2.readableListening = this.listenerCount("readable") > 0, n2.flowing !== false && this.resume()) : e5 === "readable" && (n2.endEmitted || n2.readableListening || (n2.readableListening = n2.needReadable = true, n2.flowing = false, n2.emittedReadable = false, c("on readable", n2.length, n2.reading), n2.length ? N(this) : n2.reading || i2.nextTick(Z, this))), r2;
        }, M.prototype.addListener = M.prototype.on, M.prototype.removeListener = function(e5, t2) {
          var r2 = o.prototype.removeListener.call(this, e5, t2);
          return e5 === "readable" && i2.nextTick(U, this), r2;
        }, M.prototype.removeAllListeners = function(e5) {
          var t2 = o.prototype.removeAllListeners.apply(this, arguments);
          return e5 !== "readable" && e5 !== undefined || i2.nextTick(U, this), t2;
        }, M.prototype.resume = function() {
          var e5 = this._readableState;
          return e5.flowing || (c("resume"), e5.flowing = !e5.readableListening, j(this, e5)), e5.paused = false, this;
        }, M.prototype.pause = function() {
          return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (c("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
        }, M.prototype.wrap = function(e5) {
          var t2 = this, i3 = this._readableState, r2 = false;
          for (var n2 in e5.on("end", function() {
            if (c("wrapped end"), i3.decoder && !i3.ended) {
              var e6 = i3.decoder.end();
              e6 && e6.length && t2.push(e6);
            }
            t2.push(null);
          }), e5.on("data", function(n3) {
            c("wrapped data"), i3.decoder && (n3 = i3.decoder.write(n3)), i3.objectMode && n3 == null || (i3.objectMode || n3 && n3.length) && (t2.push(n3) || (r2 = true, e5.pause()));
          }), e5)
            this[n2] === undefined && typeof e5[n2] == "function" && (this[n2] = function(t3) {
              return function() {
                return e5[t3].apply(e5, arguments);
              };
            }(n2));
          for (var a2 = 0;a2 < S.length; a2++)
            e5.on(S[a2], this.emit.bind(this, S[a2]));
          return this._read = function(t3) {
            c("wrapped _read", t3), r2 && (r2 = false, e5.resume());
          }, this;
        }, typeof Symbol == "function" && (M.prototype[Symbol.asyncIterator] = function() {
          return p === undefined && (p = e4("./internal/streams/async_iterator")), p(this);
        }), Object.defineProperty(M.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
          return this._readableState.highWaterMark;
        } }), Object.defineProperty(M.prototype, "readableBuffer", { enumerable: false, get: function() {
          return this._readableState && this._readableState.buffer;
        } }), Object.defineProperty(M.prototype, "readableFlowing", { enumerable: false, get: function() {
          return this._readableState.flowing;
        }, set: function(e5) {
          this._readableState && (this._readableState.flowing = e5);
        } }), M._fromList = Q, Object.defineProperty(M.prototype, "readableLength", { enumerable: false, get: function() {
          return this._readableState.length;
        } }), typeof Symbol == "function" && (M.from = function(t2, i3) {
          return m === undefined && (m = e4("./internal/streams/from")), m(M, t2, i3);
        });
      }).call(this);
    }).call(this, e4("_process"), commonjsGlobal !== undefined ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { "../errors": 66, "./_stream_duplex": 67, "./internal/streams/async_iterator": 72, "./internal/streams/buffer_list": 73, "./internal/streams/destroy": 74, "./internal/streams/from": 76, "./internal/streams/state": 78, "./internal/streams/stream": 79, _process: 63, buffer: 32, events: 35, inherits: 46, "string_decoder/": 80, util: 29 }], 70: [function(e4, t, i) {
    t.exports = h;
    var r = e4("../errors").codes, n = r.ERR_METHOD_NOT_IMPLEMENTED, a = r.ERR_MULTIPLE_CALLBACK, o = r.ERR_TRANSFORM_ALREADY_TRANSFORMING, s = r.ERR_TRANSFORM_WITH_LENGTH_0, l = e4("./_stream_duplex");
    function u(e5, t2) {
      var i2 = this._transformState;
      i2.transforming = false;
      var r2 = i2.writecb;
      if (r2 === null)
        return this.emit("error", new a);
      i2.writechunk = null, i2.writecb = null, t2 != null && this.push(t2), r2(e5);
      var n2 = this._readableState;
      n2.reading = false, (n2.needReadable || n2.length < n2.highWaterMark) && this._read(n2.highWaterMark);
    }
    function h(e5) {
      if (!(this instanceof h))
        return new h(e5);
      l.call(this, e5), this._transformState = { afterTransform: u.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e5 && (typeof e5.transform == "function" && (this._transform = e5.transform), typeof e5.flush == "function" && (this._flush = e5.flush)), this.on("prefinish", c);
    }
    function c() {
      var e5 = this;
      typeof this._flush != "function" || this._readableState.destroyed ? f(this, null, null) : this._flush(function(t2, i2) {
        f(e5, t2, i2);
      });
    }
    function f(e5, t2, i2) {
      if (t2)
        return e5.emit("error", t2);
      if (i2 != null && e5.push(i2), e5._writableState.length)
        throw new s;
      if (e5._transformState.transforming)
        throw new o;
      return e5.push(null);
    }
    e4("inherits")(h, l), h.prototype.push = function(e5, t2) {
      return this._transformState.needTransform = false, l.prototype.push.call(this, e5, t2);
    }, h.prototype._transform = function(e5, t2, i2) {
      i2(new n("_transform()"));
    }, h.prototype._write = function(e5, t2, i2) {
      var r2 = this._transformState;
      if (r2.writecb = i2, r2.writechunk = e5, r2.writeencoding = t2, !r2.transforming) {
        var n2 = this._readableState;
        (r2.needTransform || n2.needReadable || n2.length < n2.highWaterMark) && this._read(n2.highWaterMark);
      }
    }, h.prototype._read = function(e5) {
      var t2 = this._transformState;
      t2.writechunk === null || t2.transforming ? t2.needTransform = true : (t2.transforming = true, this._transform(t2.writechunk, t2.writeencoding, t2.afterTransform));
    }, h.prototype._destroy = function(e5, t2) {
      l.prototype._destroy.call(this, e5, function(e6) {
        t2(e6);
      });
    };
  }, { "../errors": 66, "./_stream_duplex": 67, inherits: 46 }], 71: [function(e4, t, i) {
    (function(i2, r) {
      (function() {
        function n(e5) {
          var t2 = this;
          this.next = null, this.entry = null, this.finish = function() {
            G(t2, e5);
          };
        }
        var a;
        t.exports = I, I.WritableState = A;
        var o = { deprecate: e4("util-deprecate") }, s = e4("./internal/streams/stream"), l = e4("buffer").Buffer, u = r.Uint8Array || function() {
        };
        function h(e5) {
          return l.from(e5);
        }
        function c(e5) {
          return l.isBuffer(e5) || e5 instanceof u;
        }
        var f, d = e4("./internal/streams/destroy"), p = e4("./internal/streams/state").getHighWaterMark, m = e4("../errors").codes, _ = m.ERR_INVALID_ARG_TYPE, g = m.ERR_METHOD_NOT_IMPLEMENTED, b2 = m.ERR_MULTIPLE_CALLBACK, y = m.ERR_STREAM_CANNOT_PIPE, w = m.ERR_STREAM_DESTROYED, v = m.ERR_STREAM_NULL_VALUES, x = m.ERR_STREAM_WRITE_AFTER_END, E = m.ERR_UNKNOWN_ENCODING, k = d.errorOrDestroy;
        function S() {
        }
        function A(t2, i3, r2) {
          a = a || e4("./_stream_duplex"), t2 = t2 || {}, typeof r2 != "boolean" && (r2 = i3 instanceof a), this.objectMode = !!t2.objectMode, r2 && (this.objectMode = this.objectMode || !!t2.writableObjectMode), this.highWaterMark = p(this, t2, "writableHighWaterMark", r2), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
          var o2 = t2.decodeStrings === false;
          this.decodeStrings = !o2, this.defaultEncoding = t2.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e5) {
            F(i3, e5);
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t2.emitClose !== false, this.autoDestroy = !!t2.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new n(this);
        }
        function I(t2) {
          var i3 = this instanceof (a = a || e4("./_stream_duplex"));
          if (!i3 && !f.call(I, this))
            return new I(t2);
          this._writableState = new A(t2, this, i3), this.writable = true, t2 && (typeof t2.write == "function" && (this._write = t2.write), typeof t2.writev == "function" && (this._writev = t2.writev), typeof t2.destroy == "function" && (this._destroy = t2.destroy), typeof t2.final == "function" && (this._final = t2.final)), s.call(this);
        }
        function M(e5, t2) {
          var r2 = new x;
          k(e5, r2), i2.nextTick(t2, r2);
        }
        function T(e5, t2, r2, n2) {
          var a2;
          return r2 === null ? a2 = new v : typeof r2 == "string" || t2.objectMode || (a2 = new _("chunk", ["string", "Buffer"], r2)), !a2 || (k(e5, a2), i2.nextTick(n2, a2), false);
        }
        function P(e5, t2, i3) {
          return e5.objectMode || e5.decodeStrings === false || typeof t2 != "string" || (t2 = l.from(t2, i3)), t2;
        }
        function B(e5, t2, i3, r2, n2, a2) {
          if (!i3) {
            var o2 = P(t2, r2, n2);
            r2 !== o2 && (i3 = true, n2 = "buffer", r2 = o2);
          }
          var s2 = t2.objectMode ? 1 : r2.length;
          t2.length += s2;
          var l2 = t2.length < t2.highWaterMark;
          if (l2 || (t2.needDrain = true), t2.writing || t2.corked) {
            var u2 = t2.lastBufferedRequest;
            t2.lastBufferedRequest = { chunk: r2, encoding: n2, isBuf: i3, callback: a2, next: null }, u2 ? u2.next = t2.lastBufferedRequest : t2.bufferedRequest = t2.lastBufferedRequest, t2.bufferedRequestCount += 1;
          } else
            C(e5, t2, false, s2, r2, n2, a2);
          return l2;
        }
        function C(e5, t2, i3, r2, n2, a2, o2) {
          t2.writelen = r2, t2.writecb = o2, t2.writing = true, t2.sync = true, t2.destroyed ? t2.onwrite(new w("write")) : i3 ? e5._writev(n2, t2.onwrite) : e5._write(n2, a2, t2.onwrite), t2.sync = false;
        }
        function R(e5, t2, r2, n2, a2) {
          --t2.pendingcb, r2 ? (i2.nextTick(a2, n2), i2.nextTick(Z, e5, t2), e5._writableState.errorEmitted = true, k(e5, n2)) : (a2(n2), e5._writableState.errorEmitted = true, k(e5, n2), Z(e5, t2));
        }
        function z(e5) {
          e5.writing = false, e5.writecb = null, e5.length -= e5.writelen, e5.writelen = 0;
        }
        function F(e5, t2) {
          var r2 = e5._writableState, n2 = r2.sync, a2 = r2.writecb;
          if (typeof a2 != "function")
            throw new b2;
          if (z(r2), t2)
            R(e5, r2, n2, t2, a2);
          else {
            var o2 = $(r2) || e5.destroyed;
            o2 || r2.corked || r2.bufferProcessing || !r2.bufferedRequest || D(e5, r2), n2 ? i2.nextTick(N, e5, r2, o2, a2) : N(e5, r2, o2, a2);
          }
        }
        function N(e5, t2, i3, r2) {
          i3 || O(e5, t2), t2.pendingcb--, r2(), Z(e5, t2);
        }
        function O(e5, t2) {
          t2.length === 0 && t2.needDrain && (t2.needDrain = false, e5.emit("drain"));
        }
        function D(e5, t2) {
          t2.bufferProcessing = true;
          var i3 = t2.bufferedRequest;
          if (e5._writev && i3 && i3.next) {
            var r2 = t2.bufferedRequestCount, a2 = new Array(r2), o2 = t2.corkedRequestsFree;
            o2.entry = i3;
            for (var s2 = 0, l2 = true;i3; )
              a2[s2] = i3, i3.isBuf || (l2 = false), i3 = i3.next, s2 += 1;
            a2.allBuffers = l2, C(e5, t2, true, t2.length, a2, "", o2.finish), t2.pendingcb++, t2.lastBufferedRequest = null, o2.next ? (t2.corkedRequestsFree = o2.next, o2.next = null) : t2.corkedRequestsFree = new n(t2), t2.bufferedRequestCount = 0;
          } else {
            for (;i3; ) {
              var { chunk: u2, encoding: h2, callback: c2 } = i3;
              if (C(e5, t2, false, t2.objectMode ? 1 : u2.length, u2, h2, c2), i3 = i3.next, t2.bufferedRequestCount--, t2.writing)
                break;
            }
            i3 === null && (t2.lastBufferedRequest = null);
          }
          t2.bufferedRequest = i3, t2.bufferProcessing = false;
        }
        function $(e5) {
          return e5.ending && e5.length === 0 && e5.bufferedRequest === null && !e5.finished && !e5.writing;
        }
        function L(e5, t2) {
          e5._final(function(i3) {
            t2.pendingcb--, i3 && k(e5, i3), t2.prefinished = true, e5.emit("prefinish"), Z(e5, t2);
          });
        }
        function U(e5, t2) {
          t2.prefinished || t2.finalCalled || (typeof e5._final != "function" || t2.destroyed ? (t2.prefinished = true, e5.emit("prefinish")) : (t2.pendingcb++, t2.finalCalled = true, i2.nextTick(L, e5, t2)));
        }
        function Z(e5, t2) {
          var i3 = $(t2);
          if (i3 && (U(e5, t2), t2.pendingcb === 0 && (t2.finished = true, e5.emit("finish"), t2.autoDestroy))) {
            var r2 = e5._readableState;
            (!r2 || r2.autoDestroy && r2.endEmitted) && e5.destroy();
          }
          return i3;
        }
        function j(e5, t2, r2) {
          t2.ending = true, Z(e5, t2), r2 && (t2.finished ? i2.nextTick(r2) : e5.once("finish", r2)), t2.ended = true, e5.writable = false;
        }
        function G(e5, t2, i3) {
          var r2 = e5.entry;
          for (e5.entry = null;r2; ) {
            var n2 = r2.callback;
            t2.pendingcb--, n2(i3), r2 = r2.next;
          }
          t2.corkedRequestsFree.next = e5;
        }
        e4("inherits")(I, s), A.prototype.getBuffer = function() {
          for (var e5 = this.bufferedRequest, t2 = [];e5; )
            t2.push(e5), e5 = e5.next;
          return t2;
        }, function() {
          try {
            Object.defineProperty(A.prototype, "buffer", { get: o.deprecate(function() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
          } catch (e5) {
          }
        }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (f = Function.prototype[Symbol.hasInstance], Object.defineProperty(I, Symbol.hasInstance, { value: function(e5) {
          return !!f.call(this, e5) || this === I && e5 && e5._writableState instanceof A;
        } })) : f = function(e5) {
          return e5 instanceof this;
        }, I.prototype.pipe = function() {
          k(this, new y);
        }, I.prototype.write = function(e5, t2, i3) {
          var r2 = this._writableState, n2 = false, a2 = !r2.objectMode && c(e5);
          return a2 && !l.isBuffer(e5) && (e5 = h(e5)), typeof t2 == "function" && (i3 = t2, t2 = null), a2 ? t2 = "buffer" : t2 || (t2 = r2.defaultEncoding), typeof i3 != "function" && (i3 = S), r2.ending ? M(this, i3) : (a2 || T(this, r2, e5, i3)) && (r2.pendingcb++, n2 = B(this, r2, a2, e5, t2, i3)), n2;
        }, I.prototype.cork = function() {
          this._writableState.corked++;
        }, I.prototype.uncork = function() {
          var e5 = this._writableState;
          e5.corked && (e5.corked--, e5.writing || e5.corked || e5.bufferProcessing || !e5.bufferedRequest || D(this, e5));
        }, I.prototype.setDefaultEncoding = function(e5) {
          if (typeof e5 == "string" && (e5 = e5.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e5 + "").toLowerCase()) > -1))
            throw new E(e5);
          return this._writableState.defaultEncoding = e5, this;
        }, Object.defineProperty(I.prototype, "writableBuffer", { enumerable: false, get: function() {
          return this._writableState && this._writableState.getBuffer();
        } }), Object.defineProperty(I.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
          return this._writableState.highWaterMark;
        } }), I.prototype._write = function(e5, t2, i3) {
          i3(new g("_write()"));
        }, I.prototype._writev = null, I.prototype.end = function(e5, t2, i3) {
          var r2 = this._writableState;
          return typeof e5 == "function" ? (i3 = e5, e5 = null, t2 = null) : typeof t2 == "function" && (i3 = t2, t2 = null), e5 != null && this.write(e5, t2), r2.corked && (r2.corked = 1, this.uncork()), r2.ending || j(this, r2, i3), this;
        }, Object.defineProperty(I.prototype, "writableLength", { enumerable: false, get: function() {
          return this._writableState.length;
        } }), Object.defineProperty(I.prototype, "destroyed", { enumerable: false, get: function() {
          return this._writableState !== undefined && this._writableState.destroyed;
        }, set: function(e5) {
          this._writableState && (this._writableState.destroyed = e5);
        } }), I.prototype.destroy = d.destroy, I.prototype._undestroy = d.undestroy, I.prototype._destroy = function(e5, t2) {
          t2(e5);
        };
      }).call(this);
    }).call(this, e4("_process"), commonjsGlobal !== undefined ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { "../errors": 66, "./_stream_duplex": 67, "./internal/streams/destroy": 74, "./internal/streams/state": 78, "./internal/streams/stream": 79, _process: 63, buffer: 32, inherits: 46, "util-deprecate": 81 }], 72: [function(e4, t, i) {
    (function(i2) {
      (function() {
        var r;
        function n(e5, t2, i3) {
          return t2 in e5 ? Object.defineProperty(e5, t2, { value: i3, enumerable: true, configurable: true, writable: true }) : e5[t2] = i3, e5;
        }
        var a = e4("./end-of-stream"), o = Symbol("lastResolve"), s = Symbol("lastReject"), l = Symbol("error"), u = Symbol("ended"), h = Symbol("lastPromise"), c = Symbol("handlePromise"), f = Symbol("stream");
        function d(e5, t2) {
          return { value: e5, done: t2 };
        }
        function p(e5) {
          var t2 = e5[o];
          if (t2 !== null) {
            var i3 = e5[f].read();
            i3 !== null && (e5[h] = null, e5[o] = null, e5[s] = null, t2(d(i3, false)));
          }
        }
        function m(e5) {
          i2.nextTick(p, e5);
        }
        function _(e5, t2) {
          return function(i3, r2) {
            e5.then(function() {
              t2[u] ? i3(d(undefined, true)) : t2[c](i3, r2);
            }, r2);
          };
        }
        var g = Object.getPrototypeOf(function() {
        }), b2 = Object.setPrototypeOf((r = { get stream() {
          return this[f];
        }, next: function() {
          var e5 = this, t2 = this[l];
          if (t2 !== null)
            return Promise.reject(t2);
          if (this[u])
            return Promise.resolve(d(undefined, true));
          if (this[f].destroyed)
            return new Promise(function(t3, r3) {
              i2.nextTick(function() {
                e5[l] ? r3(e5[l]) : t3(d(undefined, true));
              });
            });
          var r2, n2 = this[h];
          if (n2)
            r2 = new Promise(_(n2, this));
          else {
            var a2 = this[f].read();
            if (a2 !== null)
              return Promise.resolve(d(a2, false));
            r2 = new Promise(this[c]);
          }
          return this[h] = r2, r2;
        } }, n(r, Symbol.asyncIterator, function() {
          return this;
        }), n(r, "return", function() {
          var e5 = this;
          return new Promise(function(t2, i3) {
            e5[f].destroy(null, function(e6) {
              e6 ? i3(e6) : t2(d(undefined, true));
            });
          });
        }), r), g), y = function(e5) {
          var t2, i3 = Object.create(b2, (n(t2 = {}, f, { value: e5, writable: true }), n(t2, o, { value: null, writable: true }), n(t2, s, { value: null, writable: true }), n(t2, l, { value: null, writable: true }), n(t2, u, { value: e5._readableState.endEmitted, writable: true }), n(t2, c, { value: function(e6, t3) {
            var r2 = i3[f].read();
            r2 ? (i3[h] = null, i3[o] = null, i3[s] = null, e6(d(r2, false))) : (i3[o] = e6, i3[s] = t3);
          }, writable: true }), t2));
          return i3[h] = null, a(e5, function(e6) {
            if (e6 && e6.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              var t3 = i3[s];
              return t3 !== null && (i3[h] = null, i3[o] = null, i3[s] = null, t3(e6)), void (i3[l] = e6);
            }
            var r2 = i3[o];
            r2 !== null && (i3[h] = null, i3[o] = null, i3[s] = null, r2(d(undefined, true))), i3[u] = true;
          }), e5.on("readable", m.bind(null, i3)), i3;
        };
        t.exports = y;
      }).call(this);
    }).call(this, e4("_process"));
  }, { "./end-of-stream": 75, _process: 63 }], 73: [function(e4, t, i) {
    function r(e5, t2) {
      var i2 = Object.keys(e5);
      if (Object.getOwnPropertySymbols) {
        var r2 = Object.getOwnPropertySymbols(e5);
        t2 && (r2 = r2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e5, t3).enumerable;
        })), i2.push.apply(i2, r2);
      }
      return i2;
    }
    function n(e5) {
      for (var t2 = 1;t2 < arguments.length; t2++) {
        var i2 = arguments[t2] != null ? arguments[t2] : {};
        t2 % 2 ? r(Object(i2), true).forEach(function(t3) {
          a(e5, t3, i2[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(i2)) : r(Object(i2)).forEach(function(t3) {
          Object.defineProperty(e5, t3, Object.getOwnPropertyDescriptor(i2, t3));
        });
      }
      return e5;
    }
    function a(e5, t2, i2) {
      return t2 in e5 ? Object.defineProperty(e5, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e5[t2] = i2, e5;
    }
    function o(e5, t2) {
      if (!(e5 instanceof t2))
        throw new TypeError("Cannot call a class as a function");
    }
    function s(e5, t2) {
      for (var i2 = 0;i2 < t2.length; i2++) {
        var r2 = t2[i2];
        r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e5, r2.key, r2);
      }
    }
    function l(e5, t2, i2) {
      return t2 && s(e5.prototype, t2), e5;
    }
    var u = e4("buffer").Buffer, h = e4("util").inspect, c = h && h.custom || "inspect";
    function f(e5, t2, i2) {
      u.prototype.copy.call(e5, t2, i2);
    }
    t.exports = function() {
      function e5() {
        o(this, e5), this.head = null, this.tail = null, this.length = 0;
      }
      return l(e5, [{ key: "push", value: function(e6) {
        var t2 = { data: e6, next: null };
        this.length > 0 ? this.tail.next = t2 : this.head = t2, this.tail = t2, ++this.length;
      } }, { key: "unshift", value: function(e6) {
        var t2 = { data: e6, next: this.head };
        this.length === 0 && (this.tail = t2), this.head = t2, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var e6 = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, e6;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(e6) {
        if (this.length === 0)
          return "";
        for (var t2 = this.head, i2 = "" + t2.data;t2 = t2.next; )
          i2 += e6 + t2.data;
        return i2;
      } }, { key: "concat", value: function(e6) {
        if (this.length === 0)
          return u.alloc(0);
        for (var t2 = u.allocUnsafe(e6 >>> 0), i2 = this.head, r2 = 0;i2; )
          f(i2.data, t2, r2), r2 += i2.data.length, i2 = i2.next;
        return t2;
      } }, { key: "consume", value: function(e6, t2) {
        var i2;
        return e6 < this.head.data.length ? (i2 = this.head.data.slice(0, e6), this.head.data = this.head.data.slice(e6)) : i2 = e6 === this.head.data.length ? this.shift() : t2 ? this._getString(e6) : this._getBuffer(e6), i2;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(e6) {
        var t2 = this.head, i2 = 1, r2 = t2.data;
        for (e6 -= r2.length;t2 = t2.next; ) {
          var n2 = t2.data, a2 = e6 > n2.length ? n2.length : e6;
          if (a2 === n2.length ? r2 += n2 : r2 += n2.slice(0, e6), (e6 -= a2) == 0) {
            a2 === n2.length ? (++i2, t2.next ? this.head = t2.next : this.head = this.tail = null) : (this.head = t2, t2.data = n2.slice(a2));
            break;
          }
          ++i2;
        }
        return this.length -= i2, r2;
      } }, { key: "_getBuffer", value: function(e6) {
        var t2 = u.allocUnsafe(e6), i2 = this.head, r2 = 1;
        for (i2.data.copy(t2), e6 -= i2.data.length;i2 = i2.next; ) {
          var n2 = i2.data, a2 = e6 > n2.length ? n2.length : e6;
          if (n2.copy(t2, t2.length - e6, 0, a2), (e6 -= a2) == 0) {
            a2 === n2.length ? (++r2, i2.next ? this.head = i2.next : this.head = this.tail = null) : (this.head = i2, i2.data = n2.slice(a2));
            break;
          }
          ++r2;
        }
        return this.length -= r2, t2;
      } }, { key: c, value: function(e6, t2) {
        return h(this, n({}, t2, { depth: 0, customInspect: false }));
      } }]), e5;
    }();
  }, { buffer: 32, util: 29 }], 74: [function(e4, t, i) {
    (function(e5) {
      (function() {
        function i2(t2, i3) {
          var a2 = this, s2 = this._readableState && this._readableState.destroyed, l = this._writableState && this._writableState.destroyed;
          return s2 || l ? (i3 ? i3(t2) : t2 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, e5.nextTick(o, this, t2)) : e5.nextTick(o, this, t2)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t2 || null, function(t3) {
            !i3 && t3 ? a2._writableState ? a2._writableState.errorEmitted ? e5.nextTick(n, a2) : (a2._writableState.errorEmitted = true, e5.nextTick(r, a2, t3)) : e5.nextTick(r, a2, t3) : i3 ? (e5.nextTick(n, a2), i3(t3)) : e5.nextTick(n, a2);
          }), this);
        }
        function r(e6, t2) {
          o(e6, t2), n(e6);
        }
        function n(e6) {
          e6._writableState && !e6._writableState.emitClose || e6._readableState && !e6._readableState.emitClose || e6.emit("close");
        }
        function a() {
          this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
        }
        function o(e6, t2) {
          e6.emit("error", t2);
        }
        function s(e6, t2) {
          var { _readableState: i3, _writableState: r2 } = e6;
          i3 && i3.autoDestroy || r2 && r2.autoDestroy ? e6.destroy(t2) : e6.emit("error", t2);
        }
        t.exports = { destroy: i2, undestroy: a, errorOrDestroy: s };
      }).call(this);
    }).call(this, e4("_process"));
  }, { _process: 63 }], 75: [function(e4, t, i) {
    var r = e4("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
    function n(e5) {
      var t2 = false;
      return function() {
        if (!t2) {
          t2 = true;
          for (var i2 = arguments.length, r2 = new Array(i2), n2 = 0;n2 < i2; n2++)
            r2[n2] = arguments[n2];
          e5.apply(this, r2);
        }
      };
    }
    function a() {
    }
    function o(e5) {
      return e5.setHeader && typeof e5.abort == "function";
    }
    function s(e5, t2, i2) {
      if (typeof t2 == "function")
        return s(e5, null, t2);
      t2 || (t2 = {}), i2 = n(i2 || a);
      var l = t2.readable || t2.readable !== false && e5.readable, u = t2.writable || t2.writable !== false && e5.writable, h = function() {
        e5.writable || f();
      }, c = e5._writableState && e5._writableState.finished, f = function() {
        u = false, c = true, l || i2.call(e5);
      }, d = e5._readableState && e5._readableState.endEmitted, p = function() {
        l = false, d = true, u || i2.call(e5);
      }, m = function(t3) {
        i2.call(e5, t3);
      }, _ = function() {
        var t3;
        return l && !d ? (e5._readableState && e5._readableState.ended || (t3 = new r), i2.call(e5, t3)) : u && !c ? (e5._writableState && e5._writableState.ended || (t3 = new r), i2.call(e5, t3)) : undefined;
      }, g = function() {
        e5.req.on("finish", f);
      };
      return o(e5) ? (e5.on("complete", f), e5.on("abort", _), e5.req ? g() : e5.on("request", g)) : u && !e5._writableState && (e5.on("end", h), e5.on("close", h)), e5.on("end", p), e5.on("finish", f), t2.error !== false && e5.on("error", m), e5.on("close", _), function() {
        e5.removeListener("complete", f), e5.removeListener("abort", _), e5.removeListener("request", g), e5.req && e5.req.removeListener("finish", f), e5.removeListener("end", h), e5.removeListener("close", h), e5.removeListener("finish", f), e5.removeListener("end", p), e5.removeListener("error", m), e5.removeListener("close", _);
      };
    }
    t.exports = s;
  }, { "../../../errors": 66 }], 76: [function(e4, t, i) {
    t.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }, {}], 77: [function(e4, t, i) {
    var r;
    function n(e5) {
      var t2 = false;
      return function() {
        t2 || (t2 = true, e5.apply(undefined, arguments));
      };
    }
    var a = e4("../../../errors").codes, o = a.ERR_MISSING_ARGS, s = a.ERR_STREAM_DESTROYED;
    function l(e5) {
      if (e5)
        throw e5;
    }
    function u(e5) {
      return e5.setHeader && typeof e5.abort == "function";
    }
    function h(t2, i2, a2, o2) {
      o2 = n(o2);
      var l2 = false;
      t2.on("close", function() {
        l2 = true;
      }), r === undefined && (r = e4("./end-of-stream")), r(t2, { readable: i2, writable: a2 }, function(e5) {
        if (e5)
          return o2(e5);
        l2 = true, o2();
      });
      var h2 = false;
      return function(e5) {
        if (!l2 && !h2)
          return h2 = true, u(t2) ? t2.abort() : typeof t2.destroy == "function" ? t2.destroy() : void o2(e5 || new s("pipe"));
      };
    }
    function c(e5) {
      e5();
    }
    function f(e5, t2) {
      return e5.pipe(t2);
    }
    function d(e5) {
      return e5.length ? typeof e5[e5.length - 1] != "function" ? l : e5.pop() : l;
    }
    function p() {
      for (var e5 = arguments.length, t2 = new Array(e5), i2 = 0;i2 < e5; i2++)
        t2[i2] = arguments[i2];
      var r2, n2 = d(t2);
      if (Array.isArray(t2[0]) && (t2 = t2[0]), t2.length < 2)
        throw new o("streams");
      var a2 = t2.map(function(e6, i3) {
        var o2 = i3 < t2.length - 1;
        return h(e6, o2, i3 > 0, function(e7) {
          r2 || (r2 = e7), e7 && a2.forEach(c), o2 || (a2.forEach(c), n2(r2));
        });
      });
      return t2.reduce(f);
    }
    t.exports = p;
  }, { "../../../errors": 66, "./end-of-stream": 75 }], 78: [function(e4, t, i) {
    var r = e4("../../../errors").codes.ERR_INVALID_OPT_VALUE;
    function n(e5, t2, i2) {
      return e5.highWaterMark != null ? e5.highWaterMark : t2 ? e5[i2] : null;
    }
    function a(e5, t2, i2, a2) {
      var o = n(t2, a2, i2);
      if (o != null) {
        if (!isFinite(o) || Math.floor(o) !== o || o < 0)
          throw new r(a2 ? i2 : "highWaterMark", o);
        return Math.floor(o);
      }
      return e5.objectMode ? 16 : 16384;
    }
    t.exports = { getHighWaterMark: a };
  }, { "../../../errors": 66 }], 79: [function(e4, t, i) {
    t.exports = e4("events").EventEmitter;
  }, { events: 35 }], 80: [function(e4, t, i) {
    var r = e4("safe-buffer").Buffer, n = r.isEncoding || function(e5) {
      switch ((e5 = "" + e5) && e5.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function a(e5) {
      if (!e5)
        return "utf8";
      for (var t2;; )
        switch (e5) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e5;
          default:
            if (t2)
              return;
            e5 = ("" + e5).toLowerCase(), t2 = true;
        }
    }
    function o(e5) {
      var t2 = a(e5);
      if (typeof t2 != "string" && (r.isEncoding === n || !n(e5)))
        throw new Error("Unknown encoding: " + e5);
      return t2 || e5;
    }
    function s(e5) {
      var t2;
      switch (this.encoding = o(e5), this.encoding) {
        case "utf16le":
          this.text = p, this.end = m, t2 = 4;
          break;
        case "utf8":
          this.fillLast = c, t2 = 4;
          break;
        case "base64":
          this.text = _, this.end = g, t2 = 3;
          break;
        default:
          return this.write = b2, void (this.end = y);
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r.allocUnsafe(t2);
    }
    function l(e5) {
      return e5 <= 127 ? 0 : e5 >> 5 == 6 ? 2 : e5 >> 4 == 14 ? 3 : e5 >> 3 == 30 ? 4 : e5 >> 6 == 2 ? -1 : -2;
    }
    function u(e5, t2, i2) {
      var r2 = t2.length - 1;
      if (r2 < i2)
        return 0;
      var n2 = l(t2[r2]);
      return n2 >= 0 ? (n2 > 0 && (e5.lastNeed = n2 - 1), n2) : --r2 < i2 || n2 === -2 ? 0 : (n2 = l(t2[r2])) >= 0 ? (n2 > 0 && (e5.lastNeed = n2 - 2), n2) : --r2 < i2 || n2 === -2 ? 0 : (n2 = l(t2[r2])) >= 0 ? (n2 > 0 && (n2 === 2 ? n2 = 0 : e5.lastNeed = n2 - 3), n2) : 0;
    }
    function h(e5, t2, i2) {
      if ((192 & t2[0]) != 128)
        return e5.lastNeed = 0, "\uFFFD";
      if (e5.lastNeed > 1 && t2.length > 1) {
        if ((192 & t2[1]) != 128)
          return e5.lastNeed = 1, "\uFFFD";
        if (e5.lastNeed > 2 && t2.length > 2 && (192 & t2[2]) != 128)
          return e5.lastNeed = 2, "\uFFFD";
      }
    }
    function c(e5) {
      var t2 = this.lastTotal - this.lastNeed, i2 = h(this, e5);
      return i2 !== undefined ? i2 : this.lastNeed <= e5.length ? (e5.copy(this.lastChar, t2, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e5.copy(this.lastChar, t2, 0, e5.length), void (this.lastNeed -= e5.length));
    }
    function f(e5, t2) {
      var i2 = u(this, e5, t2);
      if (!this.lastNeed)
        return e5.toString("utf8", t2);
      this.lastTotal = i2;
      var r2 = e5.length - (i2 - this.lastNeed);
      return e5.copy(this.lastChar, 0, r2), e5.toString("utf8", t2, r2);
    }
    function d(e5) {
      var t2 = e5 && e5.length ? this.write(e5) : "";
      return this.lastNeed ? t2 + "\uFFFD" : t2;
    }
    function p(e5, t2) {
      if ((e5.length - t2) % 2 == 0) {
        var i2 = e5.toString("utf16le", t2);
        if (i2) {
          var r2 = i2.charCodeAt(i2.length - 1);
          if (r2 >= 55296 && r2 <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e5[e5.length - 2], this.lastChar[1] = e5[e5.length - 1], i2.slice(0, -1);
        }
        return i2;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e5[e5.length - 1], e5.toString("utf16le", t2, e5.length - 1);
    }
    function m(e5) {
      var t2 = e5 && e5.length ? this.write(e5) : "";
      if (this.lastNeed) {
        var i2 = this.lastTotal - this.lastNeed;
        return t2 + this.lastChar.toString("utf16le", 0, i2);
      }
      return t2;
    }
    function _(e5, t2) {
      var i2 = (e5.length - t2) % 3;
      return i2 === 0 ? e5.toString("base64", t2) : (this.lastNeed = 3 - i2, this.lastTotal = 3, i2 === 1 ? this.lastChar[0] = e5[e5.length - 1] : (this.lastChar[0] = e5[e5.length - 2], this.lastChar[1] = e5[e5.length - 1]), e5.toString("base64", t2, e5.length - i2));
    }
    function g(e5) {
      var t2 = e5 && e5.length ? this.write(e5) : "";
      return this.lastNeed ? t2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t2;
    }
    function b2(e5) {
      return e5.toString(this.encoding);
    }
    function y(e5) {
      return e5 && e5.length ? this.write(e5) : "";
    }
    i.StringDecoder = s, s.prototype.write = function(e5) {
      if (e5.length === 0)
        return "";
      var t2, i2;
      if (this.lastNeed) {
        if ((t2 = this.fillLast(e5)) === undefined)
          return "";
        i2 = this.lastNeed, this.lastNeed = 0;
      } else
        i2 = 0;
      return i2 < e5.length ? t2 ? t2 + this.text(e5, i2) : this.text(e5, i2) : t2 || "";
    }, s.prototype.end = d, s.prototype.text = f, s.prototype.fillLast = function(e5) {
      if (this.lastNeed <= e5.length)
        return e5.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e5.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e5.length), this.lastNeed -= e5.length;
    };
  }, { "safe-buffer": 64 }], 81: [function(e4, t, i) {
    (function(e5) {
      (function() {
        function i2(e6, t2) {
          if (r("noDeprecation"))
            return e6;
          var i3 = false;
          function n() {
            if (!i3) {
              if (r("throwDeprecation"))
                throw new Error(t2);
              r("traceDeprecation") ? console.trace(t2) : console.warn(t2), i3 = true;
            }
            return e6.apply(this, arguments);
          }
          return n;
        }
        function r(t2) {
          try {
            if (!e5.localStorage)
              return false;
          } catch (e6) {
            return false;
          }
          var i3 = e5.localStorage[t2];
          return i3 != null && String(i3).toLowerCase() === "true";
        }
        t.exports = i2;
      }).call(this);
    }).call(this, commonjsGlobal !== undefined ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, {}], 82: [function(e4, t, i) {
    arguments[4][25][0].apply(i, arguments);
  }, { dup: 25 }], 83: [function(e4, t, i) {
    var r = e4("is-arguments"), n = e4("is-generator-function"), a = e4("which-typed-array"), o = e4("is-typed-array");
    function s(e5) {
      return e5.call.bind(e5);
    }
    var l = typeof BigInt != "undefined", u = typeof Symbol != "undefined", h = s(Object.prototype.toString), c = s(Number.prototype.valueOf), f = s(String.prototype.valueOf), d = s(Boolean.prototype.valueOf);
    if (l)
      var p = s(BigInt.prototype.valueOf);
    if (u)
      var m = s(Symbol.prototype.valueOf);
    function _(e5, t2) {
      if (typeof e5 != "object")
        return false;
      try {
        return t2(e5), true;
      } catch (e6) {
        return false;
      }
    }
    function g(e5) {
      return typeof Promise != "undefined" && e5 instanceof Promise || e5 !== null && typeof e5 == "object" && typeof e5.then == "function" && typeof e5.catch == "function";
    }
    function b2(e5) {
      return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(e5) : o(e5) || U(e5);
    }
    function y(e5) {
      return a(e5) === "Uint8Array";
    }
    function w(e5) {
      return a(e5) === "Uint8ClampedArray";
    }
    function v(e5) {
      return a(e5) === "Uint16Array";
    }
    function x(e5) {
      return a(e5) === "Uint32Array";
    }
    function E(e5) {
      return a(e5) === "Int8Array";
    }
    function k(e5) {
      return a(e5) === "Int16Array";
    }
    function S(e5) {
      return a(e5) === "Int32Array";
    }
    function A(e5) {
      return a(e5) === "Float32Array";
    }
    function I(e5) {
      return a(e5) === "Float64Array";
    }
    function M(e5) {
      return a(e5) === "BigInt64Array";
    }
    function T(e5) {
      return a(e5) === "BigUint64Array";
    }
    function P(e5) {
      return h(e5) === "[object Map]";
    }
    function B(e5) {
      return typeof Map != "undefined" && (P.working ? P(e5) : e5 instanceof Map);
    }
    function C(e5) {
      return h(e5) === "[object Set]";
    }
    function R(e5) {
      return typeof Set != "undefined" && (C.working ? C(e5) : e5 instanceof Set);
    }
    function z(e5) {
      return h(e5) === "[object WeakMap]";
    }
    function F(e5) {
      return typeof WeakMap != "undefined" && (z.working ? z(e5) : e5 instanceof WeakMap);
    }
    function N(e5) {
      return h(e5) === "[object WeakSet]";
    }
    function O(e5) {
      return N(e5);
    }
    function D(e5) {
      return h(e5) === "[object ArrayBuffer]";
    }
    function $(e5) {
      return typeof ArrayBuffer != "undefined" && (D.working ? D(e5) : e5 instanceof ArrayBuffer);
    }
    function L(e5) {
      return h(e5) === "[object DataView]";
    }
    function U(e5) {
      return typeof DataView != "undefined" && (L.working ? L(e5) : e5 instanceof DataView);
    }
    i.isArgumentsObject = r, i.isGeneratorFunction = n, i.isTypedArray = o, i.isPromise = g, i.isArrayBufferView = b2, i.isUint8Array = y, i.isUint8ClampedArray = w, i.isUint16Array = v, i.isUint32Array = x, i.isInt8Array = E, i.isInt16Array = k, i.isInt32Array = S, i.isFloat32Array = A, i.isFloat64Array = I, i.isBigInt64Array = M, i.isBigUint64Array = T, P.working = typeof Map != "undefined" && P(new Map), i.isMap = B, C.working = typeof Set != "undefined" && C(new Set), i.isSet = R, z.working = typeof WeakMap != "undefined" && z(new WeakMap), i.isWeakMap = F, N.working = typeof WeakSet != "undefined" && N(new WeakSet), i.isWeakSet = O, D.working = typeof ArrayBuffer != "undefined" && D(new ArrayBuffer), i.isArrayBuffer = $, L.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && L(new DataView(new ArrayBuffer(1), 0, 1)), i.isDataView = U;
    var Z = typeof SharedArrayBuffer != "undefined" ? SharedArrayBuffer : undefined;
    function j(e5) {
      return h(e5) === "[object SharedArrayBuffer]";
    }
    function G(e5) {
      return Z !== undefined && (j.working === undefined && (j.working = j(new Z)), j.working ? j(e5) : e5 instanceof Z);
    }
    function H(e5) {
      return h(e5) === "[object AsyncFunction]";
    }
    function Q(e5) {
      return h(e5) === "[object Map Iterator]";
    }
    function W(e5) {
      return h(e5) === "[object Set Iterator]";
    }
    function q(e5) {
      return h(e5) === "[object Generator]";
    }
    function V(e5) {
      return h(e5) === "[object WebAssembly.Module]";
    }
    function Y(e5) {
      return _(e5, c);
    }
    function K(e5) {
      return _(e5, f);
    }
    function J(e5) {
      return _(e5, d);
    }
    function X(e5) {
      return l && _(e5, p);
    }
    function ee(e5) {
      return u && _(e5, m);
    }
    function te(e5) {
      return Y(e5) || K(e5) || J(e5) || X(e5) || ee(e5);
    }
    function ie(e5) {
      return typeof Uint8Array != "undefined" && ($(e5) || G(e5));
    }
    i.isSharedArrayBuffer = G, i.isAsyncFunction = H, i.isMapIterator = Q, i.isSetIterator = W, i.isGeneratorObject = q, i.isWebAssemblyCompiledModule = V, i.isNumberObject = Y, i.isStringObject = K, i.isBooleanObject = J, i.isBigIntObject = X, i.isSymbolObject = ee, i.isBoxedPrimitive = te, i.isAnyArrayBuffer = ie, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e5) {
      Object.defineProperty(i, e5, { enumerable: false, value: function() {
        throw new Error(e5 + " is not supported in userland");
      } });
    });
  }, { "is-arguments": 47, "is-generator-function": 49, "is-typed-array": 50, "which-typed-array": 85 }], 84: [function(e4, t, i) {
    (function(t2) {
      (function() {
        var r = Object.getOwnPropertyDescriptors || function(e5) {
          for (var t3 = Object.keys(e5), i2 = {}, r2 = 0;r2 < t3.length; r2++)
            i2[t3[r2]] = Object.getOwnPropertyDescriptor(e5, t3[r2]);
          return i2;
        }, n = /%[sdj%]/g;
        i.format = function(e5) {
          if (!E(e5)) {
            for (var t3 = [], i2 = 0;i2 < arguments.length; i2++)
              t3.push(l(arguments[i2]));
            return t3.join(" ");
          }
          i2 = 1;
          for (var r2 = arguments, a2 = r2.length, o2 = String(e5).replace(n, function(e6) {
            if (e6 === "%%")
              return "%";
            if (i2 >= a2)
              return e6;
            switch (e6) {
              case "%s":
                return String(r2[i2++]);
              case "%d":
                return Number(r2[i2++]);
              case "%j":
                try {
                  return JSON.stringify(r2[i2++]);
                } catch (e7) {
                  return "[Circular]";
                }
              default:
                return e6;
            }
          }), s2 = r2[i2];i2 < a2; s2 = r2[++i2])
            w(s2) || !I(s2) ? o2 += " " + s2 : o2 += " " + l(s2);
          return o2;
        }, i.deprecate = function(e5, r2) {
          if (t2 !== undefined && t2.noDeprecation === true)
            return e5;
          if (t2 === undefined)
            return function() {
              return i.deprecate(e5, r2).apply(this, arguments);
            };
          var n2 = false;
          function a2() {
            if (!n2) {
              if (t2.throwDeprecation)
                throw new Error(r2);
              t2.traceDeprecation ? console.trace(r2) : console.error(r2), n2 = true;
            }
            return e5.apply(this, arguments);
          }
          return a2;
        };
        var a = {}, o = /^$/;
        if (t2.env.NODE_DEBUG) {
          var s = t2.env.NODE_DEBUG;
          s = s.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), o = new RegExp("^" + s + "$", "i");
        }
        function l(e5, t3) {
          var r2 = { seen: [], stylize: h };
          return arguments.length >= 3 && (r2.depth = arguments[2]), arguments.length >= 4 && (r2.colors = arguments[3]), y(t3) ? r2.showHidden = t3 : t3 && i._extend(r2, t3), S(r2.showHidden) && (r2.showHidden = false), S(r2.depth) && (r2.depth = 2), S(r2.colors) && (r2.colors = false), S(r2.customInspect) && (r2.customInspect = true), r2.colors && (r2.stylize = u), f(r2, e5, r2.depth);
        }
        function u(e5, t3) {
          var i2 = l.styles[t3];
          return i2 ? "[" + l.colors[i2][0] + "m" + e5 + "[" + l.colors[i2][1] + "m" : e5;
        }
        function h(e5, t3) {
          return e5;
        }
        function c(e5) {
          var t3 = {};
          return e5.forEach(function(e6, i2) {
            t3[e6] = true;
          }), t3;
        }
        function f(e5, t3, r2) {
          if (e5.customInspect && t3 && P(t3.inspect) && t3.inspect !== i.inspect && (!t3.constructor || t3.constructor.prototype !== t3)) {
            var n2 = t3.inspect(r2, e5);
            return E(n2) || (n2 = f(e5, n2, r2)), n2;
          }
          var a2 = d(e5, t3);
          if (a2)
            return a2;
          var o2 = Object.keys(t3), s2 = c(o2);
          if (e5.showHidden && (o2 = Object.getOwnPropertyNames(t3)), T(t3) && (o2.indexOf("message") >= 0 || o2.indexOf("description") >= 0))
            return p(t3);
          if (o2.length === 0) {
            if (P(t3)) {
              var l2 = t3.name ? ": " + t3.name : "";
              return e5.stylize("[Function" + l2 + "]", "special");
            }
            if (A(t3))
              return e5.stylize(RegExp.prototype.toString.call(t3), "regexp");
            if (M(t3))
              return e5.stylize(Date.prototype.toString.call(t3), "date");
            if (T(t3))
              return p(t3);
          }
          var u2, h2 = "", y2 = false, w2 = ["{", "}"];
          return b2(t3) && (y2 = true, w2 = ["[", "]"]), P(t3) && (h2 = " [Function" + (t3.name ? ": " + t3.name : "") + "]"), A(t3) && (h2 = " " + RegExp.prototype.toString.call(t3)), M(t3) && (h2 = " " + Date.prototype.toUTCString.call(t3)), T(t3) && (h2 = " " + p(t3)), o2.length !== 0 || y2 && t3.length != 0 ? r2 < 0 ? A(t3) ? e5.stylize(RegExp.prototype.toString.call(t3), "regexp") : e5.stylize("[Object]", "special") : (e5.seen.push(t3), u2 = y2 ? m(e5, t3, r2, s2, o2) : o2.map(function(i2) {
            return _(e5, t3, r2, s2, i2, y2);
          }), e5.seen.pop(), g(u2, h2, w2)) : w2[0] + h2 + w2[1];
        }
        function d(e5, t3) {
          if (S(t3))
            return e5.stylize("undefined", "undefined");
          if (E(t3)) {
            var i2 = "'" + JSON.stringify(t3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return e5.stylize(i2, "string");
          }
          return x(t3) ? e5.stylize("" + t3, "number") : y(t3) ? e5.stylize("" + t3, "boolean") : w(t3) ? e5.stylize("null", "null") : undefined;
        }
        function p(e5) {
          return "[" + Error.prototype.toString.call(e5) + "]";
        }
        function m(e5, t3, i2, r2, n2) {
          for (var a2 = [], o2 = 0, s2 = t3.length;o2 < s2; ++o2)
            N(t3, String(o2)) ? a2.push(_(e5, t3, i2, r2, String(o2), true)) : a2.push("");
          return n2.forEach(function(n3) {
            n3.match(/^\d+$/) || a2.push(_(e5, t3, i2, r2, n3, true));
          }), a2;
        }
        function _(e5, t3, i2, r2, n2, a2) {
          var o2, s2, l2;
          if ((l2 = Object.getOwnPropertyDescriptor(t3, n2) || { value: t3[n2] }).get ? s2 = l2.set ? e5.stylize("[Getter/Setter]", "special") : e5.stylize("[Getter]", "special") : l2.set && (s2 = e5.stylize("[Setter]", "special")), N(r2, n2) || (o2 = "[" + n2 + "]"), s2 || (e5.seen.indexOf(l2.value) < 0 ? (s2 = w(i2) ? f(e5, l2.value, null) : f(e5, l2.value, i2 - 1)).indexOf("\n") > -1 && (s2 = a2 ? s2.split("\n").map(function(e6) {
            return "  " + e6;
          }).join("\n").slice(2) : "\n" + s2.split("\n").map(function(e6) {
            return "   " + e6;
          }).join("\n")) : s2 = e5.stylize("[Circular]", "special")), S(o2)) {
            if (a2 && n2.match(/^\d+$/))
              return s2;
            (o2 = JSON.stringify("" + n2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o2 = o2.slice(1, -1), o2 = e5.stylize(o2, "name")) : (o2 = o2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o2 = e5.stylize(o2, "string"));
          }
          return o2 + ": " + s2;
        }
        function g(e5, t3, i2) {
          return e5.reduce(function(e6, t4) {
            return t4.indexOf("\n"), e6 + t4.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0) > 60 ? i2[0] + (t3 === "" ? "" : t3 + "\n ") + " " + e5.join(",\n  ") + " " + i2[1] : i2[0] + t3 + " " + e5.join(", ") + " " + i2[1];
        }
        function b2(e5) {
          return Array.isArray(e5);
        }
        function y(e5) {
          return typeof e5 == "boolean";
        }
        function w(e5) {
          return e5 === null;
        }
        function v(e5) {
          return e5 == null;
        }
        function x(e5) {
          return typeof e5 == "number";
        }
        function E(e5) {
          return typeof e5 == "string";
        }
        function k(e5) {
          return typeof e5 == "symbol";
        }
        function S(e5) {
          return e5 === undefined;
        }
        function A(e5) {
          return I(e5) && C(e5) === "[object RegExp]";
        }
        function I(e5) {
          return typeof e5 == "object" && e5 !== null;
        }
        function M(e5) {
          return I(e5) && C(e5) === "[object Date]";
        }
        function T(e5) {
          return I(e5) && (C(e5) === "[object Error]" || e5 instanceof Error);
        }
        function P(e5) {
          return typeof e5 == "function";
        }
        function B(e5) {
          return e5 === null || typeof e5 == "boolean" || typeof e5 == "number" || typeof e5 == "string" || typeof e5 == "symbol" || e5 === undefined;
        }
        function C(e5) {
          return Object.prototype.toString.call(e5);
        }
        function R(e5) {
          return e5 < 10 ? "0" + e5.toString(10) : e5.toString(10);
        }
        i.debuglog = function(e5) {
          if (e5 = e5.toUpperCase(), !a[e5])
            if (o.test(e5)) {
              var r2 = t2.pid;
              a[e5] = function() {
                var t3 = i.format.apply(i, arguments);
                console.error("%s %d: %s", e5, r2, t3);
              };
            } else
              a[e5] = function() {
              };
          return a[e5];
        }, i.inspect = l, l.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, l.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i.types = e4("./support/types"), i.isArray = b2, i.isBoolean = y, i.isNull = w, i.isNullOrUndefined = v, i.isNumber = x, i.isString = E, i.isSymbol = k, i.isUndefined = S, i.isRegExp = A, i.types.isRegExp = A, i.isObject = I, i.isDate = M, i.types.isDate = M, i.isError = T, i.types.isNativeError = T, i.isFunction = P, i.isPrimitive = B, i.isBuffer = e4("./support/isBuffer");
        var z = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        function F() {
          var e5 = new Date, t3 = [R(e5.getHours()), R(e5.getMinutes()), R(e5.getSeconds())].join(":");
          return [e5.getDate(), z[e5.getMonth()], t3].join(" ");
        }
        function N(e5, t3) {
          return Object.prototype.hasOwnProperty.call(e5, t3);
        }
        i.log = function() {
          console.log("%s - %s", F(), i.format.apply(i, arguments));
        }, i.inherits = e4("inherits"), i._extend = function(e5, t3) {
          if (!t3 || !I(t3))
            return e5;
          for (var i2 = Object.keys(t3), r2 = i2.length;r2--; )
            e5[i2[r2]] = t3[i2[r2]];
          return e5;
        };
        var O = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : undefined;
        function D(e5, t3) {
          if (!e5) {
            var i2 = new Error("Promise was rejected with a falsy value");
            i2.reason = e5, e5 = i2;
          }
          return t3(e5);
        }
        function $(e5) {
          if (typeof e5 != "function")
            throw new TypeError('The "original" argument must be of type Function');
          function i2() {
            for (var i3 = [], r2 = 0;r2 < arguments.length; r2++)
              i3.push(arguments[r2]);
            var n2 = i3.pop();
            if (typeof n2 != "function")
              throw new TypeError("The last argument must be of type Function");
            var a2 = this, o2 = function() {
              return n2.apply(a2, arguments);
            };
            e5.apply(this, i3).then(function(e6) {
              t2.nextTick(o2.bind(null, null, e6));
            }, function(e6) {
              t2.nextTick(D.bind(null, e6, o2));
            });
          }
          return Object.setPrototypeOf(i2, Object.getPrototypeOf(e5)), Object.defineProperties(i2, r(e5)), i2;
        }
        i.promisify = function(e5) {
          if (typeof e5 != "function")
            throw new TypeError('The "original" argument must be of type Function');
          if (O && e5[O]) {
            var t3;
            if (typeof (t3 = e5[O]) != "function")
              throw new TypeError('The "util.promisify.custom" argument must be of type Function');
            return Object.defineProperty(t3, O, { value: t3, enumerable: false, writable: false, configurable: true }), t3;
          }
          function t3() {
            for (var t4, i2, r2 = new Promise(function(e6, r3) {
              t4 = e6, i2 = r3;
            }), n2 = [], a2 = 0;a2 < arguments.length; a2++)
              n2.push(arguments[a2]);
            n2.push(function(e6, r3) {
              e6 ? i2(e6) : t4(r3);
            });
            try {
              e5.apply(this, n2);
            } catch (e6) {
              i2(e6);
            }
            return r2;
          }
          return Object.setPrototypeOf(t3, Object.getPrototypeOf(e5)), O && Object.defineProperty(t3, O, { value: t3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t3, r(e5));
        }, i.promisify.custom = O, i.callbackify = $;
      }).call(this);
    }).call(this, e4("_process"));
  }, { "./support/isBuffer": 82, "./support/types": 83, _process: 63, inherits: 46 }], 85: [function(e4, t, i) {
    (function(i2) {
      (function() {
        var r = e4("for-each"), n = e4("available-typed-arrays"), a = e4("call-bind/callBound"), o = e4("gopd"), s = a("Object.prototype.toString"), l = e4("has-tostringtag/shams")(), u = typeof globalThis == "undefined" ? i2 : globalThis, h = n(), c = a("String.prototype.slice"), f = {}, d = Object.getPrototypeOf;
        l && o && d && r(h, function(e5) {
          if (typeof u[e5] == "function") {
            var t2 = new u[e5];
            if (Symbol.toStringTag in t2) {
              var i3 = d(t2), r2 = o(i3, Symbol.toStringTag);
              if (!r2) {
                var n2 = d(i3);
                r2 = o(n2, Symbol.toStringTag);
              }
              f[e5] = r2.get;
            }
          }
        });
        var p = function(e5) {
          var t2 = false;
          return r(f, function(i3, r2) {
            if (!t2)
              try {
                var n2 = i3.call(e5);
                n2 === r2 && (t2 = n2);
              } catch (e6) {
              }
          }), t2;
        }, m = e4("is-typed-array");
        t.exports = function(e5) {
          return !!m(e5) && (l && Symbol.toStringTag in e5 ? p(e5) : c(s(e5), 8, -1));
        };
      }).call(this);
    }).call(this, commonjsGlobal !== undefined ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { "available-typed-arrays": 27, "call-bind/callBound": 33, "for-each": 36, gopd: 40, "has-tostringtag/shams": 43, "is-typed-array": 50 }] }, {}, [20])(20);
  browserExports = browser$1.exports;
  PNGFilterType2 = PNGFilterType || (PNGFilterType = {}), PNGFilterType2[PNGFilterType2.AUTO = -1] = "AUTO", PNGFilterType2[PNGFilterType2.NONE = 0] = "NONE", PNGFilterType2[PNGFilterType2.SUB = 1] = "SUB", PNGFilterType2[PNGFilterType2.UP = 2] = "UP", PNGFilterType2[PNGFilterType2.AVERAGE = 3] = "AVERAGE", PNGFilterType2[PNGFilterType2.PATH = 4] = "PATH", PNGColorType2 = PNGColorType || (PNGColorType = {}), PNGColorType2[PNGColorType2.GRAYSCALE = 0] = "GRAYSCALE", PNGColorType2[PNGColorType2.COLOR = 2] = "COLOR", PNGColorType2[PNGColorType2.GRAYSCALE_ALPHA = 4] = "GRAYSCALE_ALPHA", PNGColorType2[PNGColorType2.COLOR_ALPHA = 6] = "COLOR_ALPHA";
  UTIF = { exports: {} };
  common = {};
  deflate$1 = {};
  deflate = {};
  trees = {};
  strings = {};
  inflate$1 = {};
  inflate = {};
  (function(e4) {
    (function() {
      var t = {};
      function i() {
        typeof process != "undefined" && false || console.log.apply(console, arguments);
      }
      e4.exports = t, function(e5, t2) {
        (function() {
          var t3 = function() {
            function e6(e7) {
              this.message = "JPEG error: " + e7;
            }
            return e6.prototype = new Error, e6.prototype.name = "JpegError", e6.constructor = e6, e6;
          }(), i2 = function() {
            var e6 = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), i3 = 4017, n = 799, a = 3406, o = 2276, s = 1567, l = 3784, u = 5793, h = 2896;
            function c(e7) {
              e7 == null && (e7 = {}), e7.w == null && (e7.w = -1), this.V = e7.n, this.N = e7.w;
            }
            function f(e7, t4) {
              for (var i4, r2, n2, a2 = 0, o2 = [], s2 = 16;s2 > 0 && !e7[s2 - 1]; )
                s2--;
              o2.push({ children: [], index: 0 });
              var l2 = o2[0];
              for (i4 = 0;i4 < s2; i4++) {
                for (r2 = 0;r2 < e7[i4]; r2++) {
                  for ((l2 = o2.pop()).children[l2.index] = t4[a2];l2.index > 0; )
                    l2 = o2.pop();
                  for (l2.index++, o2.push(l2);o2.length <= i4; )
                    o2.push(n2 = { children: [], index: 0 }), l2.children[l2.index] = n2.children, l2 = n2;
                  a2++;
                }
                i4 + 1 < s2 && (o2.push(n2 = { children: [], index: 0 }), l2.children[l2.index] = n2.children, l2 = n2);
              }
              return o2[0].children;
            }
            function d(e7, t4, i4) {
              return 64 * ((e7.P + 1) * t4 + i4);
            }
            function p(i4, n2, a2, o2, s2, l2, u2, h2, c2, f2) {
              f2 == null && (f2 = false);
              var p2, m2, _2, b2, y, w, v, x, E, k, S, A = a2.m, I = a2.Z, M = n2, T = 0, P = 0, B = 0, C = 0, R = 0, z = 0;
              function F() {
                if (P > 0)
                  return P--, T >> P & 1;
                if ((T = i4[n2++]) === 255) {
                  var e7 = i4[n2++];
                  if (e7) {
                    if (e7 === 220 && f2) {
                      var o3 = r(i4, n2 += 2);
                      if (n2 += 2, o3 > 0 && o3 !== a2.s)
                        throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", o3);
                    } else if (e7 === 217) {
                      if (f2) {
                        var s3 = 8 * R;
                        if (s3 > 0 && s3 < a2.s / 10)
                          throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", s3);
                      }
                      throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                    }
                    throw new t3("unexpected marker");
                  }
                }
                return P = 7, T >>> 7;
              }
              function N(e7) {
                for (var i5 = e7;; ) {
                  switch (typeof (i5 = i5[F()])) {
                    case "number":
                      return i5;
                    case "object":
                      continue;
                  }
                  throw new t3("invalid huffman sequence");
                }
              }
              function O(e7) {
                for (var t4 = 0;e7 > 0; )
                  t4 = t4 << 1 | F(), e7--;
                return t4;
              }
              function D(e7) {
                if (e7 === 1)
                  return F() === 1 ? 1 : -1;
                var t4 = O(e7);
                return t4 >= 1 << e7 - 1 ? t4 : t4 + (-1 << e7) + 1;
              }
              function $(e7, t4, i5, r2, n3) {
                var a3 = i5 % A;
                R = (i5 / A | 0) * e7.A + r2;
                var o3 = a3 * e7.h + n3;
                t4(e7, d(e7, R, o3));
              }
              function L(e7, t4, i5) {
                R = i5 / e7.P | 0;
                var r2 = i5 % e7.P;
                t4(e7, d(e7, R, r2));
              }
              var U = o2.length;
              for (v = I ? l2 === 0 ? h2 === 0 ? function(e7, t4) {
                var i5 = N(e7.J), r2 = i5 === 0 ? 0 : D(i5) << c2;
                e7.D[t4] = e7.Q += r2;
              } : function(e7, t4) {
                e7.D[t4] |= F() << c2;
              } : h2 === 0 ? function(t4, i5) {
                if (B > 0)
                  B--;
                else
                  for (var r2 = l2, n3 = u2;r2 <= n3; ) {
                    var a3 = N(t4.i), o3 = 15 & a3, s3 = a3 >> 4;
                    if (o3 !== 0) {
                      var h3 = e6[r2 += s3];
                      t4.D[i5 + h3] = D(o3) * (1 << c2), r2++;
                    } else {
                      if (s3 < 15) {
                        B = O(s3) + (1 << s3) - 1;
                        break;
                      }
                      r2 += 16;
                    }
                  }
              } : function(i5, r2) {
                for (var n3, a3, o3 = l2, s3 = u2, h3 = 0;o3 <= s3; ) {
                  var f3 = r2 + e6[o3], d2 = i5.D[f3] < 0 ? -1 : 1;
                  switch (C) {
                    case 0:
                      if (h3 = (a3 = N(i5.i)) >> 4, (n3 = 15 & a3) == 0)
                        h3 < 15 ? (B = O(h3) + (1 << h3), C = 4) : (h3 = 16, C = 1);
                      else {
                        if (n3 !== 1)
                          throw new t3("invalid ACn encoding");
                        p2 = D(n3), C = h3 ? 2 : 3;
                      }
                      continue;
                    case 1:
                    case 2:
                      i5.D[f3] ? i5.D[f3] += d2 * (F() << c2) : --h3 == 0 && (C = C === 2 ? 3 : 0);
                      break;
                    case 3:
                      i5.D[f3] ? i5.D[f3] += d2 * (F() << c2) : (i5.D[f3] = p2 << c2, C = 0);
                      break;
                    case 4:
                      i5.D[f3] && (i5.D[f3] += d2 * (F() << c2));
                  }
                  o3++;
                }
                C === 4 && --B == 0 && (C = 0);
              } : function(t4, i5) {
                var r2 = N(t4.J), n3 = r2 === 0 ? 0 : D(r2), a3 = 1;
                for (t4.D[i5] = t4.Q += n3;a3 < 64; ) {
                  var o3 = N(t4.i), s3 = 15 & o3, l3 = o3 >> 4;
                  if (s3 !== 0) {
                    var u3 = e6[a3 += l3];
                    t4.D[i5 + u3] = D(s3), a3++;
                  } else {
                    if (l3 < 15)
                      break;
                    a3 += 16;
                  }
                }
              }, E = U === 1 ? o2[0].P * o2[0].c : A * a2.R;z <= E; ) {
                var Z = s2 ? Math.min(E - z, s2) : E;
                if (Z > 0) {
                  for (_2 = 0;_2 < U; _2++)
                    o2[_2].Q = 0;
                  if (B = 0, U === 1)
                    for (m2 = o2[0], w = 0;w < Z; w++)
                      L(m2, v, z), z++;
                  else
                    for (w = 0;w < Z; w++) {
                      for (_2 = 0;_2 < U; _2++)
                        for (k = (m2 = o2[_2]).h, S = m2.A, b2 = 0;b2 < S; b2++)
                          for (y = 0;y < k; y++)
                            $(m2, v, z, b2, y);
                      z++;
                    }
                }
                if (P = 0, !(x = g(i4, n2)))
                  break;
                if (x.u && (n2 = x.offset), !(x.M >= 65488 && x.M <= 65495))
                  break;
                n2 += 2;
              }
              return n2 - M;
            }
            function m(e7, r2, c2) {
              var f2, d2, p2, m2, _2, g2, b2, y, w, v, x, E, k, S, A, I, M, T = e7.$, P = e7.D;
              if (!T)
                throw new t3("missing required Quantization Table.");
              for (var B = 0;B < 64; B += 8)
                w = P[r2 + B], v = P[r2 + B + 1], x = P[r2 + B + 2], E = P[r2 + B + 3], k = P[r2 + B + 4], S = P[r2 + B + 5], A = P[r2 + B + 6], I = P[r2 + B + 7], w *= T[B], v | x | E | k | S | A | I ? (v *= T[B + 1], x *= T[B + 2], E *= T[B + 3], k *= T[B + 4], S *= T[B + 5], A *= T[B + 6], I *= T[B + 7], d2 = (f2 = (f2 = u * w + 128 >> 8) + (d2 = u * k + 128 >> 8) + 1 >> 1) - d2, M = (p2 = x) * l + (m2 = A) * s + 128 >> 8, p2 = p2 * s - m2 * l + 128 >> 8, b2 = (_2 = (_2 = h * (v - I) + 128 >> 8) + (b2 = S << 4) + 1 >> 1) - b2, g2 = (y = (y = h * (v + I) + 128 >> 8) + (g2 = E << 4) + 1 >> 1) - g2, m2 = (f2 = f2 + (m2 = M) + 1 >> 1) - m2, p2 = (d2 = d2 + p2 + 1 >> 1) - p2, M = _2 * o + y * a + 2048 >> 12, _2 = _2 * a - y * o + 2048 >> 12, y = M, M = g2 * n + b2 * i3 + 2048 >> 12, g2 = g2 * i3 - b2 * n + 2048 >> 12, b2 = M, c2[B] = f2 + y, c2[B + 7] = f2 - y, c2[B + 1] = d2 + b2, c2[B + 6] = d2 - b2, c2[B + 2] = p2 + g2, c2[B + 5] = p2 - g2, c2[B + 3] = m2 + _2, c2[B + 4] = m2 - _2) : (M = u * w + 512 >> 10, c2[B] = M, c2[B + 1] = M, c2[B + 2] = M, c2[B + 3] = M, c2[B + 4] = M, c2[B + 5] = M, c2[B + 6] = M, c2[B + 7] = M);
              for (var C = 0;C < 8; ++C)
                w = c2[C], (v = c2[C + 8]) | (x = c2[C + 16]) | (E = c2[C + 24]) | (k = c2[C + 32]) | (S = c2[C + 40]) | (A = c2[C + 48]) | (I = c2[C + 56]) ? (d2 = (f2 = 4112 + ((f2 = u * w + 2048 >> 12) + (d2 = u * k + 2048 >> 12) + 1 >> 1)) - d2, M = (p2 = x) * l + (m2 = A) * s + 2048 >> 12, p2 = p2 * s - m2 * l + 2048 >> 12, m2 = M, b2 = (_2 = (_2 = h * (v - I) + 2048 >> 12) + (b2 = S) + 1 >> 1) - b2, g2 = (y = (y = h * (v + I) + 2048 >> 12) + (g2 = E) + 1 >> 1) - g2, M = _2 * o + y * a + 2048 >> 12, _2 = _2 * a - y * o + 2048 >> 12, y = M, M = g2 * n + b2 * i3 + 2048 >> 12, g2 = g2 * i3 - b2 * n + 2048 >> 12, (w = (f2 = f2 + m2 + 1 >> 1) + y) < 16 ? w = 0 : w >= 4080 ? w = 255 : w >>= 4, (v = (d2 = d2 + p2 + 1 >> 1) + (b2 = M)) < 16 ? v = 0 : v >= 4080 ? v = 255 : v >>= 4, (x = (p2 = d2 - p2) + g2) < 16 ? x = 0 : x >= 4080 ? x = 255 : x >>= 4, (E = (m2 = f2 - m2) + _2) < 16 ? E = 0 : E >= 4080 ? E = 255 : E >>= 4, (k = m2 - _2) < 16 ? k = 0 : k >= 4080 ? k = 255 : k >>= 4, (S = p2 - g2) < 16 ? S = 0 : S >= 4080 ? S = 255 : S >>= 4, (A = d2 - b2) < 16 ? A = 0 : A >= 4080 ? A = 255 : A >>= 4, (I = f2 - y) < 16 ? I = 0 : I >= 4080 ? I = 255 : I >>= 4, P[r2 + C] = w, P[r2 + C + 8] = v, P[r2 + C + 16] = x, P[r2 + C + 24] = E, P[r2 + C + 32] = k, P[r2 + C + 40] = S, P[r2 + C + 48] = A, P[r2 + C + 56] = I) : (M = (M = u * w + 8192 >> 14) < -2040 ? 0 : M >= 2024 ? 255 : M + 2056 >> 4, P[r2 + C] = M, P[r2 + C + 8] = M, P[r2 + C + 16] = M, P[r2 + C + 24] = M, P[r2 + C + 32] = M, P[r2 + C + 40] = M, P[r2 + C + 48] = M, P[r2 + C + 56] = M);
            }
            function _(e7, t4) {
              for (var { P: i4, c: r2 } = t4, n2 = new Int16Array(64), a2 = 0;a2 < r2; a2++)
                for (var o2 = 0;o2 < i4; o2++) {
                  m(t4, d(t4, a2, o2), n2);
                }
              return t4.D;
            }
            function g(e7, t4, i4) {
              i4 == null && (i4 = t4);
              var n2 = e7.length - 1, a2 = i4 < t4 ? i4 : t4;
              if (t4 >= n2)
                return null;
              var o2 = r(e7, t4);
              if (o2 >= 65472 && o2 <= 65534)
                return { u: null, M: o2, offset: t4 };
              for (var s2 = r(e7, a2);!(s2 >= 65472 && s2 <= 65534); ) {
                if (++a2 >= n2)
                  return null;
                s2 = r(e7, a2);
              }
              return { u: o2.toString(16), M: s2, offset: a2 };
            }
            return c.prototype = { parse(i4, n2) {
              n2 == null && (n2 = {});
              var a2, o2, s2 = n2.F, l2 = 0, u2 = null, h2 = null, c2 = 0;
              function d2() {
                var e7 = r(i4, l2), t4 = (l2 += 2) + e7 - 2, n3 = g(i4, t4, l2);
                n3 && n3.u && (t4 = n3.offset);
                var a3 = i4.subarray(l2, t4);
                return l2 += a3.length, a3;
              }
              function m2(e7) {
                for (var t4 = Math.ceil(e7.o / 8 / e7.X), i5 = Math.ceil(e7.s / 8 / e7.B), r2 = 0;r2 < e7.W.length; r2++) {
                  Z = e7.W[r2];
                  var n3 = Math.ceil(Math.ceil(e7.o / 8) * Z.h / e7.X), a3 = Math.ceil(Math.ceil(e7.s / 8) * Z.A / e7.B), o3 = t4 * Z.h, s3 = 64 * (i5 * Z.A) * (o3 + 1);
                  Z.D = new Int16Array(s3), Z.P = n3, Z.c = a3;
                }
                e7.m = t4, e7.R = i5;
              }
              var b2 = [], y = [], w = [], v = r(i4, l2);
              if (l2 += 2, v !== 65496)
                throw new t3("SOI not found");
              v = r(i4, l2), l2 += 2;
              e:
                for (;v !== 65497; ) {
                  var x, E, k;
                  switch (v) {
                    case 65504:
                    case 65505:
                    case 65506:
                    case 65507:
                    case 65508:
                    case 65509:
                    case 65510:
                    case 65511:
                    case 65512:
                    case 65513:
                    case 65514:
                    case 65515:
                    case 65516:
                    case 65517:
                    case 65518:
                    case 65519:
                    case 65534:
                      var S = d2();
                      v === 65504 && S[0] === 74 && S[1] === 70 && S[2] === 73 && S[3] === 70 && S[4] === 0 && (u2 = { version: { d: S[5], T: S[6] }, K: S[7], j: S[8] << 8 | S[9], H: S[10] << 8 | S[11], S: S[12], I: S[13], C: S.subarray(14, 14 + 3 * S[12] * S[13]) }), v === 65518 && S[0] === 65 && S[1] === 100 && S[2] === 111 && S[3] === 98 && S[4] === 101 && (h2 = { version: S[5] << 8 | S[6], k: S[7] << 8 | S[8], q: S[9] << 8 | S[10], a: S[11] });
                      break;
                    case 65499:
                      for (var A = r(i4, l2) + (l2 += 2) - 2;l2 < A; ) {
                        var I = i4[l2++], M = new Uint16Array(64);
                        if (I >> 4) {
                          if (I >> 4 != 1)
                            throw new t3("DQT - invalid table spec");
                          for (E = 0;E < 64; E++)
                            M[e6[E]] = r(i4, l2), l2 += 2;
                        } else
                          for (E = 0;E < 64; E++)
                            M[e6[E]] = i4[l2++];
                        b2[15 & I] = M;
                      }
                      break;
                    case 65472:
                    case 65473:
                    case 65474:
                      if (a2)
                        throw new t3("Only single frame JPEGs supported");
                      l2 += 2, (a2 = {}).G = v === 65473, a2.Z = v === 65474, a2.precision = i4[l2++];
                      var T, P = r(i4, l2), B = 0, C = 0;
                      l2 += 2, a2.s = s2 || P, a2.o = r(i4, l2), l2 += 2, a2.W = [], a2._ = {};
                      var R = i4[l2++];
                      for (x = 0;x < R; x++) {
                        T = i4[l2];
                        var z = i4[l2 + 1] >> 4, F = 15 & i4[l2 + 1];
                        B < z && (B = z), C < F && (C = F);
                        var N = i4[l2 + 2];
                        k = a2.W.push({ h: z, A: F, L: N, $: null }), a2._[T] = k - 1, l2 += 3;
                      }
                      a2.X = B, a2.B = C, m2(a2);
                      break;
                    case 65476:
                      var O = r(i4, l2);
                      for (l2 += 2, x = 2;x < O; ) {
                        var D = i4[l2++], $ = new Uint8Array(16), L = 0;
                        for (E = 0;E < 16; E++, l2++)
                          L += $[E] = i4[l2];
                        var U = new Uint8Array(L);
                        for (E = 0;E < L; E++, l2++)
                          U[E] = i4[l2];
                        x += 17 + L, (D >> 4 ? y : w)[15 & D] = f($, U);
                      }
                      break;
                    case 65501:
                      o2 = r(i4, l2 += 2), l2 += 2;
                      break;
                    case 65498:
                      var Z, j = ++c2 == 1 && !s2;
                      l2 += 2;
                      var G = i4[l2++], H = [];
                      for (x = 0;x < G; x++) {
                        var Q = i4[l2++], W = a2._[Q];
                        (Z = a2.W[W]).index = Q;
                        var q = i4[l2++];
                        Z.J = w[q >> 4], Z.i = y[15 & q], H.push(Z);
                      }
                      var V = i4[l2++], Y = i4[l2++], K = i4[l2++];
                      try {
                        var J = p(i4, l2, a2, H, o2, V, Y, K >> 4, 15 & K, j);
                        l2 += J;
                      } catch (e7) {
                        if (e7 instanceof DNLMarkerError)
                          return this.parse(i4, { F: e7.s });
                        if (e7 instanceof EOIMarkerError)
                          break e;
                        throw e7;
                      }
                      break;
                    case 65500:
                      l2 += 4;
                      break;
                    case 65535:
                      i4[l2] !== 255 && l2--;
                      break;
                    default:
                      var X = g(i4, l2 - 2, l2 - 3);
                      if (X && X.u) {
                        l2 = X.offset;
                        break;
                      }
                      if (l2 >= i4.length - 1)
                        break e;
                      throw new t3("JpegImage.parse - unknown marker: " + v.toString(16));
                  }
                  v = r(i4, l2), l2 += 2;
                }
              for (this.width = a2.o, this.height = a2.s, this.g = u2, this.b = h2, this.W = [], x = 0;x < a2.W.length; x++) {
                var ee = b2[(Z = a2.W[x]).L];
                ee && (Z.$ = ee), this.W.push({ index: Z.index, e: _(0, Z), l: Z.h / a2.X, t: Z.A / a2.B, P: Z.P, c: Z.c });
              }
              this.p = this.W.length;
            }, Y(e7, t4, i4) {
              i4 == null && (i4 = false);
              var r2, n2, a2, o2, s2, l2, u2, h2, c2, f2, d2, p2, m2 = this.width / e7, _2 = this.height / t4, g2 = 0, b2 = this.W.length, y = e7 * t4 * b2, w = new Uint8ClampedArray(y), v = new Uint32Array(e7), x = 4294967288;
              for (u2 = 0;u2 < b2; u2++) {
                if (n2 = (r2 = this.W[u2]).l * m2, a2 = r2.t * _2, g2 = u2, d2 = r2.e, o2 = r2.P + 1 << 3, n2 !== p2) {
                  for (s2 = 0;s2 < e7; s2++)
                    h2 = 0 | s2 * n2, v[s2] = (h2 & x) << 3 | 7 & h2;
                  p2 = n2;
                }
                for (l2 = 0;l2 < t4; l2++)
                  for (f2 = o2 * ((h2 = 0 | l2 * a2) & x) | (7 & h2) << 3, s2 = 0;s2 < e7; s2++)
                    w[g2] = d2[f2 + v[s2]], g2 += b2;
              }
              var E = this.V;
              if (i4 || b2 !== 4 || E || (E = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), E)
                for (u2 = 0;u2 < y; )
                  for (h2 = 0, c2 = 0;h2 < b2; h2++, u2++, c2 += 2)
                    w[u2] = (w[u2] * E[c2] >> 8) + E[c2 + 1];
              return w;
            }, get f() {
              return this.b ? !!this.b.a : this.p === 3 ? this.N !== 0 && (this.W[0].index !== 82 || this.W[1].index !== 71 || this.W[2].index !== 66) : this.N === 1;
            }, z: function(e7) {
              for (var t4, i4, r2, n2 = 0, a2 = e7.length;n2 < a2; n2 += 3)
                t4 = e7[n2], i4 = e7[n2 + 1], r2 = e7[n2 + 2], e7[n2] = t4 - 179.456 + 1.402 * r2, e7[n2 + 1] = t4 + 135.459 - 0.344 * i4 - 0.714 * r2, e7[n2 + 2] = t4 - 226.816 + 1.772 * i4;
              return e7;
            }, O: function(e7) {
              for (var t4, i4, r2, n2, a2 = 0, o2 = 0, s2 = e7.length;o2 < s2; o2 += 4)
                t4 = e7[o2], i4 = e7[o2 + 1], r2 = e7[o2 + 2], n2 = e7[o2 + 3], e7[a2++] = i4 * (-0.0000660635669420364 * i4 + 0.000437130475926232 * r2 - 0.000054080610064599 * t4 + 0.00048449797120281 * n2 - 0.154362151871126) - 122.67195406894 + r2 * (-0.000957964378445773 * r2 + 0.000817076911346625 * t4 - 0.00477271405408747 * n2 + 1.53380253221734) + t4 * (0.000961250184130688 * t4 - 0.00266257332283933 * n2 + 0.48357088451265) + n2 * (-0.000336197177618394 * n2 + 0.484791561490776), e7[a2++] = 107.268039397724 + i4 * (0.0000219927104525741 * i4 - 0.000640992018297945 * r2 + 0.000659397001245577 * t4 + 0.000426105652938837 * n2 - 0.176491792462875) + r2 * (-0.000778269941513683 * r2 + 0.00130872261408275 * t4 + 0.000770482631801132 * n2 - 0.151051492775562) + t4 * (0.00126935368114843 * t4 - 0.00265090189010898 * n2 + 0.25802910206845) + n2 * (-0.000318913117588328 * n2 - 0.213742400323665), e7[a2++] = i4 * (-0.000570115196973677 * i4 - 0.0000263409051004589 * r2 + 0.0020741088115012 * t4 - 0.00288260236853442 * n2 + 0.814272968359295) - 20.810012546947 + r2 * (-0.0000153496057440975 * r2 - 0.000132689043961446 * t4 + 0.000560833691242812 * n2 - 0.195152027534049) + t4 * (0.00174418132927582 * t4 - 0.00255243321439347 * n2 + 0.116935020465145) + n2 * (-0.000343531996510555 * n2 + 0.24165260232407);
              return e7.subarray(0, a2);
            }, r: function(e7) {
              for (var t4, i4, r2, n2 = 0, a2 = e7.length;n2 < a2; n2 += 4)
                t4 = e7[n2], i4 = e7[n2 + 1], r2 = e7[n2 + 2], e7[n2] = 434.456 - t4 - 1.402 * r2, e7[n2 + 1] = 119.541 - t4 + 0.344 * i4 + 0.714 * r2, e7[n2 + 2] = 481.816 - t4 - 1.772 * i4;
              return e7;
            }, U: function(e7) {
              for (var t4, i4, r2, n2, a2 = 0, o2 = 0, s2 = e7.length;o2 < s2; o2 += 4)
                t4 = e7[o2], i4 = e7[o2 + 1], r2 = e7[o2 + 2], n2 = e7[o2 + 3], e7[a2++] = 255 + t4 * (-0.00006747147073602441 * t4 + 0.0008379262121013727 * i4 + 0.0002894718188643294 * r2 + 0.003264231057537806 * n2 - 1.1185611867203937) + i4 * (0.000026374107616089405 * i4 - 0.00008626949158638572 * r2 - 0.0002748769067499491 * n2 - 0.02155688794978967) + r2 * (-0.00003878099212869363 * r2 - 0.0003267808279485286 * n2 + 0.0686742238595345) - n2 * (0.0003361971776183937 * n2 + 0.7430659151342254), e7[a2++] = 255 + t4 * (0.00013596372813588848 * t4 + 0.000924537132573585 * i4 + 0.00010567359618683593 * r2 + 0.0004791864687436512 * n2 - 0.3109689587515875) + i4 * (-0.00023545346108370344 * i4 + 0.0002702845253534714 * r2 + 0.0020200308977307156 * n2 - 0.7488052167015494) + r2 * (0.00006834815998235662 * r2 + 0.00015168452363460973 * n2 - 0.09751927774728933) - n2 * (0.0003189131175883281 * n2 + 0.7364883807733168), e7[a2++] = 255 + t4 * (0.000013598650411385307 * t4 + 0.00012423956175490851 * i4 + 0.0004751985097583589 * r2 - 0.0000036729317476630422 * n2 - 0.05562186980264034) + i4 * (0.00016141380598724676 * i4 + 0.0009692239130725186 * r2 + 0.0007782692450036253 * n2 - 0.44015232367526463) + r2 * (0.0000005068882914068769 * r2 + 0.0017778369011375071 * n2 - 0.7591454649749609) - n2 * (0.0003435319965105553 * n2 + 0.7063770186160144);
              return e7.subarray(0, a2);
            }, getData: function(e7) {
              var { width: i4, height: r2, forceRGB: n2, isSourcePDF: a2 } = e7;
              if (this.p > 4)
                throw new t3("Unsupported color mode");
              var o2 = this.Y(i4, r2, a2);
              if (this.p === 1 && n2) {
                for (var s2 = o2.length, l2 = new Uint8ClampedArray(3 * s2), u2 = 0, h2 = 0;h2 < s2; h2++) {
                  var c2 = o2[h2];
                  l2[u2++] = c2, l2[u2++] = c2, l2[u2++] = c2;
                }
                return l2;
              }
              if (this.p === 3 && this.f)
                return this.z(o2);
              if (this.p === 4) {
                if (this.f)
                  return n2 ? this.O(o2) : this.r(o2);
                if (n2)
                  return this.U(o2);
              }
              return o2;
            } }, c;
          }();
          function r(e6, t4) {
            return e6[t4] << 8 | e6[t4 + 1];
          }
          e5.JpegDecoder = i2;
        })(), e5.encodeImage = function(t3, i2, r, n) {
          var a = { t256: [i2], t257: [r], t258: [8, 8, 8, 8], t259: [1], t262: [2], t273: [1000], t277: [4], t278: [r], t279: [i2 * r * 4], t282: [[72, 1]], t283: [[72, 1]], t284: [1], t286: [[0, 1]], t287: [[0, 1]], t296: [1], t305: ["Photopea (UTIF.js)"], t338: [1] };
          if (n)
            for (var o in n)
              a[o] = n[o];
          var s = new Uint8Array(e5.encode([a])), l = new Uint8Array(t3), u = new Uint8Array(1000 + i2 * r * 4);
          for (o = 0;o < s.length; o++)
            u[o] = s[o];
          for (o = 0;o < l.length; o++)
            u[1000 + o] = l[o];
          return u.buffer;
        }, e5.encode = function(t3) {
          var i2 = new Uint8Array(20000), r = 4, n = e5._binBE;
          i2[0] = i2[1] = 77, n.writeUshort(i2, 2, 42);
          var a = 8;
          n.writeUint(i2, r, a), r += 4;
          for (var o = 0;o < t3.length; o++) {
            var s = e5._writeIFD(n, e5._types.basic, i2, a, t3[o]);
            a = s[1], o < t3.length - 1 && (3 & a && (a += 4 - (3 & a)), n.writeUint(i2, s[0], a));
          }
          return i2.slice(0, a).buffer;
        }, e5.decode = function(t3, r) {
          r == null && (r = { parseMN: true, debug: false });
          var n = new Uint8Array(t3), a = 0, o = e5._binBE.readASCII(n, a, 2);
          a += 2;
          var s = o == "II" ? e5._binLE : e5._binBE;
          s.readUshort(n, a), a += 2;
          var l = s.readUint(n, a);
          a += 4;
          for (var u = [];; ) {
            var h = s.readUshort(n, l), c = s.readUshort(n, l + 4);
            if (h != 0 && (c < 1 || 13 < c)) {
              i("error in TIFF");
              break;
            }
            if (e5._readIFD(s, n, l, u, 0, r), (l = s.readUint(n, l + 2 + 12 * h)) == 0)
              break;
          }
          return u;
        }, e5.decodeImage = function(t3, r, n) {
          if (!r.data) {
            var a = new Uint8Array(t3), o = e5._binBE.readASCII(a, 0, 2);
            if (r.t256 != null) {
              r.isLE = o == "II", r.width = r.t256[0], r.height = r.t257[0];
              var s = r.t259 ? r.t259[0] : 1, l = r.t266 ? r.t266[0] : 1;
              r.t284 && r.t284[0] == 2 && i("PlanarConfiguration 2 should not be used!"), s == 7 && r.t258 && r.t258.length > 3 && (r.t258 = r.t258.slice(0, 3));
              var u = r.t277 ? r.t277[0] : 1, h = (r.t258 ? r.t258[0] : 1) * u;
              s == 1 && r.t279 != null && r.t278 && r.t262[0] == 32803 && (h = Math.round(8 * r.t279[0] / (r.width * r.t278[0]))), r.t50885 && r.t50885[0] == 4 && (h = 3 * r.t258[0]);
              var c = 8 * Math.ceil(r.width * h / 8), f = r.t273;
              (f == null || r.t322) && (f = r.t324);
              var d = r.t279;
              s == 1 && f.length == 1 && (d = [r.height * (c >>> 3)]), (d == null || r.t322) && (d = r.t325);
              var p = new Uint8Array(r.height * (c >>> 3)), m = 0;
              if (r.t322 != null) {
                var _ = r.t322[0], g = r.t323[0], b2 = Math.floor((r.width + _ - 1) / _), y = Math.floor((r.height + g - 1) / g), w = new Uint8Array(0 | Math.ceil(_ * g * h / 8));
                console.log("====", b2, y);
                for (var v = 0;v < y; v++)
                  for (var x = 0;x < b2; x++) {
                    var E = v * b2 + x;
                    w.fill(0), e5.decode._decompress(r, n, a, f[E], d[E], s, w, 0, l, _, g), s == 6 ? p = w : e5._copyTile(w, 0 | Math.ceil(_ * h / 8), g, p, 0 | Math.ceil(r.width * h / 8), r.height, 0 | Math.ceil(x * _ * h / 8), v * g);
                  }
                m = 8 * p.length;
              } else {
                if (f == null)
                  return;
                var k = r.t278 ? r.t278[0] : r.height;
                k = Math.min(k, r.height);
                for (E = 0;E < f.length; E++)
                  e5.decode._decompress(r, n, a, f[E], d[E], s, p, 0 | Math.ceil(m / 8), l, r.width, k), m += c * k;
                m = Math.min(m, 8 * p.length);
              }
              r.data = new Uint8Array(p.buffer, 0, 0 | Math.ceil(m / 8));
            }
          }
        }, e5.decode._decompress = function(r, n, a, o, s, l, u, h, c, f, d) {
          if (r.t271 && r.t271[0] == "Panasonic" && r.t45 && r.t45[0] == 6 && (l = 34316), l == 1)
            for (var p = 0;p < s; p++)
              u[h + p] = a[o + p];
          else if (l == 2)
            e5.decode._decodeG2(a, o, s, u, h, f, c);
          else if (l == 3)
            e5.decode._decodeG3(a, o, s, u, h, f, c, !!r.t292 && !(1 & ~r.t292[0]));
          else if (l == 4)
            e5.decode._decodeG4(a, o, s, u, h, f, c);
          else if (l == 5)
            e5.decode._decodeLZW(a, o, s, u, h, 8);
          else if (l == 6)
            e5.decode._decodeOldJPEG(r, a, o, s, u, h);
          else if (l == 7 || l == 34892)
            e5.decode._decodeNewJPEG(r, a, o, s, u, h);
          else if (l == 8 || l == 32946) {
            var m = new Uint8Array(a.buffer, o + 2, s - 6), _ = t2.inflateRaw(m);
            h + _.length <= u.length && u.set(_, h);
          } else
            l == 9 ? e5.decode._decodeVC5(a, o, s, u, h, r.t33422) : l == 32767 ? e5.decode._decodeARW(r, a, o, s, u, h) : l == 32773 ? e5.decode._decodePackBits(a, o, s, u, h) : l == 32809 ? e5.decode._decodeThunder(a, o, s, u, h) : l == 34316 ? e5.decode._decodePanasonic(r, a, o, s, u, h) : l == 34713 ? e5.decode._decodeNikon(r, n, a, o, s, u, h) : l == 34676 ? e5.decode._decodeLogLuv32(r, a, o, s, u, h) : i("Unknown compression", l);
          var g = r.t258 ? Math.min(32, r.t258[0]) : 1, b2 = r.t277 ? r.t277[0] : 1, y = g * b2 >>> 3, w = Math.ceil(g * b2 * f / 8);
          if (g == 16 && !r.isLE && r.t33422 == null)
            for (var v = 0;v < d; v++)
              for (var x = h + v * w, E = 1;E < w; E += 2) {
                var k = u[x + E];
                u[x + E] = u[x + E - 1], u[x + E - 1] = k;
              }
          if (r.t317 && r.t317[0] == 2)
            for (v = 0;v < d; v++) {
              var S = h + v * w;
              if (g == 16)
                for (p = y;p < w; p += 2) {
                  var A = (u[S + p + 1] << 8 | u[S + p]) + (u[S + p - y + 1] << 8 | u[S + p - y]);
                  u[S + p] = 255 & A, u[S + p + 1] = A >>> 8 & 255;
                }
              else if (b2 == 3)
                for (p = 3;p < w; p += 3)
                  u[S + p] = u[S + p] + u[S + p - 3] & 255, u[S + p + 1] = u[S + p + 1] + u[S + p - 2] & 255, u[S + p + 2] = u[S + p + 2] + u[S + p - 1] & 255;
              else
                for (p = y;p < w; p++)
                  u[S + p] = u[S + p] + u[S + p - y] & 255;
            }
        }, e5.decode._decodePanasonic = function(e6, t3, i2, r, n, a) {
          var o, s, l, u, h, c, f, d, p = t3.buffer, m = e6.t2[0], _ = e6.t3[0], g = e6.t10[0], b2 = e6.t45[0], y = 0, w = 0, v = 0, x = 0, E = b2 == 6 ? new Uint32Array(18) : new Uint8Array(16), k = [0, 0], S = [0, 0], A = 0, I = new Uint8Array(16384), M = new Uint16Array(n.buffer);
          function T(e7) {
            if (v == 0) {
              var t4 = new Uint8Array(p, i2 + w + 8184, 8200), r2 = new Uint8Array(p, i2 + w, 8184);
              I.set(t4), I.set(r2, t4.length), w += 16384;
            }
            if (b2 != 5)
              return (I[x = (v = v - e7 & 131071) >> 3 ^ 16368] | I[x + 1] << 8) >> (7 & v) & ~(-1 << e7);
            for (o = 0;o < 16; o++)
              E[o] = I[v++], v &= 16383;
          }
          function P(e7) {
            return I[v + 15 - e7];
          }
          function B() {
            k[0] = 0, k[1] = 0, S[0] = 0, S[1] = 0;
          }
          if (b2 == 7)
            throw b2;
          if (b2 == 6) {
            var C = g == 12, R = C ? function() {
              E[0] = P(0) << 4 | P(1) >> 4, E[1] = 4095 & ((15 & P(1)) << 8 | P(2)), E[2] = P(3) >> 6 & 3, E[3] = (63 & P(3)) << 2 | P(4) >> 6, E[4] = (63 & P(4)) << 2 | P(5) >> 6, E[5] = (63 & P(5)) << 2 | P(6) >> 6, E[6] = P(6) >> 4 & 3, E[7] = (15 & P(6)) << 4 | P(7) >> 4, E[8] = (15 & P(7)) << 4 | P(8) >> 4, E[9] = (15 & P(8)) << 4 | P(9) >> 4, E[10] = P(9) >> 2 & 3, E[11] = (3 & P(9)) << 6 | P(10) >> 2, E[12] = (3 & P(10)) << 6 | P(11) >> 2, E[13] = (3 & P(11)) << 6 | P(12) >> 2, E[14] = 3 & P(12), E[15] = P(13), E[16] = P(14), E[17] = P(15), v += 16, x = 0;
            } : function() {
              E[0] = P(0) << 6 | P(1) >> 2, E[1] = 16383 & ((3 & P(1)) << 12 | P(2) << 4 | P(3) >> 4), E[2] = P(3) >> 2 & 3, E[3] = (3 & P(3)) << 8 | P(4), E[4] = P(5) << 2 | P(6) >> 6, E[5] = (63 & P(6)) << 4 | P(7) >> 4, E[6] = P(7) >> 2 & 3, E[7] = (3 & P(7)) << 8 | P(8), E[8] = P(9) << 2 & 1020 | P(10) >> 6, E[9] = 1023 & (P(10) << 4 | P(11) >> 4), E[10] = P(11) >> 2 & 3, E[11] = (3 & P(11)) << 8 | P(12), E[12] = 1023 & (P(13) << 2 & 1020 | P(14) >> 6), E[13] = 1023 & (P(14) << 4 | P(15) >> 4), v += 16, x = 0;
            }, z = C ? 14 : 11, F = C ? 128 : 512, N = C ? 2048 : 8192, O = C ? 16383 : 65535, D = C ? 4095 : 16383, $ = m / z, L = 16 * $, U = C ? 18 : 14;
            for (c = 0;c < _ - 15; c += 16) {
              var Z = Math.min(16, _ - c), j = L * Z;
              for (I = new Uint8Array(p, i2 + y, j), v = 0, y += j, d = 0, f = 0;d < Z; d++, f = 0) {
                A = (c + d) * m;
                for (var G = 0;G < $; G++)
                  for (R(), B(), l = 0, h = 0, o = 0;o < z; o++) {
                    if (u = 1 & o, o % 3 == 2) {
                      var H = x < U ? E[x++] : 0;
                      H == 3 && (H = 4), h = F << H, l = 1 << H;
                    }
                    var Q = x < U ? E[x++] : 0;
                    k[u] ? (Q *= l, h < N && S[u] > h && (Q += S[u] - h), S[u] = Q) : (k[u] = Q, Q ? S[u] = Q : Q = S[u]), M[A + f++] = Q - 15 <= O ? Q - 15 & O : Q + 2147483633 >> 31 & D;
                  }
              }
            }
          } else if (b2 == 5) {
            var W = g == 12 ? 10 : 9;
            for (c = 0;c < _; c++)
              for (f = 0;f < m; f += W)
                T(0), g == 12 ? (M[A++] = ((15 & E[1]) << 8) + E[0], M[A++] = 16 * E[2] + (E[1] >> 4), M[A++] = ((15 & E[4]) << 8) + E[3], M[A++] = 16 * E[5] + (E[4] >> 4), M[A++] = ((15 & E[7]) << 8) + E[6], M[A++] = 16 * E[8] + (E[7] >> 4), M[A++] = ((15 & E[10]) << 8) + E[9], M[A++] = 16 * E[11] + (E[10] >> 4), M[A++] = ((15 & E[13]) << 8) + E[12], M[A++] = 16 * E[14] + (E[13] >> 4)) : g == 14 && (M[A++] = E[0] + ((63 & E[1]) << 8), M[A++] = (E[1] >> 6) + 4 * E[2] + ((15 & E[3]) << 10), M[A++] = (E[3] >> 4) + 16 * E[4] + ((3 & E[5]) << 12), M[A++] = ((252 & E[5]) >> 2) + (E[6] << 6), M[A++] = E[7] + ((63 & E[8]) << 8), M[A++] = (E[8] >> 6) + 4 * E[9] + ((15 & E[10]) << 10), M[A++] = (E[10] >> 4) + 16 * E[11] + ((3 & E[12]) << 12), M[A++] = ((252 & E[12]) >> 2) + (E[13] << 6), M[A++] = E[14] + ((63 & E[15]) << 8));
          } else {
            if (b2 != 4)
              throw b2;
            for (c = 0;c < _; c++)
              for (f = 0;f < m; f++)
                u = 1 & (o = f % 14), o == 0 && B(), o % 3 == 2 && (l = 4 >> 3 - T(2)), S[u] ? (s = T(8)) != 0 && (k[u] -= 128 << l, (k[u] < 0 || l == 4) && (k[u] &= ~(-1 << l)), k[u] += s << l) : (S[u] = T(8), (S[u] || o > 11) && (k[u] = S[u] << 4 | T(4))), M[A++] = k[1 & f];
          }
        }, e5.decode._decodeVC5 = function() {
          var t3, i2, r, n = [1, 0, 1, 0, 2, 2, 1, 1, 3, 7, 1, 2, 5, 25, 1, 3, 6, 48, 1, 4, 6, 54, 1, 5, 7, 111, 1, 8, 7, 99, 1, 6, 7, 105, 12, 0, 7, 107, 1, 7, 8, 209, 20, 0, 8, 212, 1, 9, 8, 220, 1, 10, 9, 393, 1, 11, 9, 394, 32, 0, 9, 416, 1, 12, 9, 427, 1, 13, 10, 887, 1, 18, 10, 784, 1, 14, 10, 790, 1, 15, 10, 835, 60, 0, 10, 852, 1, 16, 10, 885, 1, 17, 11, 1571, 1, 19, 11, 1668, 1, 20, 11, 1669, 100, 0, 11, 1707, 1, 21, 11, 1772, 1, 22, 12, 3547, 1, 29, 12, 3164, 1, 24, 12, 3166, 1, 25, 12, 3140, 1, 23, 12, 3413, 1, 26, 12, 3537, 1, 27, 12, 3539, 1, 28, 13, 7093, 1, 35, 13, 6283, 1, 30, 13, 6331, 1, 31, 13, 6335, 180, 0, 13, 6824, 1, 32, 13, 7072, 1, 33, 13, 7077, 320, 0, 13, 7076, 1, 34, 14, 12565, 1, 36, 14, 12661, 1, 37, 14, 12669, 1, 38, 14, 13651, 1, 39, 14, 14184, 1, 40, 15, 28295, 1, 46, 15, 28371, 1, 47, 15, 25320, 1, 42, 15, 25336, 1, 43, 15, 25128, 1, 41, 15, 27300, 1, 44, 15, 28293, 1, 45, 16, 50259, 1, 48, 16, 50643, 1, 49, 16, 50675, 1, 50, 16, 56740, 1, 53, 16, 56584, 1, 51, 16, 56588, 1, 52, 17, 113483, 1, 61, 17, 113482, 1, 60, 17, 101285, 1, 55, 17, 101349, 1, 56, 17, 109205, 1, 57, 17, 109207, 1, 58, 17, 100516, 1, 54, 17, 113171, 1, 59, 18, 202568, 1, 62, 18, 202696, 1, 63, 18, 218408, 1, 64, 18, 218412, 1, 65, 18, 226340, 1, 66, 18, 226356, 1, 67, 18, 226358, 1, 68, 19, 402068, 1, 69, 19, 405138, 1, 70, 19, 405394, 1, 71, 19, 436818, 1, 72, 19, 436826, 1, 73, 19, 452714, 1, 75, 19, 452718, 1, 76, 19, 452682, 1, 74, 20, 804138, 1, 77, 20, 810279, 1, 78, 20, 810790, 1, 79, 20, 873638, 1, 80, 20, 873654, 1, 81, 20, 905366, 1, 82, 20, 905430, 1, 83, 20, 905438, 1, 84, 21, 1608278, 1, 85, 21, 1620557, 1, 86, 21, 1621582, 1, 87, 21, 1621583, 1, 88, 21, 1747310, 1, 89, 21, 1810734, 1, 90, 21, 1810735, 1, 91, 21, 1810863, 1, 92, 21, 1810879, 1, 93, 22, 3621725, 1, 99, 22, 3621757, 1, 100, 22, 3241112, 1, 94, 22, 3494556, 1, 95, 22, 3494557, 1, 96, 22, 3494622, 1, 97, 22, 3494623, 1, 98, 23, 6482227, 1, 102, 23, 6433117, 1, 101, 23, 6989117, 1, 103, 23, 6989119, 1, 105, 23, 6989118, 1, 104, 23, 7243449, 1, 106, 23, 7243512, 1, 107, 24, 13978233, 1, 111, 24, 12964453, 1, 109, 24, 12866232, 1, 108, 24, 14486897, 1, 113, 24, 13978232, 1, 110, 24, 14486896, 1, 112, 24, 14487026, 1, 114, 24, 14487027, 1, 115, 25, 25732598, 1, 225, 25, 25732597, 1, 189, 25, 25732596, 1, 188, 25, 25732595, 1, 203, 25, 25732594, 1, 202, 25, 25732593, 1, 197, 25, 25732592, 1, 207, 25, 25732591, 1, 169, 25, 25732590, 1, 223, 25, 25732589, 1, 159, 25, 25732522, 1, 235, 25, 25732579, 1, 152, 25, 25732575, 1, 192, 25, 25732489, 1, 179, 25, 25732573, 1, 201, 25, 25732472, 1, 172, 25, 25732576, 1, 149, 25, 25732488, 1, 178, 25, 25732566, 1, 120, 25, 25732571, 1, 219, 25, 25732577, 1, 150, 25, 25732487, 1, 127, 25, 25732506, 1, 211, 25, 25732548, 1, 125, 25, 25732588, 1, 158, 25, 25732486, 1, 247, 25, 25732467, 1, 238, 25, 25732508, 1, 163, 25, 25732552, 1, 228, 25, 25732603, 1, 183, 25, 25732513, 1, 217, 25, 25732587, 1, 168, 25, 25732520, 1, 122, 25, 25732484, 1, 128, 25, 25732562, 1, 249, 25, 25732505, 1, 187, 25, 25732504, 1, 186, 25, 25732483, 1, 136, 25, 25928905, 1, 181, 25, 25732560, 1, 255, 25, 25732500, 1, 230, 25, 25732482, 1, 135, 25, 25732555, 1, 233, 25, 25732568, 1, 222, 25, 25732583, 1, 145, 25, 25732481, 1, 134, 25, 25732586, 1, 167, 25, 25732521, 1, 248, 25, 25732518, 1, 209, 25, 25732480, 1, 243, 25, 25732512, 1, 216, 25, 25732509, 1, 164, 25, 25732547, 1, 140, 25, 25732479, 1, 157, 25, 25732544, 1, 239, 25, 25732574, 1, 191, 25, 25732564, 1, 251, 25, 25732478, 1, 156, 25, 25732546, 1, 139, 25, 25732498, 1, 242, 25, 25732557, 1, 133, 25, 25732477, 1, 162, 25, 25732515, 1, 213, 25, 25732584, 1, 165, 25, 25732514, 1, 212, 25, 25732476, 1, 227, 25, 25732494, 1, 198, 25, 25732531, 1, 236, 25, 25732530, 1, 234, 25, 25732529, 1, 117, 25, 25732528, 1, 215, 25, 25732527, 1, 124, 25, 25732526, 1, 123, 25, 25732525, 1, 254, 25, 25732524, 1, 253, 25, 25732523, 1, 148, 25, 25732570, 1, 218, 25, 25732580, 1, 146, 25, 25732581, 1, 147, 25, 25732569, 1, 224, 25, 25732533, 1, 143, 25, 25732540, 1, 184, 25, 25732541, 1, 185, 25, 25732585, 1, 166, 25, 25732556, 1, 132, 25, 25732485, 1, 129, 25, 25732563, 1, 250, 25, 25732578, 1, 151, 25, 25732501, 1, 119, 25, 25732502, 1, 193, 25, 25732536, 1, 176, 25, 25732496, 1, 245, 25, 25732553, 1, 229, 25, 25732516, 1, 206, 25, 25732582, 1, 144, 25, 25732517, 1, 208, 25, 25732558, 1, 137, 25, 25732543, 1, 241, 25, 25732466, 1, 237, 25, 25732507, 1, 190, 25, 25732542, 1, 240, 25, 25732551, 1, 131, 25, 25732554, 1, 232, 25, 25732565, 1, 252, 25, 25732475, 1, 171, 25, 25732493, 1, 205, 25, 25732492, 1, 204, 25, 25732491, 1, 118, 25, 25732490, 1, 214, 25, 25928904, 1, 180, 25, 25732549, 1, 126, 25, 25732602, 1, 182, 25, 25732539, 1, 175, 25, 25732545, 1, 141, 25, 25732559, 1, 138, 25, 25732537, 1, 177, 25, 25732534, 1, 153, 25, 25732503, 1, 194, 25, 25732606, 1, 160, 25, 25732567, 1, 121, 25, 25732538, 1, 174, 25, 25732497, 1, 246, 25, 25732550, 1, 130, 25, 25732572, 1, 200, 25, 25732474, 1, 170, 25, 25732511, 1, 221, 25, 25732601, 1, 196, 25, 25732532, 1, 142, 25, 25732519, 1, 210, 25, 25732495, 1, 199, 25, 25732605, 1, 155, 25, 25732535, 1, 154, 25, 25732499, 1, 244, 25, 25732510, 1, 220, 25, 25732600, 1, 195, 25, 25732607, 1, 161, 25, 25732604, 1, 231, 25, 25732473, 1, 173, 25, 25732599, 1, 226, 26, 51465122, 1, 116, 26, 51465123, 0, 1], a = [3, 3, 3, 3, 2, 2, 2, 1, 1, 1];
          function o(e6) {
            var t4 = e6[1], i3 = e6[0][t4 >>> 3] >>> 7 - (7 & t4) & 1;
            return e6[1]++, i3;
          }
          function s(e6, i3) {
            if (t3 == null) {
              t3 = {};
              for (var r2 = 0;r2 < n.length; r2 += 4)
                t3[n[r2 + 1]] = n.slice(r2, r2 + 4);
            }
            for (var a2 = o(e6), s2 = t3[a2];s2 == null; )
              a2 = a2 << 1 | o(e6), s2 = t3[a2];
            var l2 = s2[3];
            l2 != 0 && (l2 = o(e6) == 0 ? l2 : -l2), i3[0] = s2[2], i3[1] = l2;
          }
          function l(e6, t4) {
            for (var i3 = 0;i3 < t4; i3++)
              1 & ~e6 || e6++, e6 >>>= 1;
            return e6;
          }
          function u(e6, t4) {
            return e6 >> t4;
          }
          function h(e6, t4, i3, r2, n2, a2) {
            t4[i3] = u(u(11 * e6[n2] - 4 * e6[n2 + a2] + e6[n2 + a2 + a2] + 4, 3) + e6[r2], 1), t4[i3 + a2] = u(u(5 * e6[n2] + 4 * e6[n2 + a2] - e6[n2 + a2 + a2] + 4, 3) - e6[r2], 1);
          }
          function c(e6, t4, i3, r2, n2, a2) {
            var o2 = e6[n2 - a2] - e6[n2 + a2], s2 = e6[n2], l2 = e6[r2];
            t4[i3] = u(u(o2 + 4, 3) + s2 + l2, 1), t4[i3 + a2] = u(u(4 - o2, 3) + s2 - l2, 1);
          }
          function f(e6, t4, i3, r2, n2, a2) {
            t4[i3] = u(u(5 * e6[n2] + 4 * e6[n2 - a2] - e6[n2 - a2 - a2] + 4, 3) + e6[r2], 1), t4[i3 + a2] = u(u(11 * e6[n2] - 4 * e6[n2 - a2] + e6[n2 - a2 - a2] + 4, 3) - e6[r2], 1);
          }
          function d(e6) {
            return e6 = r[e6 = e6 < 0 ? 0 : e6 > 4095 ? 4095 : e6] >>> 2;
          }
          return function(t4, n2, o2, u2, p, m) {
            u2 = new Uint16Array(u2.buffer);
            var _, g, b2, y, w, v, x, E, k = Date.now(), S = e5._binBE, A = n2 + o2;
            n2 += 4;
            for (var I = m[0] == 1;n2 < A; ) {
              var M = S.readShort(t4, n2), T = S.readUshort(t4, n2 + 2);
              if (n2 += 4, M == 12)
                N = T;
              else if (M == 20)
                _ = T;
              else if (M == 21)
                g = T;
              else if (M == 48)
                b2 = T;
              else if (M == 53)
                y = T;
              else if (M == 35)
                ;
              else if (M == 62)
                w = T;
              else if (M == 101)
                ;
              else if (M == 109)
                v = T;
              else if (M == 84)
                ;
              else if (M == 106)
                ;
              else if (M == 107)
                ;
              else if (M == 108)
                ;
              else if (M == 102)
                ;
              else if (M == 104)
                ie = T;
              else if (M == 105)
                ;
              else {
                var P = M < 0 ? -M : M, B = 65280 & P, C = 0;
                if (24576 & P && (8192 & P ? (C = 65535 & T, C += (255 & P) << 16) : C = 65535 & T), 24576 & ~P) {
                  if (P == 16388)
                    n2 += 4 * C;
                  else if (B != 8192 && B != 8448 && B != 9216)
                    throw P.toString(16);
                } else {
                  if (x == null) {
                    x = [];
                    for (var R = 0;R < 4; R++)
                      x[R] = new Int16Array((_ >>> 1) * (g >>> 1));
                    E = new Int16Array((_ >>> 1) * (g >>> 1)), i2 = new Int16Array(1024);
                    for (R = 0;R < 1024; R++) {
                      var z = R - 512, F = Math.abs(z), N = Math.floor(768 * F * F * F / 16581375) + F;
                      i2[R] = Math.sign(z) * N;
                    }
                    r = new Uint16Array(4096);
                    for (R = 0;R < 4096; R++) {
                      var O = R, D = 65535 * (Math.pow(113, O / 4095) - 1) / 112;
                      r[R] = Math.min(D, 65535);
                    }
                  }
                  var $ = x[w], L = l(_, 1 + a[b2]), U = l(g, 1 + a[b2]);
                  if (b2 == 0)
                    for (var Z = 0;Z < U; Z++)
                      for (var j = 0;j < L; j++) {
                        var G = n2 + 2 * (Z * L + j);
                        $[Z * (_ >>> 1) + j] = t4[G] << 8 | t4[G + 1];
                      }
                  else {
                    var H = [t4, 8 * n2], Q = [], W = 0, q = L * U, V = [0, 0], Y = 0;
                    for (T = 0;W < q; )
                      for (s(H, V), Y = V[0], T = V[1];Y > 0; )
                        Q[W++] = T, Y--;
                    var K = (b2 - 1) % 3, J = K != 1 ? L : 0, X = K != 0 ? U : 0;
                    for (Z = 0;Z < U; Z++) {
                      var ee = (Z + X) * (_ >>> 1) + J, te = Z * L;
                      for (j = 0;j < L; j++)
                        $[ee + j] = i2[Q[te + j] + 512] * y;
                    }
                    if (K == 2) {
                      var ie = _ >>> 1, re = 2 * L, ne = 2 * U;
                      for (Z = 0;Z < U; Z++)
                        for (j = 0;j < re; j++) {
                          R = 2 * Z * ie + j;
                          var ae = U * ie + (se = Z * ie + j);
                          Z == 0 ? h($, E, R, ae, se, ie) : Z == U - 1 ? f($, E, R, ae, se, ie) : c($, E, R, ae, se, ie);
                        }
                      var oe = $;
                      $ = E, E = oe;
                      for (Z = 0;Z < ne; Z++)
                        for (j = 0;j < L; j++) {
                          var se;
                          R = Z * ie + 2 * j, ae = L + (se = Z * ie + j);
                          j == 0 ? h($, E, R, ae, se, 1) : j == L - 1 ? f($, E, R, ae, se, 1) : c($, E, R, ae, se, 1);
                        }
                      oe = $;
                      $ = E, E = oe;
                      for (var le = [], ue = 2 - ~~((b2 - 1) / 3), he = 0;he < 3; he++)
                        le[he] = v >> 14 - 2 * he & 3;
                      var ce = le[ue];
                      if (ce != 0)
                        for (Z = 0;Z < ne; Z++)
                          for (j = 0;j < re; j++) {
                            $[R = Z * ie + j] = $[R] << ce;
                          }
                    }
                  }
                  if (b2 == 9 && w == 3) {
                    var fe = x[0], de = x[1], pe = x[2], me = x[3];
                    for (Z = 0;Z < g; Z += 2)
                      for (j = 0;j < _; j += 2) {
                        var _e = Z * _ + j, ge = fe[G = (Z >>> 1) * (_ >>> 1) + (j >>> 1)], be = de[G] - 2048, ye = pe[G] - 2048, we = me[G] - 2048, ve = (be << 1) + ge, xe = (ye << 1) + ge, Ee = ge + we, ke = ge - we;
                        I ? (u2[_e] = d(Ee), u2[_e + 1] = d(xe), u2[_e + _] = d(ve), u2[_e + _ + 1] = d(ke)) : (u2[_e] = d(ve), u2[_e + 1] = d(Ee), u2[_e + _] = d(ke), u2[_e + _ + 1] = d(xe));
                      }
                  }
                  n2 += 4 * C;
                }
              }
            }
            console.log(Date.now() - k);
          };
        }(), e5.decode._decodeLogLuv32 = function(e6, t3, i2, r, n, a) {
          for (var o = e6.width, s = 4 * o, l = 0, u = new Uint8Array(s);l < r; ) {
            for (var h = 0;h < s; ) {
              var c = t3[i2 + l];
              if (l++, c < 128) {
                for (var f = 0;f < c; f++)
                  u[h + f] = t3[i2 + l + f];
                h += c, l += c;
              } else {
                c -= 126;
                for (f = 0;f < c; f++)
                  u[h + f] = t3[i2 + l];
                h += c, l++;
              }
            }
            for (var d = 0;d < o; d++)
              n[a + 0] = u[d], n[a + 1] = u[d + o], n[a + 2] = u[d + 2 * o], n[a + 4] = u[d + 3 * o], a += 6;
          }
        }, e5.decode._ljpeg_diff = function(t3, i2, r) {
          var n, a, o = e5.decode._getbithuff;
          return n = o(t3, i2, r[0], r), (a = o(t3, i2, n, 0)) & 1 << n - 1 || (a -= (1 << n) - 1), a;
        }, e5.decode._decodeARW = function(t3, i2, r, n, a, o) {
          var s = t3.t256[0], l = t3.t257[0], u = t3.t258[0], h = t3.isLE ? e5._binLE : e5._binBE;
          if (s * l == n || s * l * 1.5 == n)
            if (s * l * 1.5 != n) {
              var c, f, d, p, m, _, g, b2, y = new Uint16Array(16), w = new Uint8Array(s + 1);
              for (M = 0;M < l; M++) {
                for (var v = 0;v < s; v++)
                  w[v] = i2[r++];
                for (b2 = 0, I = 0;I < s - 30; b2 += 16) {
                  for (f = 2047 & (c = h.readUint(w, b2)), d = 2047 & c >>> 11, p = 15 & c >>> 22, m = 15 & c >>> 26, _ = 0;_ < 4 && 128 << _ <= f - d; _++)
                    ;
                  for (g = 30, x = 0;x < 16; x++)
                    x == p ? y[x] = f : x == m ? y[x] = d : (y[x] = ((h.readUshort(w, b2 + (g >> 3)) >>> (7 & g) & 127) << _) + d, y[x] > 2047 && (y[x] = 2047), g += 7);
                  for (x = 0;x < 16; x++, I += 2) {
                    N = y[x] << 1;
                    e5.decode._putsF(a, (M * s + I) * u, N << 16 - u);
                  }
                  I -= 1 & I ? 1 : 31;
                }
              }
            } else
              for (var x = 0;x < n; x += 3) {
                var E = i2[r + x + 0], k = i2[r + x + 1], S = i2[r + x + 2];
                a[o + x] = k << 4 | E >>> 4, a[o + x + 1] = E << 4 | S >>> 4, a[o + x + 2] = S << 4 | k >>> 4;
              }
          else {
            l += 8;
            var A, I, M, T = [r, 0, 0, 0], P = new Uint16Array(32770), B = [3857, 3856, 3599, 3342, 3085, 2828, 2571, 2314, 2057, 1800, 1543, 1286, 1029, 772, 771, 768, 514, 513], C = 0, R = e5.decode._ljpeg_diff;
            for (P[0] = 15, A = x = 0;x < 18; x++)
              for (var z = 32768 >>> (B[x] >>> 8), F = 0;F < z; F++)
                P[++A] = B[x];
            for (I = s;I--; )
              for (M = 0;M < l + 1; M += 2)
                if (M == l && (M = 1), C += R(i2, T, P), M < l) {
                  var N = 4095 & C;
                  e5.decode._putsF(a, (M * s + I) * u, N << 16 - u);
                }
          }
        }, e5.decode._decodeNikon = function(t3, i2, r, n, a, o, s) {
          var l = [[0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 57, 90, 56, 39, 22, 5, 4, 3, 2, 1, 0, 11, 12, 12], [0, 0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12], [0, 0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 8, 92, 75, 58, 41, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14], [0, 0, 1, 4, 2, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14]], u = t3.t256[0], h = t3.t257[0], c = t3.t258[0], f = 0, d = 0, p = e5.decode._make_decoder, m = e5.decode._getbithuff, _ = i2[0].exifIFD.makerNote, g = _.t150 ? _.t150 : _.t140, b2 = 0, y = g[b2++], w = g[b2++];
          y != 73 && w != 88 || (b2 += 2110), y == 70 && (f = 2), c == 14 && (f += 3);
          for (var v = [[0, 0], [0, 0]], x = t3.isLE ? e5._binLE : e5._binBE, E = 0;E < 2; E++)
            for (var k = 0;k < 2; k++)
              v[E][k] = x.readShort(g, b2), b2 += 2;
          var S, A, I, M, T, P = 1 << c & 32767, B = 0, C = x.readShort(g, b2);
          b2 += 2, C > 1 && (B = Math.floor(P / (C - 1))), y == 68 && w == 32 && B > 0 && (d = x.readShort(g, 562));
          var R = [0, 0], z = p(l[f]), F = [n, 0, 0, 0];
          for (S = 0;S < h; S++)
            for (d && S == d && (z = p(l[f + 1])), A = 0;A < u; A++) {
              E = m(r, F, z[0], z), (T = 1 + (m(r, F, (I = 15 & E) - (M = E >>> 4), 0) << 1) << M >>> 1) & 1 << I - 1 || (T -= (1 << I) - (M == 0 ? 1 : 0)), A < 2 ? R[A] = v[1 & S][A] += T : R[1 & A] += T;
              var N = Math.min(Math.max(R[1 & A], 0), (1 << c) - 1), O = (S * u + A) * c;
              e5.decode._putsF(o, O, N << 16 - c);
            }
        }, e5.decode._putsF = function(e6, t3, i2) {
          i2 <<= 8 - (7 & t3);
          var r = t3 >>> 3;
          e6[r] |= i2 >>> 16, e6[r + 1] |= i2 >>> 8, e6[r + 2] |= i2;
        }, e5.decode._getbithuff = function(t3, i2, r, n) {
          var a;
          e5.decode._get_byte;
          var o = i2[0], s = i2[1], l = i2[2], u = i2[3];
          if (r == 0 || l < 0)
            return 0;
          for (;!u && l < r && (a = t3[o++]) != -1 && !(u = 0); )
            s = (s << 8) + a, l += 8;
          if (a = s << 32 - l >>> 32 - r, n ? (l -= n[a + 1] >>> 8, a = 255 & n[a + 1]) : l -= r, l < 0)
            throw "e";
          return i2[0] = o, i2[1] = s, i2[2] = l, i2[3] = u, a;
        }, e5.decode._make_decoder = function(e6) {
          var t3, i2, r, n, a, o = [];
          for (t3 = 16;t3 != 0 && !e6[t3]; t3--)
            ;
          var s = 17;
          for (o[0] = t3, r = i2 = 1;i2 <= t3; i2++)
            for (n = 0;n < e6[i2]; n++, ++s)
              for (a = 0;a < 1 << t3 - i2; a++)
                r <= 1 << t3 && (o[r++] = i2 << 8 | e6[s]);
          return o;
        }, e5.decode._decodeNewJPEG = function(t3, i2, r, n, a, o) {
          n = Math.min(n, i2.length - r);
          var s = t3.t347, l = s ? s.length : 0, u = new Uint8Array(l + n);
          if (s) {
            for (var h = 0, c = 0;c < l - 1 && (s[c] != 255 || s[c + 1] != 217); c++)
              u[h++] = s[c];
            var f = i2[r], d = i2[r + 1];
            f == 255 && d == 216 || (u[h++] = f, u[h++] = d);
            for (c = 2;c < n; c++)
              u[h++] = i2[r + c];
          } else
            for (c = 0;c < n; c++)
              u[c] = i2[r + c];
          if (t3.t262[0] == 32803 || t3.t259[0] == 7 && t3.t262[0] == 34892) {
            var p = t3.t258[0], m = e5.LosslessJpegDecode(u), _ = m.length;
            if (p == 16)
              if (t3.isLE)
                for (c = 0;c < _; c++)
                  a[o + (c << 1)] = 255 & m[c], a[o + (c << 1) + 1] = m[c] >>> 8;
              else
                for (c = 0;c < _; c++)
                  a[o + (c << 1)] = m[c] >>> 8, a[o + (c << 1) + 1] = 255 & m[c];
            else if (p == 14 || p == 12 || p == 10) {
              var g = 16 - p;
              for (c = 0;c < _; c++)
                e5.decode._putsF(a, c * p, m[c] << g);
            } else {
              if (p != 8)
                throw new Error("unsupported bit depth " + p);
              for (c = 0;c < _; c++)
                a[o + c] = m[c];
            }
          } else {
            var b2 = new e5.JpegDecoder;
            b2.parse(u);
            var y = b2.getData({ width: b2.width, height: b2.height, forceRGB: true, isSourcePDF: false });
            for (c = 0;c < y.length; c++)
              a[o + c] = y[c];
          }
          t3.t262[0] == 6 && (t3.t262[0] = 2);
        }, e5.decode._decodeOldJPEGInit = function(e6, t3, r, n) {
          var a, o, s, l, u, h = 216, c = 0, f = 0, d = false, p = e6.t513, m = p ? p[0] : 0, _ = e6.t514, g = _ ? _[0] : 0, b2 = e6.t324 || e6.t273 || p, y = e6.t530, w = 0, v = 0, x = e6.t277 ? e6.t277[0] : 1, E = e6.t515;
          if (b2 && (f = b2[0], d = b2.length > 1), !d) {
            if (t3[r] == 255 && t3[r + 1] == h)
              return { jpegOffset: r };
            if (p != null && (t3[r + m] == 255 && t3[r + m + 1] == h ? c = r + m : i("JPEGInterchangeFormat does not point to SOI"), _ == null ? i("JPEGInterchangeFormatLength field is missing") : (m >= f || m + g <= f) && i("JPEGInterchangeFormatLength field value is invalid"), c != null))
              return { jpegOffset: c };
          }
          if (y != null && (w = y[0], v = y[1]), p != null && _ != null)
            if (g >= 2 && m + g <= f) {
              for (a = t3[r + m + g - 2] == 255 && t3[r + m + g - 1] == h ? new Uint8Array(g - 2) : new Uint8Array(g), s = 0;s < a.length; s++)
                a[s] = t3[r + m + s];
              i("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
            } else
              i("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
          if (a == null) {
            var k = 0, S = [];
            S[k++] = 255, S[k++] = h;
            var A = e6.t519;
            if (A == null)
              throw new Error("JPEGQTables tag is missing");
            for (s = 0;s < A.length; s++)
              for (S[k++] = 255, S[k++] = 219, S[k++] = 0, S[k++] = 67, S[k++] = s, l = 0;l < 64; l++)
                S[k++] = t3[r + A[s] + l];
            for (u = 0;u < 2; u++) {
              var I = e6[u == 0 ? "t520" : "t521"];
              if (I == null)
                throw new Error((u == 0 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
              for (s = 0;s < I.length; s++) {
                S[k++] = 255, S[k++] = 196;
                var M = 19;
                for (l = 0;l < 16; l++)
                  M += t3[r + I[s] + l];
                for (S[k++] = M >>> 8, S[k++] = 255 & M, S[k++] = s | u << 4, l = 0;l < 16; l++)
                  S[k++] = t3[r + I[s] + l];
                for (l = 0;l < M; l++)
                  S[k++] = t3[r + I[s] + 16 + l];
              }
            }
            if (S[k++] = 255, S[k++] = 192, S[k++] = 0, S[k++] = 8 + 3 * x, S[k++] = 8, S[k++] = e6.height >>> 8 & 255, S[k++] = 255 & e6.height, S[k++] = e6.width >>> 8 & 255, S[k++] = 255 & e6.width, S[k++] = x, x == 1)
              S[k++] = 1, S[k++] = 17, S[k++] = 0;
            else
              for (s = 0;s < 3; s++)
                S[k++] = s + 1, S[k++] = s != 0 ? 17 : (15 & w) << 4 | 15 & v, S[k++] = s;
            E != null && E[0] != 0 && (S[k++] = 255, S[k++] = 221, S[k++] = 0, S[k++] = 4, S[k++] = E[0] >>> 8 & 255, S[k++] = 255 & E[0]), a = new Uint8Array(S);
          }
          var T = -1;
          for (s = 0;s < a.length - 1; ) {
            if (a[s] == 255 && a[s + 1] == 192) {
              T = s;
              break;
            }
            s++;
          }
          if (T == -1) {
            var P = new Uint8Array(a.length + 10 + 3 * x);
            P.set(a);
            var B = a.length;
            if (T = a.length, (a = P)[B++] = 255, a[B++] = 192, a[B++] = 0, a[B++] = 8 + 3 * x, a[B++] = 8, a[B++] = e6.height >>> 8 & 255, a[B++] = 255 & e6.height, a[B++] = e6.width >>> 8 & 255, a[B++] = 255 & e6.width, a[B++] = x, x == 1)
              a[B++] = 1, a[B++] = 17, a[B++] = 0;
            else
              for (s = 0;s < 3; s++)
                a[B++] = s + 1, a[B++] = s != 0 ? 17 : (15 & w) << 4 | 15 & v, a[B++] = s;
          }
          if (t3[f] == 255 && t3[f + 1] == 218) {
            var C = t3[f + 2] << 8 | t3[f + 3];
            for ((o = new Uint8Array(C + 2))[0] = t3[f], o[1] = t3[f + 1], o[2] = t3[f + 2], o[3] = t3[f + 3], s = 0;s < C - 2; s++)
              o[s + 4] = t3[f + s + 4];
          } else {
            var R = 0;
            if ((o = new Uint8Array(8 + 2 * x))[R++] = 255, o[R++] = 218, o[R++] = 0, o[R++] = 6 + 2 * x, o[R++] = x, x == 1)
              o[R++] = 1, o[R++] = 0;
            else
              for (s = 0;s < 3; s++)
                o[R++] = s + 1, o[R++] = s << 4 | s;
            o[R++] = 0, o[R++] = 63, o[R++] = 0;
          }
          return { jpegOffset: r, tables: a, sosMarker: o, sofPosition: T };
        }, e5.decode._decodeOldJPEG = function(t3, i2, r, n, a, o) {
          var s, l, u, h, c = e5.decode._decodeOldJPEGInit(t3, i2, r, n);
          if (c.jpegOffset != null)
            for (s = r + n - c.jpegOffset, u = new Uint8Array(s), p = 0;p < s; p++)
              u[p] = i2[c.jpegOffset + p];
          else {
            for (l = c.tables.length, (u = new Uint8Array(l + c.sosMarker.length + n + 2)).set(c.tables), h = l, u[c.sofPosition + 5] = t3.height >>> 8 & 255, u[c.sofPosition + 6] = 255 & t3.height, u[c.sofPosition + 7] = t3.width >>> 8 & 255, u[c.sofPosition + 8] = 255 & t3.width, i2[r] == 255 && i2[r + 1] == SOS || (u.set(c.sosMarker, h), h += sosMarker.length), p = 0;p < n; p++)
              u[h++] = i2[r + p];
            u[h++] = 255, u[h++] = EOI;
          }
          var f = new e5.JpegDecoder;
          f.parse(u);
          for (var d = f.getData({ width: f.width, height: f.height, forceRGB: true, isSourcePDF: false }), p = 0;p < d.length; p++)
            a[o + p] = d[p];
          t3.t262 && t3.t262[0] == 6 && (t3.t262[0] = 2);
        }, e5.decode._decodePackBits = function(e6, t3, i2, r, n) {
          for (var a = new Int8Array(e6.buffer), o = new Int8Array(r.buffer), s = t3 + i2;t3 < s; ) {
            var l = a[t3];
            if (t3++, l >= 0 && l < 128)
              for (var u = 0;u < l + 1; u++)
                o[n] = a[t3], n++, t3++;
            if (l >= -127 && l < 0) {
              for (u = 0;u < 1 - l; u++)
                o[n] = a[t3], n++;
              t3++;
            }
          }
          return n;
        }, e5.decode._decodeThunder = function(e6, t3, i2, r, n) {
          for (var a = [0, 1, 0, -1], o = [0, 1, 2, 3, 0, -3, -2, -1], s = t3 + i2, l = 2 * n, u = 0;t3 < s; ) {
            var h = e6[t3], c = h >>> 6, f = 63 & h;
            if (t3++, c == 3 && (u = 15 & f, r[l >>> 1] |= u << 4 * (1 - l & 1), l++), c == 0)
              for (var d = 0;d < f; d++)
                r[l >>> 1] |= u << 4 * (1 - l & 1), l++;
            if (c == 2)
              for (d = 0;d < 2; d++) {
                (p = f >>> 3 * (1 - d) & 7) != 4 && (u += o[p], r[l >>> 1] |= u << 4 * (1 - l & 1), l++);
              }
            if (c == 1)
              for (d = 0;d < 3; d++) {
                var p;
                (p = f >>> 2 * (2 - d) & 3) != 2 && (u += a[p], r[l >>> 1] |= u << 4 * (1 - l & 1), l++);
              }
          }
        }, e5.decode._dmap = { 1: 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 }, e5.decode._lens = function() {
          var e6 = function(e7, t4, i3, r2) {
            for (var n2 = 0;n2 < t4.length; n2++)
              e7[t4[n2]] = i3 + n2 * r2;
          }, t3 = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100", i2 = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111", r = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011", n = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101", a = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
          t3 = t3.split(","), i2 = i2.split(","), r = r.split(","), n = n.split(","), a = a.split(",");
          var o = {}, s = {};
          return e6(o, t3, 0, 1), e6(o, r, 64, 64), e6(o, a, 1792, 64), e6(s, i2, 0, 1), e6(s, n, 64, 64), e6(s, a, 1792, 64), [o, s];
        }(), e5.decode._decodeG4 = function(t3, i2, r, n, a, o, s) {
          for (var l = e5.decode, u = i2 << 3, h = 0, c = "", f = [], d = [], p = 0;p < o; p++)
            d.push(0);
          d = l._makeDiff(d);
          for (var m = 0, _ = 0, g = 0, b2 = 0, y = 0, w = 0, v = "", x = 0, E = 8 * Math.ceil(o / 8);u >>> 3 < i2 + r; ) {
            g = l._findDiff(d, m + (m == 0 ? 0 : 1), 1 - y), b2 = l._findDiff(d, g, y);
            var k = 0;
            if (s == 1 && (k = t3[u >>> 3] >>> 7 - (7 & u) & 1), s == 2 && (k = t3[u >>> 3] >>> (7 & u) & 1), u++, c += k, v == "H") {
              if (l._lens[y][c] != null) {
                var S = l._lens[y][c];
                c = "", h += S, S < 64 && (l._addNtimes(f, h, y), m += h, y = 1 - y, h = 0, --x == 0 && (v = ""));
              }
            } else
              c == "0001" && (c = "", l._addNtimes(f, b2 - m, y), m = b2), c == "001" && (c = "", v = "H", x = 2), l._dmap[c] != null && (_ = g + l._dmap[c], l._addNtimes(f, _ - m, y), m = _, c = "", y = 1 - y);
            f.length == o && v == "" && (l._writeBits(f, n, 8 * a + w * E), y = 0, w++, m = 0, d = l._makeDiff(f), f = []);
          }
        }, e5.decode._findDiff = function(e6, t3, i2) {
          for (var r = 0;r < e6.length; r += 2)
            if (e6[r] >= t3 && e6[r + 1] == i2)
              return e6[r];
        }, e5.decode._makeDiff = function(e6) {
          var t3 = [];
          e6[0] == 1 && t3.push(0, 1);
          for (var i2 = 1;i2 < e6.length; i2++)
            e6[i2 - 1] != e6[i2] && t3.push(i2, e6[i2]);
          return t3.push(e6.length, 0, e6.length, 1), t3;
        }, e5.decode._decodeG2 = function(t3, i2, r, n, a, o, s) {
          for (var l = e5.decode, u = i2 << 3, h = 0, c = "", f = [], d = 0, p = 0, m = 8 * Math.ceil(o / 8);u >>> 3 < i2 + r; ) {
            var _ = 0;
            s == 1 && (_ = t3[u >>> 3] >>> 7 - (7 & u) & 1), s == 2 && (_ = t3[u >>> 3] >>> (7 & u) & 1), u++, c += _, (h = l._lens[d][c]) != null && (l._addNtimes(f, h, d), c = "", h < 64 && (d = 1 - d), f.length == o && (l._writeBits(f, n, 8 * a + p * m), f = [], p++, d = 0, 7 & u && (u += 8 - (7 & u)), h >= 64 && (u += 8)));
          }
        }, e5.decode._decodeG3 = function(t3, i2, r, n, a, o, s, l) {
          for (var u = e5.decode, h = i2 << 3, c = 0, f = "", d = [], p = [], m = 0;m < o; m++)
            d.push(0);
          for (var _ = 0, g = 0, b2 = 0, y = 0, w = 0, v = -1, x = "", E = 0, k = true, S = 8 * Math.ceil(o / 8);h >>> 3 < i2 + r; ) {
            b2 = u._findDiff(p, _ + (_ == 0 ? 0 : 1), 1 - w), y = u._findDiff(p, b2, w);
            var A = 0;
            if (s == 1 && (A = t3[h >>> 3] >>> 7 - (7 & h) & 1), s == 2 && (A = t3[h >>> 3] >>> (7 & h) & 1), h++, f += A, k) {
              if (u._lens[w][f] != null) {
                var I = u._lens[w][f];
                f = "", c += I, I < 64 && (u._addNtimes(d, c, w), w = 1 - w, c = 0);
              }
            } else if (x == "H") {
              if (u._lens[w][f] != null) {
                I = u._lens[w][f];
                f = "", c += I, I < 64 && (u._addNtimes(d, c, w), _ += c, w = 1 - w, c = 0, --E == 0 && (x = ""));
              }
            } else
              f == "0001" && (f = "", u._addNtimes(d, y - _, w), _ = y), f == "001" && (f = "", x = "H", E = 2), u._dmap[f] != null && (g = b2 + u._dmap[f], u._addNtimes(d, g - _, w), _ = g, f = "", w = 1 - w);
            f.endsWith("000000000001") && (v >= 0 && u._writeBits(d, n, 8 * a + v * S), l && (s == 1 && (k = (t3[h >>> 3] >>> 7 - (7 & h) & 1) == 1), s == 2 && (k = (t3[h >>> 3] >>> (7 & h) & 1) == 1), h++), f = "", w = 0, v++, _ = 0, p = u._makeDiff(d), d = []);
          }
          d.length == o && u._writeBits(d, n, 8 * a + v * S);
        }, e5.decode._addNtimes = function(e6, t3, i2) {
          for (var r = 0;r < t3; r++)
            e6.push(i2);
        }, e5.decode._writeBits = function(e6, t3, i2) {
          for (var r = 0;r < e6.length; r++)
            t3[i2 + r >>> 3] |= e6[r] << 7 - (i2 + r & 7);
        }, e5.decode._decodeLZW = e5.decode._decodeLZW = function() {
          var e6, t3, i2, r, n = 0, a = 0, o = 0, s = 0, l = function() {
            var i3 = e6 >>> 3, r2 = (t3[i3] << 16 | t3[i3 + 1] << 8 | t3[i3 + 2]) >>> 24 - (7 & e6) - a & (1 << a) - 1;
            return e6 += a, r2;
          }, u = new Uint32Array(16384), h = 0, c = function(e7) {
            a = e7 + 1, n = s + 1;
          }, f = function(e7) {
            for (var t4 = e7 << 2, n2 = u[t4 + 2], a2 = r + n2 - 1;t4 != 65535; )
              i2[a2--] = u[t4], t4 = u[t4 + 1];
            r += n2;
          }, d = function(e7, t4) {
            var i3 = n << 2, r2 = e7 << 2;
            u[i3] = u[3 + (t4 << 2)], u[i3 + 1] = r2, u[i3 + 2] = u[r2 + 2] + 1, u[i3 + 3] = u[r2 + 3], ++n + 1 == 1 << a && a != 12 && a++;
          };
          return function(a2, p, m, _, g, b2) {
            e6 = p << 3, t3 = a2, i2 = _, r = g;
            var y = p + m << 3, w = 0, v = 0;
            for (!function(e7) {
              if (e7 != h) {
                h = e7, s = 1 + (o = 1 << e7);
                for (var t4 = 0;t4 < s + 1; t4++)
                  u[4 * t4] = u[4 * t4 + 3] = t4, u[4 * t4 + 1] = 65535, u[4 * t4 + 2] = 1;
              }
            }(b2), c(b2);e6 < y && (w = l()) != s; ) {
              if (w == o) {
                if (c(b2), (w = l()) == s)
                  break;
                f(w);
              } else
                w < n ? (f(w), d(v, w)) : (d(v, v), f(n - 1));
              v = w;
            }
            return r;
          };
        }(), e5.tags = {}, e5._types = function() {
          var e6 = new Array(250);
          e6.fill(0);
          return { basic: { main: e6 = e6.concat([0, 0, 0, 0, 4, 3, 3, 3, 3, 3, 0, 0, 3, 0, 0, 0, 3, 0, 0, 2, 2, 2, 2, 4, 3, 0, 0, 3, 4, 4, 3, 3, 5, 5, 3, 2, 5, 5, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 5, 5, 3, 0, 3, 3, 4, 4, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), rest: { 33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7 } }, gps: { main: [1, 2, 5, 2, 5, 1, 5, 5, 0, 9], rest: { 18: 2, 29: 2 } } };
        }(), e5._readIFD = function(t3, r, n, a, o, s) {
          var l = t3.readUshort(r, n);
          n += 2;
          var u = {};
          s.debug && i("   ".repeat(o), a.length - 1, ">>>----------------");
          for (var h = 0;h < l; h++) {
            var c = t3.readUshort(r, n);
            n += 2;
            var f = t3.readUshort(r, n);
            n += 2;
            var d = t3.readUint(r, n);
            n += 4;
            var p = t3.readUint(r, n);
            n += 4;
            var m = [];
            if (f == 1 || f == 7) {
              var _ = d < 5 ? n - 4 : p;
              _ + d > r.buffer.byteLength && (d = r.buffer.byteLength - _), m = new Uint8Array(r.buffer, _, d);
            }
            if (f == 2) {
              var g = d < 5 ? n - 4 : p, b2 = r[g], y = Math.max(0, Math.min(d - 1, r.length - g));
              b2 < 128 || y == 0 ? m.push(t3.readASCII(r, g, y)) : m = new Uint8Array(r.buffer, g, y);
            }
            if (f == 3)
              for (var w = 0;w < d; w++)
                m.push(t3.readUshort(r, (d < 3 ? n - 4 : p) + 2 * w));
            if (f == 4 || f == 13)
              for (w = 0;w < d; w++)
                m.push(t3.readUint(r, (d < 2 ? n - 4 : p) + 4 * w));
            if (f == 5 || f == 10) {
              var v = f == 5 ? t3.readUint : t3.readInt;
              for (w = 0;w < d; w++)
                m.push([v(r, p + 8 * w), v(r, p + 8 * w + 4)]);
            }
            if (f == 8)
              for (w = 0;w < d; w++)
                m.push(t3.readShort(r, (d < 3 ? n - 4 : p) + 2 * w));
            if (f == 9)
              for (w = 0;w < d; w++)
                m.push(t3.readInt(r, (d < 2 ? n - 4 : p) + 4 * w));
            if (f == 11)
              for (w = 0;w < d; w++)
                m.push(t3.readFloat(r, p + 4 * w));
            if (f == 12)
              for (w = 0;w < d; w++)
                m.push(t3.readDouble(r, p + 8 * w));
            if (d == 0 || m.length != 0) {
              if (s.debug && i("   ".repeat(o), c, f, e5.tags[c], m), u["t" + c] = m, c == 330 && u.t272 && u.t272[0] == "DSLR-A100")
                ;
              else if (c == 330 || c == 34665 || c == 34853 || c == 50740 && t3.readUshort(r, t3.readUint(m, 0)) < 300 || c == 61440) {
                var x = c == 50740 ? [t3.readUint(m, 0)] : m, E = [];
                for (w = 0;w < x.length; w++)
                  e5._readIFD(t3, r, x[w], E, o + 1, s);
                c == 330 && (u.subIFD = E), c == 34665 && (u.exifIFD = E[0]), c == 34853 && (u.gpsiIFD = E[0]), c == 50740 && (u.dngPrvt = E[0]), c == 61440 && (u.fujiIFD = E[0]);
              }
              if (c == 37500 && s.parseMN) {
                var k = m;
                if (t3.readASCII(k, 0, 5) == "Nikon")
                  u.makerNote = e5.decode(k.slice(10).buffer)[0];
                else if (t3.readASCII(k, 0, 5) == "OLYMP" || t3.readASCII(k, 0, 9) == "OM SYSTEM") {
                  var S = [8208, 8224, 8240, 8256, 8272], A = [];
                  e5._readIFD(t3, k, k[1] == 77 ? 16 : k[5] == 85 ? 12 : 8, A, o + 1, s);
                  var I = u.makerNote = A.pop();
                  for (w = 0;w < S.length; w++) {
                    var M = "t" + S[w];
                    I[M] != null && (e5._readIFD(t3, k, I[M][0], A, o + 1, s), I[M] = A.pop());
                  }
                  I.t12288 && (e5._readIFD(t3, I.t12288, 0, A, o + 1, s), I.t12288 = A.pop());
                } else if (t3.readUshort(r, p) < 300 && t3.readUshort(r, p + 4) <= 12) {
                  A = [];
                  e5._readIFD(t3, r, p, A, o + 1, s), u.makerNote = A[0];
                }
              }
            } else if (i(c, "unknown TIFF tag type: ", f, "num:", d), h == 0)
              return;
          }
          return a.push(u), s.debug && i("   ".repeat(o), "<<<---------------"), n;
        }, e5._writeIFD = function(t3, i2, r, n, a) {
          var o = Object.keys(a), s = o.length;
          a.exifIFD && s--, a.gpsiIFD && s--, t3.writeUshort(r, n, s);
          for (var l = (n += 2) + 12 * s + 4, u = 0;u < o.length; u++) {
            var h = o[u];
            if (h != "t34665" && h != "t34853") {
              h == "exifIFD" && (h = "t34665"), h == "gpsiIFD" && (h = "t34853");
              var c = parseInt(h.slice(1)), f = i2.main[c];
              if (f == null && (f = i2.rest[c]), f == null || f == 0)
                throw new Error("unknown type of tag: " + c);
              var d = a[h];
              if (c == 34665)
                d = [l], l = e5._writeIFD(t3, i2, r, l, a.exifIFD)[1];
              if (c == 34853)
                d = [l], l = e5._writeIFD(t3, e5._types.gps, r, l, a.gpsiIFD)[1];
              f == 2 && (d = d[0] + "\0");
              var p = d.length;
              t3.writeUshort(r, n, c), n += 2, t3.writeUshort(r, n, f), n += 2, t3.writeUint(r, n, p);
              var m = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][f] * p, _ = n += 4;
              if (m > 4 && (t3.writeUint(r, n, l), _ = l), f == 1 || f == 7)
                for (var g = 0;g < p; g++)
                  r[_ + g] = d[g];
              else if (f == 2)
                t3.writeASCII(r, _, d);
              else if (f == 3)
                for (g = 0;g < p; g++)
                  t3.writeUshort(r, _ + 2 * g, d[g]);
              else if (f == 4)
                for (g = 0;g < p; g++)
                  t3.writeUint(r, _ + 4 * g, d[g]);
              else if (f == 5 || f == 10) {
                var b2 = f == 5 ? t3.writeUint : t3.writeInt;
                for (g = 0;g < p; g++) {
                  var y = d[g], w = y[0], v = y[1];
                  if (w == null)
                    throw "e";
                  b2(r, _ + 8 * g, w), b2(r, _ + 8 * g + 4, v);
                }
              } else if (f == 9)
                for (g = 0;g < p; g++)
                  t3.writeInt(r, _ + 4 * g, d[g]);
              else {
                if (f != 12)
                  throw f;
                for (g = 0;g < p; g++)
                  t3.writeDouble(r, _ + 8 * g, d[g]);
              }
              m > 4 && (l += m += 1 & m), n += 4;
            }
          }
          return [n, l];
        }, e5.toRGBA8 = function(e6, t3) {
          function r(e7) {
            return e7 < 0.0031308 ? 12.92 * e7 : 1.055 * Math.pow(e7, 1 / 2.4) - 0.055;
          }
          var { width: n, height: a } = e6, o = n * a, s = e6.data, l = new Uint8Array(4 * o), u = e6.t262 ? e6.t262[0] : 2, h = e6.t258 ? Math.min(32, e6.t258[0]) : 1;
          e6.t262 == null && h == 1 && (u = 0);
          var c = e6.t277 ? e6.t277[0] : e6.t258 ? e6.t258.length : [1, 1, 3, 1, 1, 4, 3][u], f = e6.t339 ? e6.t339[0] : null;
          if (u == 1 && h == 32 && f != 3)
            throw "e";
          var d = Math.ceil(c * h * n / 8);
          if (u == 0) {
            t3 = 1 / 256;
            for (var p = 0;p < a; p++) {
              var m = p * d, _ = p * n;
              if (h == 1)
                for (var g = 0;g < n; g++) {
                  var b2 = _ + g << 2, y = s[m + (g >> 3)] >> 7 - (7 & g) & 1;
                  l[b2] = l[b2 + 1] = l[b2 + 2] = 255 * (1 - y), l[b2 + 3] = 255;
                }
              if (h == 4)
                for (g = 0;g < n; g++) {
                  b2 = _ + g << 2, y = s[m + (g >> 1)] >> 4 - 4 * (1 & g) & 15;
                  l[b2] = l[b2 + 1] = l[b2 + 2] = 17 * (15 - y), l[b2 + 3] = 255;
                }
              if (h == 8)
                for (g = 0;g < n; g++) {
                  b2 = _ + g << 2, y = s[m + g];
                  l[b2] = l[b2 + 1] = l[b2 + 2] = 255 - y, l[b2 + 3] = 255;
                }
              if (h == 16)
                for (g = 0;g < n; g++) {
                  b2 = _ + g << 2, y = s[(v = m + 2 * g) + 1] << 8 | s[v];
                  l[b2] = l[b2 + 1] = l[b2 + 2] = Math.min(255, 255 - ~~(y * t3)), l[b2 + 3] = 255;
                }
            }
          } else if (u == 1) {
            t3 == null && (t3 = 1 / 256);
            var w = 3 & s.length ? null : new Float32Array(s.buffer);
            for (p = 0;p < a; p++) {
              m = p * d, _ = p * n;
              if (h == 1)
                for (g = 0;g < n; g++) {
                  b2 = _ + g << 2, y = s[m + (g >> 3)] >> 7 - (7 & g) & 1;
                  l[b2] = l[b2 + 1] = l[b2 + 2] = 255 * y, l[b2 + 3] = 255;
                }
              if (h == 2)
                for (g = 0;g < n; g++) {
                  b2 = _ + g << 2, y = s[m + (g >> 2)] >> 6 - 2 * (3 & g) & 3;
                  l[b2] = l[b2 + 1] = l[b2 + 2] = 85 * y, l[b2 + 3] = 255;
                }
              if (h == 8)
                for (g = 0;g < n; g++) {
                  b2 = _ + g << 2, y = s[m + g * c];
                  l[b2] = l[b2 + 1] = l[b2 + 2] = y, l[b2 + 3] = 255;
                }
              if (h == 16)
                for (g = 0;g < n; g++) {
                  b2 = _ + g << 2, y = s[(v = m + 2 * g) + 1] << 8 | s[v];
                  l[b2] = l[b2 + 1] = l[b2 + 2] = Math.min(255, ~~(y * t3)), l[b2 + 3] = 255;
                }
              if (h == 32)
                for (g = 0;g < n; g++) {
                  var v;
                  b2 = _ + g << 2, y = w[v = (m >>> 2) + g];
                  l[b2] = l[b2 + 1] = l[b2 + 2] = ~~(0.5 + 255 * y), l[b2 + 3] = 255;
                }
            }
          } else if (u == 2)
            if (h == 8) {
              if (c == 1)
                for (g = 0;g < o; g++)
                  l[4 * g] = l[4 * g + 1] = l[4 * g + 2] = s[g], l[4 * g + 3] = 255;
              if (c == 3)
                for (g = 0;g < o; g++) {
                  var x = 3 * g;
                  l[b2 = g << 2] = s[x], l[b2 + 1] = s[x + 1], l[b2 + 2] = s[x + 2], l[b2 + 3] = 255;
                }
              if (c >= 4)
                for (g = 0;g < o; g++) {
                  x = g * c;
                  l[b2 = g << 2] = s[x], l[b2 + 1] = s[x + 1], l[b2 + 2] = s[x + 2], l[b2 + 3] = s[x + 3];
                }
            } else if (h == 16) {
              if (c == 4)
                for (g = 0;g < o; g++) {
                  x = 8 * g + 1;
                  l[b2 = g << 2] = s[x], l[b2 + 1] = s[x + 2], l[b2 + 2] = s[x + 4], l[b2 + 3] = s[x + 6];
                }
              if (c == 3)
                for (g = 0;g < o; g++) {
                  x = 6 * g + 1;
                  l[b2 = g << 2] = s[x], l[b2 + 1] = s[x + 2], l[b2 + 2] = s[x + 4], l[b2 + 3] = 255;
                }
            } else {
              if (h != 32)
                throw h;
              var E = new Float32Array(s.buffer), k = 0;
              for (g = 0;g < E.length; g++)
                k = Math.min(k, E[g]);
              if (k < 0)
                for (g = 0;g < s.length; g += 4) {
                  var S = s[g];
                  s[g] = s[g + 3], s[g + 3] = S, S = s[g + 1], s[g + 1] = s[g + 2], s[g + 2] = S;
                }
              var A = [];
              for (g = 0;g < 65536; g++)
                A.push(r(g / 65535));
              for (g = 0;g < E.length; g++) {
                var I = Math.max(0, Math.min(1, E[g]));
                E[g] = A[~~(0.5 + 65535 * I)];
              }
              if (c == 3)
                for (g = 0;g < o; g++) {
                  x = 3 * g;
                  l[b2 = g << 2] = ~~(0.5 + 255 * E[x]), l[b2 + 1] = ~~(0.5 + 255 * E[x + 1]), l[b2 + 2] = ~~(0.5 + 255 * E[x + 2]), l[b2 + 3] = 255;
                }
              else {
                if (c != 4)
                  throw c;
                for (g = 0;g < o; g++) {
                  x = 4 * g;
                  l[b2 = g << 2] = ~~(0.5 + 255 * E[x]), l[b2 + 1] = ~~(0.5 + 255 * E[x + 1]), l[b2 + 2] = ~~(0.5 + 255 * E[x + 2]), l[b2 + 3] = ~~(0.5 + 255 * E[x + 3]);
                }
              }
            }
          else if (u == 3) {
            var M = e6.t320, T = 1 << h, P = h == 8 && c > 1 && e6.t338 && e6.t338[0] != 0;
            for (p = 0;p < a; p++)
              for (var B = 0;B < n; B++) {
                b2 = (g = p * n + B) << 2;
                var C = 0, R = p * d;
                if (h == 1)
                  C = s[R + (B >>> 3)] >>> 7 - (7 & B) & 1;
                else if (h == 2)
                  C = s[R + (B >>> 2)] >>> 6 - 2 * (3 & B) & 3;
                else if (h == 4)
                  C = s[R + (B >>> 1)] >>> 4 - 4 * (1 & B) & 15;
                else {
                  if (h != 8)
                    throw h;
                  C = s[R + B * c];
                }
                l[b2] = M[C] >> 8, l[b2 + 1] = M[T + C] >> 8, l[b2 + 2] = M[T + T + C] >> 8, l[b2 + 3] = P ? s[R + B * c + 1] : 255;
              }
          } else if (u == 5) {
            var z = c > 4 ? 1 : 0;
            for (g = 0;g < o; g++) {
              b2 = g << 2;
              var F = g * c;
              if (window.UDOC) {
                var N = s[F], O = s[F + 1], D = s[F + 2], $ = s[F + 3], L = UDOC.C.cmykToRgb([N * (1 / 255), O * (1 / 255), D * (1 / 255), $ * (1 / 255)]);
                l[b2] = ~~(0.5 + 255 * L[0]), l[b2 + 1] = ~~(0.5 + 255 * L[1]), l[b2 + 2] = ~~(0.5 + 255 * L[2]);
              } else {
                N = 255 - s[F], O = 255 - s[F + 1], D = 255 - s[F + 2], $ = (255 - s[F + 3]) * (1 / 255);
                l[b2] = ~~(N * $ + 0.5), l[b2 + 1] = ~~(O * $ + 0.5), l[b2 + 2] = ~~(D * $ + 0.5);
              }
              l[b2 + 3] = 255 * (1 - z) + s[F + 4] * z;
            }
          } else if (u == 6 && e6.t278) {
            var U = e6.t278[0];
            for (p = 0;p < a; p += U) {
              g = p * n;
              for (var Z = U * n, j = 0;j < Z; j++) {
                b2 = 4 * (g + j), D = s[(F = 3 * g + 4 * (j >>> 1)) + (1 & j)];
                var G = s[F + 2] - 128, H = s[F + 3] - 128, Q = D + ((H >> 2) + (H >> 3) + (H >> 5)), W = D - ((G >> 2) + (G >> 4) + (G >> 5)) - ((H >> 1) + (H >> 3) + (H >> 4) + (H >> 5)), q = D + (G + (G >> 1) + (G >> 2) + (G >> 6));
                l[b2] = Math.max(0, Math.min(255, Q)), l[b2 + 1] = Math.max(0, Math.min(255, W)), l[b2 + 2] = Math.max(0, Math.min(255, q)), l[b2 + 3] = 255;
              }
            }
          } else if (u == 32845)
            for (p = 0;p < a; p++)
              for (B = 0;B < n; B++) {
                b2 = 4 * (p * n + B);
                var V = s[(F = 6 * (p * n + B)) + 1] << 8 | s[F], Y = (V = Math.pow(2, (V + 0.5) / 256 - 64), (s[F + 3] + 0.5) / 410), K = (s[F + 5] + 0.5) / 410, J = 9 * Y / (6 * Y - 16 * K + 12), X = 4 * K / (6 * Y - 16 * K + 12), ee = J * V / X, te = (1 - J - X) * V / X;
                Q = 2.69 * ee - 1.276 * (D = V) - 0.414 * te, W = -1.022 * ee + 1.978 * D + 0.044 * te, q = 0.061 * ee - 0.224 * D + 1.163 * te;
                l[b2] = 255 * r(Math.min(Q, 1)), l[b2 + 1] = 255 * r(Math.min(W, 1)), l[b2 + 2] = 255 * r(Math.min(q, 1)), l[b2 + 3] = 255;
              }
          else
            i("Unknown Photometric interpretation: " + u);
          return l;
        }, e5.replaceIMG = function(t3) {
          t3 == null && (t3 = document.getElementsByTagName("img"));
          for (var i2 = ["tif", "tiff", "dng", "cr2", "nef"], r = 0;r < t3.length; r++) {
            var n = t3[r], a = n.getAttribute("src");
            if (a != null) {
              var o = a.split(".").pop().toLowerCase();
              if (i2.indexOf(o) != -1) {
                var s = new XMLHttpRequest;
                e5._xhrs.push(s), e5._imgs.push(n), s.open("GET", a), s.responseType = "arraybuffer", s.onload = e5._imgLoaded, s.send();
              }
            }
          }
        }, e5._xhrs = [], e5._imgs = [], e5._imgLoaded = function(t3) {
          var i2 = e5._xhrs.indexOf(t3.target), r = e5._imgs[i2];
          e5._xhrs.splice(i2, 1), e5._imgs.splice(i2, 1), r.setAttribute("src", e5.bufferToURI(t3.target.response));
        }, e5.bufferToURI = function(t3) {
          var i2 = e5.decode(t3), r = i2, n = 0, a = r[0];
          i2[0].subIFD && (r = r.concat(i2[0].subIFD));
          for (var o = 0;o < r.length; o++) {
            var s = r[o];
            if (!(s.t258 == null || s.t258.length < 3)) {
              var l = s.t256 * s.t257;
              l > n && (n = l, a = s);
            }
          }
          e5.decodeImage(t3, a, i2);
          var u = e5.toRGBA8(a), h = a.width, c = a.height, f = document.createElement("canvas");
          f.width = h, f.height = c;
          var d = f.getContext("2d"), p = new ImageData(new Uint8ClampedArray(u.buffer), h, c);
          return d.putImageData(p, 0, 0), f.toDataURL();
        }, e5._binBE = { nextZero: function(e6, t3) {
          for (;e6[t3] != 0; )
            t3++;
          return t3;
        }, readUshort: function(e6, t3) {
          return e6[t3] << 8 | e6[t3 + 1];
        }, readShort: function(t3, i2) {
          var r = e5._binBE.ui8;
          return r[0] = t3[i2 + 1], r[1] = t3[i2 + 0], e5._binBE.i16[0];
        }, readInt: function(t3, i2) {
          var r = e5._binBE.ui8;
          return r[0] = t3[i2 + 3], r[1] = t3[i2 + 2], r[2] = t3[i2 + 1], r[3] = t3[i2 + 0], e5._binBE.i32[0];
        }, readUint: function(t3, i2) {
          var r = e5._binBE.ui8;
          return r[0] = t3[i2 + 3], r[1] = t3[i2 + 2], r[2] = t3[i2 + 1], r[3] = t3[i2 + 0], e5._binBE.ui32[0];
        }, readASCII: function(e6, t3, i2) {
          for (var r = "", n = 0;n < i2; n++)
            r += String.fromCharCode(e6[t3 + n]);
          return r;
        }, readFloat: function(t3, i2) {
          for (var r = e5._binBE.ui8, n = 0;n < 4; n++)
            r[n] = t3[i2 + 3 - n];
          return e5._binBE.fl32[0];
        }, readDouble: function(t3, i2) {
          for (var r = e5._binBE.ui8, n = 0;n < 8; n++)
            r[n] = t3[i2 + 7 - n];
          return e5._binBE.fl64[0];
        }, writeUshort: function(e6, t3, i2) {
          e6[t3] = i2 >> 8 & 255, e6[t3 + 1] = 255 & i2;
        }, writeInt: function(t3, i2, r) {
          var n = e5._binBE.ui8;
          e5._binBE.i32[0] = r, t3[i2 + 3] = n[0], t3[i2 + 2] = n[1], t3[i2 + 1] = n[2], t3[i2 + 0] = n[3];
        }, writeUint: function(e6, t3, i2) {
          e6[t3] = i2 >> 24 & 255, e6[t3 + 1] = i2 >> 16 & 255, e6[t3 + 2] = i2 >> 8 & 255, e6[t3 + 3] = 255 & i2;
        }, writeASCII: function(e6, t3, i2) {
          for (var r = 0;r < i2.length; r++)
            e6[t3 + r] = i2.charCodeAt(r);
        }, writeDouble: function(t3, i2, r) {
          e5._binBE.fl64[0] = r;
          for (var n = 0;n < 8; n++)
            t3[i2 + n] = e5._binBE.ui8[7 - n];
        } }, e5._binBE.ui8 = new Uint8Array(8), e5._binBE.i16 = new Int16Array(e5._binBE.ui8.buffer), e5._binBE.i32 = new Int32Array(e5._binBE.ui8.buffer), e5._binBE.ui32 = new Uint32Array(e5._binBE.ui8.buffer), e5._binBE.fl32 = new Float32Array(e5._binBE.ui8.buffer), e5._binBE.fl64 = new Float64Array(e5._binBE.ui8.buffer), e5._binLE = { nextZero: e5._binBE.nextZero, readUshort: function(e6, t3) {
          return e6[t3 + 1] << 8 | e6[t3];
        }, readShort: function(t3, i2) {
          var r = e5._binBE.ui8;
          return r[0] = t3[i2 + 0], r[1] = t3[i2 + 1], e5._binBE.i16[0];
        }, readInt: function(t3, i2) {
          var r = e5._binBE.ui8;
          return r[0] = t3[i2 + 0], r[1] = t3[i2 + 1], r[2] = t3[i2 + 2], r[3] = t3[i2 + 3], e5._binBE.i32[0];
        }, readUint: function(t3, i2) {
          var r = e5._binBE.ui8;
          return r[0] = t3[i2 + 0], r[1] = t3[i2 + 1], r[2] = t3[i2 + 2], r[3] = t3[i2 + 3], e5._binBE.ui32[0];
        }, readASCII: e5._binBE.readASCII, readFloat: function(t3, i2) {
          for (var r = e5._binBE.ui8, n = 0;n < 4; n++)
            r[n] = t3[i2 + n];
          return e5._binBE.fl32[0];
        }, readDouble: function(t3, i2) {
          for (var r = e5._binBE.ui8, n = 0;n < 8; n++)
            r[n] = t3[i2 + n];
          return e5._binBE.fl64[0];
        }, writeUshort: function(e6, t3, i2) {
          e6[t3] = 255 & i2, e6[t3 + 1] = i2 >> 8 & 255;
        }, writeInt: function(t3, i2, r) {
          var n = e5._binBE.ui8;
          e5._binBE.i32[0] = r, t3[i2 + 0] = n[0], t3[i2 + 1] = n[1], t3[i2 + 2] = n[2], t3[i2 + 3] = n[3];
        }, writeUint: function(e6, t3, i2) {
          e6[t3] = i2 >>> 0 & 255, e6[t3 + 1] = i2 >>> 8 & 255, e6[t3 + 2] = i2 >>> 16 & 255, e6[t3 + 3] = i2 >>> 24 & 255;
        }, writeASCII: e5._binBE.writeASCII }, e5._copyTile = function(e6, t3, i2, r, n, a, o, s) {
          for (var l = Math.min(t3, n - o), u = Math.min(i2, a - s), h = 0;h < u; h++)
            for (var c = (s + h) * n + o, f = h * t3, d = 0;d < l; d++)
              r[c + d] = e6[f + d];
        }, e5.LosslessJpegDecode = function() {
          var e6, t3;
          function i2() {
            return e6[t3++];
          }
          function r() {
            return e6[t3++] << 8 | e6[t3++];
          }
          function n(e7) {
            for (var t4 = i2(), r2 = [0, 0, 0, 255], n2 = [], o2 = 0;o2 < 16; o2++)
              n2[o2] = i2();
            for (o2 = 0;o2 < 16; o2++)
              for (var s2 = 0;s2 < n2[o2]; s2++) {
                r2[a(r2, 0, o2 + 1, 1) + 3] = i2();
              }
            var l2 = new Uint8Array(256);
            e7[t4] = [new Uint8Array(r2), l2];
            for (o2 = 0;o2 < 256; o2++) {
              for (var u2 = 8, h2 = o2, c2 = 0;r2[c2 + 3] == 255 && u2 != 0; )
                c2 = r2[c2 + (h2 >> --u2 & 1)];
              l2[o2] = c2;
            }
          }
          function a(e7, t4, i3, r2) {
            if (e7[t4 + 3] != 255)
              return 0;
            if (i3 == 0)
              return t4;
            for (var n2 = 0;n2 < 2; n2++) {
              e7[t4 + n2] == 0 && (e7[t4 + n2] = e7.length, e7.push(0, 0, r2, 255));
              var o2 = a(e7, e7[t4 + n2], i3 - 1, r2 + 1);
              if (o2 != 0)
                return o2;
            }
            return 0;
          }
          function o(e7) {
            for (var { b: t4, f: i3 } = e7;t4 < 25 && e7.a < e7.d; ) {
              var r2 = e7.data[e7.a++];
              r2 != 255 || e7.c || e7.a++, i3 = i3 << 8 | r2, t4 += 8;
            }
            if (t4 < 0)
              throw "e";
            e7.b = t4, e7.f = i3;
          }
          function s(e7, t4) {
            return t4.b < e7 && o(t4), t4.f >> (t4.b -= e7) & 65535 >> 16 - e7;
          }
          function l(e7, t4) {
            var i3 = e7[0], r2 = 0, n2 = 255;
            t4.b < 16 && o(t4);
            var a2 = t4.f >> t4.b - 8 & 255;
            for (n2 = i3[(r2 = e7[1][a2]) + 3], t4.b -= i3[r2 + 2];n2 == 255; )
              n2 = i3[(r2 = i3[r2 + (t4.f >> --t4.b & 1)]) + 3];
            return n2;
          }
          function u(e7, t4) {
            return e7 < 32768 >> 16 - t4 && (e7 += 1 - (1 << t4)), e7;
          }
          function h(e7, t4) {
            var i3 = l(e7, t4);
            return i3 == 0 ? 0 : i3 == 16 ? -32768 : u(s(i3, t4), i3);
          }
          function c(e7, t4, i3, r2, n2, a2) {
            for (var o2 = 0, s2 = 0;s2 < a2; s2++) {
              for (var l2 = s2 * t4, u2 = 0;u2 < t4; u2 += n2) {
                o2++;
                for (var c2 = 0;c2 < n2; c2++)
                  e7[l2 + u2 + c2] = h(r2[c2], i3);
              }
              if (i3.e != 0 && o2 % i3.e == 0 && s2 != 0) {
                for (var { a: f2, data: d2 } = i3;d2[f2] != 255 || !(208 <= d2[f2 + 1] && d2[f2 + 1] <= 215); )
                  f2--;
                i3.a = f2 + 2, i3.f = 0, i3.b = 0;
              }
            }
          }
          function f(e7, t4) {
            return u(s(e7, t4), e7);
          }
          function d(e7, t4, i3, r2, n2, a2, o2, s2) {
            for (var l2 = i3 * o2, u2 = n2;u2 < a2; u2++)
              e7[u2] += 1 << s2 - 1;
            for (var h2 = o2;h2 < l2; h2 += o2)
              for (u2 = n2;u2 < a2; u2++)
                e7[h2 + u2] += e7[h2 + u2 - o2];
            for (var c2 = 1;c2 < r2; c2++) {
              var f2 = c2 * l2;
              for (u2 = n2;u2 < a2; u2++)
                e7[f2 + u2] += e7[f2 + u2 - l2];
              for (h2 = o2;h2 < l2; h2 += o2)
                for (u2 = n2;u2 < a2; u2++) {
                  var d2 = f2 + h2 + u2, p = d2 - l2, m = e7[d2 - o2], _ = 0;
                  if (t4 == 0)
                    _ = 0;
                  else if (t4 == 1)
                    _ = m;
                  else if (t4 == 2)
                    _ = e7[p];
                  else if (t4 == 3)
                    _ = e7[p - o2];
                  else if (t4 == 4)
                    _ = m + (e7[p] - e7[p - o2]);
                  else if (t4 == 5)
                    _ = m + (e7[p] - e7[p - o2] >>> 1);
                  else if (t4 == 6)
                    _ = e7[p] + (m - e7[p - o2] >>> 1);
                  else {
                    if (t4 != 7)
                      throw t4;
                    _ = m + e7[p] >>> 1;
                  }
                  e7[d2] += _;
                }
            }
          }
          return function(a2) {
            if (e6 = a2, t3 = 0, r() != 65496)
              throw "e";
            for (var o2 = [], s2 = 0, u2 = 0, h2 = 0, p = [], m = [], _ = [], g = 0, b2 = 0, y = 0;; ) {
              var w = r();
              if (w != 65535) {
                var v = r();
                if (w == 65475) {
                  u2 = i2(), b2 = r(), y = r(), g = i2();
                  for (var x = 0;x < g; x++) {
                    var E = i2(), k = i2();
                    if (i2() != 0)
                      throw "e";
                    o2[E] = [x, k >> 4, 15 & k];
                  }
                } else if (w == 65476)
                  for (var S = t3 + v - 2;t3 < S; )
                    n(m);
                else {
                  if (w == 65498) {
                    t3++;
                    for (x = 0;x < g; x++) {
                      var A = o2[i2()];
                      _[A[0]] = m[i2() >>> 4], p[A[0]] = A.slice(1);
                    }
                    s2 = i2(), t3 += 2;
                    break;
                  }
                  w == 65501 ? h2 = r() : t3 += v - 2;
                }
              } else
                t3--;
            }
            var I = new (u2 > 8 ? Uint16Array : Uint8Array)(b2 * y * g), M = { b: 0, f: 0, c: s2 == 8, a: t3, data: e6, d: e6.length, e: h2 };
            if (M.c)
              (function(i3, r2, n2, a3, o3) {
                for (var s3 = e6.length - t3, u3 = 0;u3 < s3; u3 += 4) {
                  var h3 = e6[t3 + u3];
                  e6[t3 + u3] = e6[t3 + u3 + 3], e6[t3 + u3 + 3] = h3, h3 = e6[t3 + u3 + 1], e6[t3 + u3 + 1] = e6[t3 + u3 + 2], e6[t3 + u3 + 2] = h3;
                }
                for (var c2 = 0;c2 < o3; c2++)
                  for (var d2 = 32768, p2 = 32768, m2 = 0;m2 < r2; m2 += 2) {
                    var _2 = l(a3, n2), g2 = l(a3, n2);
                    _2 != 0 && (d2 += f(_2, n2)), g2 != 0 && (p2 += f(g2, n2)), i3[c2 * r2 + m2] = 65535 & d2, i3[c2 * r2 + m2 + 1] = 65535 & p2;
                  }
              })(I, y * g, M, _[0], b2);
            else {
              var T = [], P = 0, B = 0;
              for (x = 0;x < g; x++) {
                var C = p[x];
                (Z = C[0]) > P && (P = Z), (U = C[1]) > B && (B = U), T.push(Z * U);
              }
              if (P != 1 || B != 1) {
                if (g != 3 || T[1] != 1 || T[2] != 1)
                  throw "e";
                if (P != 2 || B != 1 && B != 2)
                  throw "e";
                var R = [], z = 0;
                for (x = 0;x < g; x++) {
                  for (var F = 0;F < T[x]; F++)
                    R.push(_[x]);
                  z += T[x];
                }
                var N = y / P, O = b2 / B, D = N * O;
                c(I, N * z, M, R, z, O), d(I, s2, N, O, z - 2, z, z, u2);
                var $ = new Uint16Array(D * T[0]);
                if (P == 2 && B == 2) {
                  for (x = 0;x < D; x++)
                    $[4 * x] = I[6 * x], $[4 * x + 1] = I[6 * x + 1], $[4 * x + 2] = I[6 * x + 2], $[4 * x + 3] = I[6 * x + 3];
                  d($, s2, 4 * N, O, 0, 1, 1, u2);
                  for (x = 0;x < D; x++)
                    I[6 * x] = $[4 * x], I[6 * x + 1] = $[4 * x + 1], I[6 * x + 2] = $[4 * x + 2], I[6 * x + 3] = $[4 * x + 3];
                }
                if (P == 2 && B == 1) {
                  for (x = 0;x < D; x++)
                    $[2 * x] = I[4 * x], $[2 * x + 1] = I[4 * x + 1];
                  d($, s2, 2 * N, O, 0, 1, 1, u2);
                  for (x = 0;x < D; x++)
                    I[4 * x] = $[2 * x], I[4 * x + 1] = $[2 * x + 1];
                }
                for (var L = I.slice(0), U = 0;U < b2; U++)
                  if (B == 2)
                    for (var Z = 0;Z < y; Z++) {
                      var j = ((U >>> 1) * N + (Z >>> 1)) * z, G = 2 * (1 & U) + (1 & Z);
                      I[H = (U * y + Z) * g] = L[j + G], I[H + 1] = L[j + 4], I[H + 2] = L[j + 5];
                    }
                  else
                    for (Z = 0;Z < y; Z++) {
                      var H;
                      j = (U * N + (Z >>> 1)) * z, G = 1 & Z;
                      I[H = (U * y + Z) * g] = L[j + G], I[H + 1] = L[j + 2], I[H + 2] = L[j + 3];
                    }
              } else if (c(I, y * g, M, _, g, b2), h2 == 0)
                d(I, s2, y, b2, 0, g, g, u2);
              else {
                var Q = Math.floor(h2 / y);
                for (U = 0;U < b2; U += Q) {
                  var W = I.slice(U * y * g, (U + Q) * y * g);
                  d(W, s2, y, Q, 0, g, g, u2), I.set(W, U * y * g);
                }
              }
            }
            return I;
          };
        }(), function() {
          var t3 = 2, i2 = 4, r = 5, n = 6, a = 7, o = 12, s = 13, l = 14, u = 15, h = 17;
          function c(e6) {
            var t4 = { c: new Int8Array(2 << e6.u) };
            return function(e7, t5, i3) {
              var r2 = [t5, 3 * t5 + 18, 5 * t5 + 67, 7 * t5 + 276, i3];
              e7.o = t5, e7.w = (r2[4] + 2 * t5) / (2 * t5 + 1) + 1 | 0, e7.v = Math.ceil(Math.log2(e7.w)), e7.t = 9, function(e8, t6) {
                for (var i4 = -t6[4], r3 = 0;i4 <= t6[4]; r3++, i4++)
                  e8[r3] = i4 <= -t6[3] ? -4 : i4 <= -t6[2] ? -3 : i4 <= -t6[1] ? -2 : i4 < -t6[0] ? -1 : i4 <= t6[0] ? 0 : i4 < t6[1] ? 1 : i4 < t6[2] ? 2 : i4 < t6[3] ? 3 : 4;
              }(e7.c, r2);
            }(t4, 0, e6.g), t4;
          }
          function f(e6) {
            for (var t4 = [[], [], []], i3 = Math.max(2, e6.w + 32 >>> 6), r2 = 0;r2 < 3; r2++)
              for (var n2 = 0;n2 < 41; n2++)
                t4[r2][n2] = [i3, 1];
            return t4;
          }
          function d(e6, t4) {
            var i3 = 0, r2 = 8 - e6.a;
            if (e6.j, e6.a, t4) {
              if (t4 >= r2)
                do {
                  i3 <<= r2, t4 -= r2, i3 |= e6[e6.j] & (1 << r2) - 1, e6.j++, r2 = 8;
                } while (t4 >= 8);
              t4 && (i3 <<= t4, r2 -= t4, i3 |= e6[e6.j] >>> r2 & (1 << t4) - 1), e6.a = 8 - r2;
            }
            return i3;
          }
          function p(e6, t4, i3, r2, n2, a2, o2, s2) {
            s2 == null && (s2 = 0);
            var l2, u2, h2, c2, f2, p2, m2 = a2 + 1, _2 = m2 % 2, g2 = 0, b3 = r2[n2], y2 = r2[n2 - 1], w = r2[n2 - 2][m2], v = y2[m2 - 1], x = y2[m2], E = y2[m2 + 1], k = b3[m2 - 1], S = b3[m2 + 1], A = Math.abs;
            if (_2 && (h2 = A(E - x), c2 = A(w - x), f2 = A(v - x)), _2) {
              if (p2 = (p2 = h2 > f2 && c2 < h2 ? w + v : h2 < f2 && c2 < f2 ? w + E : E + v) + 2 * x >>> 2, s2)
                return void (b3[m2] = p2);
              l2 = t4.t * t4.c[e6.g + x - w] + t4.c[e6.g + v - x];
            } else
              p2 = x > v && x > E || x < v && x < E ? S + k + 2 * x >>> 2 : k + S >>> 1, l2 = t4.t * t4.c[e6.g + x - v] + t4.c[e6.g + v - k];
            u2 = A(l2);
            var I = function(e7) {
              for (var t5 = -1, i4 = 0;!i4; t5++)
                i4 = e7[e7.j] >>> 7 - e7.a & 1, e7.a++, e7.a &= 7, e7.a || e7.j++;
              return t5;
            }(i3);
            if (I < e6.n - t4.v - 1) {
              var M = function(e7, t5) {
                var i4 = 0;
                if (t5 < e7)
                  for (;i4 <= 14 && t5 << ++i4 < e7; )
                    ;
                return i4;
              }(o2[u2][0], o2[u2][1]);
              g2 = d(i3, M) + (I << M);
            } else
              g2 = d(i3, t4.v) + 1;
            g2 = 1 & g2 ? -1 - (g2 >>> 1) : g2 >>> 1, o2[u2][0] += A(g2), o2[u2][1] == e6.f && (o2[u2][0] >>>= 1, o2[u2][1] >>>= 1), o2[u2][1]++, p2 = l2 < 0 ? p2 - g2 : p2 + g2, e6.i && (p2 < 0 ? p2 += t4.w : p2 > e6.g && (p2 -= t4.w)), b3[m2] = p2 >= 0 ? Math.min(p2, e6.g) : 0;
          }
          function m(e6, t4, i3) {
            for (var r2 = e6[0].length, n2 = t4;n2 <= i3; n2++)
              e6[n2][0] = e6[n2 - 1][1], e6[n2][r2 - 1] = e6[n2 - 1][r2 - 2];
          }
          function _(e6) {
            m(e6, a, o), m(e6, t3, i2), m(e6, u, h);
          }
          function g(e6, t4, r2, n2, a2, o2, l2, u2, h2, c2, f2, d2, m2) {
            for (var g2 = 0, b3 = 1, y2 = a2 < s && a2 > i2;b3 < e6.m; )
              g2 < e6.m && (p(e6, t4, r2, n2, a2, g2, l2[h2], e6.h && (y2 && c2 || !y2 && (f2 || (g2 & d2) == m2))), p(e6, t4, r2, n2, o2, g2, l2[h2], e6.h && (!y2 && c2 || y2 && (f2 || (g2 & d2) == m2))), g2 += 2), g2 > 8 && (p(e6, t4, r2, n2, a2, b3, u2[h2]), p(e6, t4, r2, n2, o2, b3, u2[h2]), b3 += 2);
            _(n2);
          }
          function b2(e6, r2, n2, s2, l2, c2) {
            g(e6, r2, n2, s2, t3, a, l2, c2, 0, 0, 1, 0, 8), g(e6, r2, n2, s2, 8, u, l2, c2, 1, 0, 1, 0, 8), g(e6, r2, n2, s2, 3, 9, l2, c2, 2, 1, 0, 3, 0), g(e6, r2, n2, s2, 10, 16, l2, c2, 0, 0, 0, 3, 2), g(e6, r2, n2, s2, i2, 11, l2, c2, 1, 0, 0, 3, 2), g(e6, r2, n2, s2, o, h, l2, c2, 2, 1, 0, 3, 0);
          }
          function y(e6, i3, r2, n2, o2, s2) {
            var l2 = s2.length, h2 = e6.l;
            o2 + 1 == e6.s && (h2 = e6.e - o2 * e6.l);
            for (var c2 = 6 * e6.e * n2 + o2 * e6.l, f2 = 0;f2 < 6; f2++) {
              for (var d2 = 0;d2 < h2; d2++) {
                var p2, m2 = s2[f2 % l2][d2 % l2];
                p2 = m2 == 0 ? t3 + (f2 >>> 1) : m2 == 2 ? u + (f2 >>> 1) : a + f2;
                var _2 = e6.h ? (2 * d2 / 3 & 2147483646 | d2 % 3 & 1) + (d2 % 3 >>> 1) : d2 >>> 1;
                i3[c2 + d2] = r2[p2][_2 + 1];
              }
              c2 += e6.e;
            }
          }
          e5._decompressRAF = function(a2, u2) {
            var d2 = function(t4) {
              var i3 = e5._binBE.readUshort, r2 = { b: i3(t4, 0), i: t4[2], C: t4[3], u: t4[4], q: i3(t4, 5), k: i3(t4, 7), e: i3(t4, 9), l: i3(t4, 11), s: t4[13], d: i3(t4, 14) };
              if (r2.b != 18771 || r2.i > 1 || r2.q < 6 || r2.q % 6 || r2.e < 768 || r2.e % 24 || r2.l != 768 || r2.k < r2.l || r2.k % r2.l || r2.k - r2.e >= r2.l || r2.s > 16 || r2.s != r2.k / r2.l || r2.s != Math.ceil(r2.e / r2.l) || r2.d != r2.q / 6 || r2.u != 12 && r2.u != 14 && r2.u != 16 || r2.C != 16 && r2.C != 0)
                throw "Invalid data";
              if (r2.i == 0)
                throw "Not implemented. We need this file!";
              return r2.h = r2.C == 16, r2.m = 0 | (r2.h ? 2 * r2.l / 3 : r2.l >>> 1), r2.A = r2.m + 2, r2.f = 64, r2.g = (1 << r2.u) - 1, r2.n = 4 * r2.u, r2;
            }(a2), p2 = function(t4, i3) {
              var r2 = new Array(i3.s), n2 = 4 * i3.s, a3 = 16 + n2;
              12 & n2 && (a3 += 16 - (12 & n2));
              for (var o2 = 0, s2 = 16;o2 < i3.s; s2 += 4) {
                var l2 = e5._binBE.readUint(t4, s2);
                r2[o2] = t4.slice(a3, a3 + l2), r2[o2].j = 0, r2[o2].a = 0, a3 += l2, o2++;
              }
              if (a3 != t4.length)
                throw "Invalid data";
              return r2;
            }(a2, d2), m2 = c(d2), g2 = new Int16Array(d2.e * d2.q);
            u2 == null && (u2 = d2.h ? [[1, 1, 0, 1, 1, 2], [1, 1, 2, 1, 1, 0], [2, 0, 1, 0, 2, 1], [1, 1, 2, 1, 1, 0], [1, 1, 0, 1, 1, 2], [0, 2, 1, 2, 0, 1]] : [[0, 1], [3, 2]]);
            for (var w = [[0, 3], [1, i2], [r, 11], [n, o], [s, 16], [l, h]], v = [], x = 0;x < 18; x++)
              v[x] = new Uint16Array(d2.A);
            for (var E = 0;E < d2.s; E++) {
              var k = f(m2), S = f(m2);
              for (x = 0;x < 18; x++)
                for (var A = 0;A < d2.A; A++)
                  v[x][A] = 0;
              for (var I = 0;I < d2.d; I++) {
                b2(d2, m2, p2[E], v, k, S);
                for (x = 0;x < 6; x++)
                  for (A = 0;A < d2.A; A++)
                    v[w[x][0]][A] = v[w[x][1]][A];
                y(d2, g2, v, I, E, u2);
                for (x = t3;x < 18; x++)
                  if ([r, n, s, l].indexOf(x) == -1)
                    for (A = 0;A < d2.A; A++)
                      v[x][A] = 0;
                _(v);
              }
            }
            return g2;
          };
        }();
      }(t, typeof commonjsRequire == "function" ? requirePako() : self.pako);
    })();
  })(UTIF);
  UTIFExports = UTIF.exports;
  utif = getDefaultExportFromCjs(UTIFExports);
  (function(e4) {
    e4.assertEqual = (e5) => e5, e4.assertIs = function(e5) {
    }, e4.assertNever = function(e5) {
      throw new Error;
    }, e4.arrayToEnum = (e5) => {
      const t = {};
      for (const i of e5)
        t[i] = i;
      return t;
    }, e4.getValidEnumValues = (t) => {
      const i = e4.objectKeys(t).filter((e5) => typeof t[t[e5]] != "number"), r = {};
      for (const e5 of i)
        r[e5] = t[e5];
      return e4.objectValues(r);
    }, e4.objectValues = (t) => e4.objectKeys(t).map(function(e5) {
      return t[e5];
    }), e4.objectKeys = typeof Object.keys == "function" ? (e5) => Object.keys(e5) : (e5) => {
      const t = [];
      for (const i in e5)
        Object.prototype.hasOwnProperty.call(e5, i) && t.push(i);
      return t;
    }, e4.find = (e5, t) => {
      for (const i of e5)
        if (t(i))
          return i;
    }, e4.isInteger = typeof Number.isInteger == "function" ? (e5) => Number.isInteger(e5) : (e5) => typeof e5 == "number" && isFinite(e5) && Math.floor(e5) === e5, e4.joinValues = function(e5, t = " | ") {
      return e5.map((e6) => typeof e6 == "string" ? `'${e6}'` : e6).join(t);
    }, e4.jsonStringifyReplacer = (e5, t) => typeof t == "bigint" ? t.toString() : t;
  })(util$1 || (util$1 = {})), function(e4) {
    e4.mergeShapes = (e5, t) => ({ ...e5, ...t });
  }(objectUtil || (objectUtil = {}));
  ZodParsedType = util$1.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
  getParsedType = (e4) => {
    switch (typeof e4) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(e4) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        return Array.isArray(e4) ? ZodParsedType.array : e4 === null ? ZodParsedType.null : e4.then && typeof e4.then == "function" && e4.catch && typeof e4.catch == "function" ? ZodParsedType.promise : typeof Map != "undefined" && e4 instanceof Map ? ZodParsedType.map : typeof Set != "undefined" && e4 instanceof Set ? ZodParsedType.set : typeof Date != "undefined" && e4 instanceof Date ? ZodParsedType.date : ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  ZodIssueCode = util$1.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
  quotelessJson = (e4) => JSON.stringify(e4, null, 2).replace(/"([^"]+)":/g, "$1:");
  ZodError.create = (e4) => new ZodError(e4);
  errorMap = (e4, t) => {
    let i;
    switch (e4.code) {
      case ZodIssueCode.invalid_type:
        i = e4.received === ZodParsedType.undefined ? "Required" : `Expected ${e4.expected}, received ${e4.received}`;
        break;
      case ZodIssueCode.invalid_literal:
        i = `Invalid literal value, expected ${JSON.stringify(e4.expected, util$1.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        i = `Unrecognized key(s) in object: ${util$1.joinValues(e4.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        i = "Invalid input";
        break;
      case ZodIssueCode.invalid_union_discriminator:
        i = `Invalid discriminator value. Expected ${util$1.joinValues(e4.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        i = `Invalid enum value. Expected ${util$1.joinValues(e4.options)}, received '${e4.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        i = "Invalid function arguments";
        break;
      case ZodIssueCode.invalid_return_type:
        i = "Invalid function return type";
        break;
      case ZodIssueCode.invalid_date:
        i = "Invalid date";
        break;
      case ZodIssueCode.invalid_string:
        typeof e4.validation == "object" ? "includes" in e4.validation ? (i = `Invalid input: must include "${e4.validation.includes}"`, typeof e4.validation.position == "number" && (i = `${i} at one or more positions greater than or equal to ${e4.validation.position}`)) : ("startsWith" in e4.validation) ? i = `Invalid input: must start with "${e4.validation.startsWith}"` : ("endsWith" in e4.validation) ? i = `Invalid input: must end with "${e4.validation.endsWith}"` : util$1.assertNever(e4.validation) : i = e4.validation !== "regex" ? `Invalid ${e4.validation}` : "Invalid";
        break;
      case ZodIssueCode.too_small:
        i = e4.type === "array" ? `Array must contain ${e4.exact ? "exactly" : e4.inclusive ? "at least" : "more than"} ${e4.minimum} element(s)` : e4.type === "string" ? `String must contain ${e4.exact ? "exactly" : e4.inclusive ? "at least" : "over"} ${e4.minimum} character(s)` : e4.type === "number" ? `Number must be ${e4.exact ? "exactly equal to " : e4.inclusive ? "greater than or equal to " : "greater than "}${e4.minimum}` : e4.type === "date" ? `Date must be ${e4.exact ? "exactly equal to " : e4.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e4.minimum))}` : "Invalid input";
        break;
      case ZodIssueCode.too_big:
        i = e4.type === "array" ? `Array must contain ${e4.exact ? "exactly" : e4.inclusive ? "at most" : "less than"} ${e4.maximum} element(s)` : e4.type === "string" ? `String must contain ${e4.exact ? "exactly" : e4.inclusive ? "at most" : "under"} ${e4.maximum} character(s)` : e4.type === "number" ? `Number must be ${e4.exact ? "exactly" : e4.inclusive ? "less than or equal to" : "less than"} ${e4.maximum}` : e4.type === "bigint" ? `BigInt must be ${e4.exact ? "exactly" : e4.inclusive ? "less than or equal to" : "less than"} ${e4.maximum}` : e4.type === "date" ? `Date must be ${e4.exact ? "exactly" : e4.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e4.maximum))}` : "Invalid input";
        break;
      case ZodIssueCode.custom:
        i = "Invalid input";
        break;
      case ZodIssueCode.invalid_intersection_types:
        i = "Intersection results could not be merged";
        break;
      case ZodIssueCode.not_multiple_of:
        i = `Number must be a multiple of ${e4.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        i = "Number must be finite";
        break;
      default:
        i = t.defaultError, util$1.assertNever(e4);
    }
    return { message: i };
  };
  overrideErrorMap = errorMap;
  makeIssue = (e4) => {
    const { data: t, path: i, errorMaps: r, issueData: n } = e4, a = [...i, ...n.path || []], o = { ...n, path: a };
    if (n.message !== undefined)
      return { ...n, path: a, message: n.message };
    let s = "";
    const l = r.filter((e5) => !!e5).slice().reverse();
    for (const e5 of l)
      s = e5(o, { data: t, defaultError: s }).message;
    return { ...n, path: a, message: s };
  };
  EMPTY_PATH = [];
  INVALID = Object.freeze({ status: "aborted" });
  DIRTY = (e4) => ({ status: "dirty", value: e4 });
  OK = (e4) => ({ status: "valid", value: e4 });
  isAborted = (e4) => e4.status === "aborted";
  isDirty = (e4) => e4.status === "dirty";
  isValid = (e4) => e4.status === "valid";
  isAsync = (e4) => typeof Promise != "undefined" && e4 instanceof Promise;
  typeof SuppressedError == "function" && SuppressedError, function(e4) {
    e4.errToObj = (e5) => typeof e5 == "string" ? { message: e5 } : e5 || {}, e4.toString = (e5) => typeof e5 == "string" ? e5 : e5 == null ? undefined : e5.message;
  }(errorUtil || (errorUtil = {}));
  handleResult = (e4, t) => {
    if (isValid(t))
      return { success: true, data: t.value };
    if (!e4.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return { success: false, get error() {
      if (this._error)
        return this._error;
      const t2 = new ZodError(e4.common.issues);
      return this._error = t2, this._error;
    } };
  };
  cuidRegex = /^c[^\s-]{8,}$/i;
  cuid2Regex = /^[0-9a-z]+$/;
  ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  nanoidRegex = /^[a-z0-9_-]{21}$/i;
  durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
  ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
  dateRegex = new RegExp(`^${dateRegexSource}\$`);
  ZodString.create = (e4) => {
    var t;
    return new ZodString({ checks: [], typeName: ZodFirstPartyTypeKind.ZodString, coerce: (t = e4 == null ? undefined : e4.coerce) !== null && t !== undefined && t, ...processCreateParams(e4) });
  };
  ZodNumber.create = (e4) => new ZodNumber({ checks: [], typeName: ZodFirstPartyTypeKind.ZodNumber, coerce: (e4 == null ? undefined : e4.coerce) || false, ...processCreateParams(e4) });
  ZodBigInt.create = (e4) => {
    var t;
    return new ZodBigInt({ checks: [], typeName: ZodFirstPartyTypeKind.ZodBigInt, coerce: (t = e4 == null ? undefined : e4.coerce) !== null && t !== undefined && t, ...processCreateParams(e4) });
  };
  ZodBoolean.create = (e4) => new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean, coerce: (e4 == null ? undefined : e4.coerce) || false, ...processCreateParams(e4) });
  ZodDate.create = (e4) => new ZodDate({ checks: [], coerce: (e4 == null ? undefined : e4.coerce) || false, typeName: ZodFirstPartyTypeKind.ZodDate, ...processCreateParams(e4) });
  ZodSymbol.create = (e4) => new ZodSymbol({ typeName: ZodFirstPartyTypeKind.ZodSymbol, ...processCreateParams(e4) });
  ZodUndefined.create = (e4) => new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined, ...processCreateParams(e4) });
  ZodNull.create = (e4) => new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull, ...processCreateParams(e4) });
  ZodAny.create = (e4) => new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny, ...processCreateParams(e4) });
  ZodUnknown.create = (e4) => new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown, ...processCreateParams(e4) });
  ZodNever.create = (e4) => new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever, ...processCreateParams(e4) });
  ZodVoid.create = (e4) => new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid, ...processCreateParams(e4) });
  ZodArray.create = (e4, t) => new ZodArray({ type: e4, minLength: null, maxLength: null, exactLength: null, typeName: ZodFirstPartyTypeKind.ZodArray, ...processCreateParams(t) });
  ZodObject.create = (e4, t) => new ZodObject({ shape: () => e4, unknownKeys: "strip", catchall: ZodNever.create(), typeName: ZodFirstPartyTypeKind.ZodObject, ...processCreateParams(t) }), ZodObject.strictCreate = (e4, t) => new ZodObject({ shape: () => e4, unknownKeys: "strict", catchall: ZodNever.create(), typeName: ZodFirstPartyTypeKind.ZodObject, ...processCreateParams(t) }), ZodObject.lazycreate = (e4, t) => new ZodObject({ shape: e4, unknownKeys: "strip", catchall: ZodNever.create(), typeName: ZodFirstPartyTypeKind.ZodObject, ...processCreateParams(t) });
  ZodUnion.create = (e4, t) => new ZodUnion({ options: e4, typeName: ZodFirstPartyTypeKind.ZodUnion, ...processCreateParams(t) });
  getDiscriminator = (e4) => e4 instanceof ZodLazy ? getDiscriminator(e4.schema) : e4 instanceof ZodEffects ? getDiscriminator(e4.innerType()) : e4 instanceof ZodLiteral ? [e4.value] : e4 instanceof ZodEnum ? e4.options : e4 instanceof ZodNativeEnum ? util$1.objectValues(e4.enum) : e4 instanceof ZodDefault ? getDiscriminator(e4._def.innerType) : e4 instanceof ZodUndefined ? [undefined] : e4 instanceof ZodNull ? [null] : e4 instanceof ZodOptional ? [undefined, ...getDiscriminator(e4.unwrap())] : e4 instanceof ZodNullable ? [null, ...getDiscriminator(e4.unwrap())] : e4 instanceof ZodBranded || e4 instanceof ZodReadonly ? getDiscriminator(e4.unwrap()) : e4 instanceof ZodCatch ? getDiscriminator(e4._def.innerType) : [];
  ZodIntersection.create = (e4, t, i) => new ZodIntersection({ left: e4, right: t, typeName: ZodFirstPartyTypeKind.ZodIntersection, ...processCreateParams(i) });
  ZodTuple.create = (e4, t) => {
    if (!Array.isArray(e4))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new ZodTuple({ items: e4, typeName: ZodFirstPartyTypeKind.ZodTuple, rest: null, ...processCreateParams(t) });
  };
  ZodMap.create = (e4, t, i) => new ZodMap({ valueType: t, keyType: e4, typeName: ZodFirstPartyTypeKind.ZodMap, ...processCreateParams(i) });
  ZodSet.create = (e4, t) => new ZodSet({ valueType: e4, minSize: null, maxSize: null, typeName: ZodFirstPartyTypeKind.ZodSet, ...processCreateParams(t) });
  ZodLazy.create = (e4, t) => new ZodLazy({ getter: e4, typeName: ZodFirstPartyTypeKind.ZodLazy, ...processCreateParams(t) });
  ZodLiteral.create = (e4, t) => new ZodLiteral({ value: e4, typeName: ZodFirstPartyTypeKind.ZodLiteral, ...processCreateParams(t) });
  _ZodEnum_cache = new WeakMap, ZodEnum.create = createZodEnum;
  _ZodNativeEnum_cache = new WeakMap, ZodNativeEnum.create = (e4, t) => new ZodNativeEnum({ values: e4, typeName: ZodFirstPartyTypeKind.ZodNativeEnum, ...processCreateParams(t) });
  ZodPromise.create = (e4, t) => new ZodPromise({ type: e4, typeName: ZodFirstPartyTypeKind.ZodPromise, ...processCreateParams(t) });
  ZodEffects.create = (e4, t, i) => new ZodEffects({ schema: e4, typeName: ZodFirstPartyTypeKind.ZodEffects, effect: t, ...processCreateParams(i) }), ZodEffects.createWithPreprocess = (e4, t, i) => new ZodEffects({ schema: t, effect: { type: "preprocess", transform: e4 }, typeName: ZodFirstPartyTypeKind.ZodEffects, ...processCreateParams(i) });
  ZodOptional.create = (e4, t) => new ZodOptional({ innerType: e4, typeName: ZodFirstPartyTypeKind.ZodOptional, ...processCreateParams(t) });
  ZodNullable.create = (e4, t) => new ZodNullable({ innerType: e4, typeName: ZodFirstPartyTypeKind.ZodNullable, ...processCreateParams(t) });
  ZodDefault.create = (e4, t) => new ZodDefault({ innerType: e4, typeName: ZodFirstPartyTypeKind.ZodDefault, defaultValue: typeof t.default == "function" ? t.default : () => t.default, ...processCreateParams(t) });
  ZodCatch.create = (e4, t) => new ZodCatch({ innerType: e4, typeName: ZodFirstPartyTypeKind.ZodCatch, catchValue: typeof t.catch == "function" ? t.catch : () => t.catch, ...processCreateParams(t) });
  ZodNaN.create = (e4) => new ZodNaN({ typeName: ZodFirstPartyTypeKind.ZodNaN, ...processCreateParams(e4) });
  BRAND = Symbol("zod_brand");
  ZodReadonly.create = (e4, t) => new ZodReadonly({ innerType: e4, typeName: ZodFirstPartyTypeKind.ZodReadonly, ...processCreateParams(t) });
  late = { object: ZodObject.lazycreate };
  (function(e4) {
    e4.ZodString = "ZodString", e4.ZodNumber = "ZodNumber", e4.ZodNaN = "ZodNaN", e4.ZodBigInt = "ZodBigInt", e4.ZodBoolean = "ZodBoolean", e4.ZodDate = "ZodDate", e4.ZodSymbol = "ZodSymbol", e4.ZodUndefined = "ZodUndefined", e4.ZodNull = "ZodNull", e4.ZodAny = "ZodAny", e4.ZodUnknown = "ZodUnknown", e4.ZodNever = "ZodNever", e4.ZodVoid = "ZodVoid", e4.ZodArray = "ZodArray", e4.ZodObject = "ZodObject", e4.ZodUnion = "ZodUnion", e4.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e4.ZodIntersection = "ZodIntersection", e4.ZodTuple = "ZodTuple", e4.ZodRecord = "ZodRecord", e4.ZodMap = "ZodMap", e4.ZodSet = "ZodSet", e4.ZodFunction = "ZodFunction", e4.ZodLazy = "ZodLazy", e4.ZodLiteral = "ZodLiteral", e4.ZodEnum = "ZodEnum", e4.ZodEffects = "ZodEffects", e4.ZodNativeEnum = "ZodNativeEnum", e4.ZodOptional = "ZodOptional", e4.ZodNullable = "ZodNullable", e4.ZodDefault = "ZodDefault", e4.ZodCatch = "ZodCatch", e4.ZodPromise = "ZodPromise", e4.ZodBranded = "ZodBranded", e4.ZodPipeline = "ZodPipeline", e4.ZodReadonly = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  instanceOfType = (e4, t = { message: `Input not instance of ${e4.name}` }) => custom((t2) => t2 instanceof e4, t);
  stringType = ZodString.create;
  numberType = ZodNumber.create;
  nanType = ZodNaN.create;
  bigIntType = ZodBigInt.create;
  booleanType = ZodBoolean.create;
  dateType = ZodDate.create;
  symbolType = ZodSymbol.create;
  undefinedType = ZodUndefined.create;
  nullType = ZodNull.create;
  anyType = ZodAny.create;
  unknownType = ZodUnknown.create;
  neverType = ZodNever.create;
  voidType = ZodVoid.create;
  arrayType = ZodArray.create;
  objectType = ZodObject.create;
  strictObjectType = ZodObject.strictCreate;
  unionType = ZodUnion.create;
  discriminatedUnionType = ZodDiscriminatedUnion.create;
  intersectionType = ZodIntersection.create;
  tupleType = ZodTuple.create;
  recordType = ZodRecord.create;
  mapType = ZodMap.create;
  setType = ZodSet.create;
  functionType = ZodFunction.create;
  lazyType = ZodLazy.create;
  literalType = ZodLiteral.create;
  enumType = ZodEnum.create;
  nativeEnumType = ZodNativeEnum.create;
  promiseType = ZodPromise.create;
  effectsType = ZodEffects.create;
  optionalType = ZodOptional.create;
  nullableType = ZodNullable.create;
  preprocessType = ZodEffects.createWithPreprocess;
  pipelineType = ZodPipeline.create;
  ostring = () => stringType().optional();
  onumber = () => numberType().optional();
  oboolean = () => booleanType().optional();
  coerce = { string: (e4) => ZodString.create({ ...e4, coerce: true }), number: (e4) => ZodNumber.create({ ...e4, coerce: true }), boolean: (e4) => ZodBoolean.create({ ...e4, coerce: true }), bigint: (e4) => ZodBigInt.create({ ...e4, coerce: true }), date: (e4) => ZodDate.create({ ...e4, coerce: true }) };
  NEVER = INVALID;
  z = Object.freeze({ __proto__: null, defaultErrorMap: errorMap, setErrorMap, getErrorMap, makeIssue, EMPTY_PATH, addIssueToContext, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, get util() {
    return util$1;
  }, get objectUtil() {
    return objectUtil;
  }, ZodParsedType, getParsedType, ZodType, datetimeRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodTransformer: ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, custom, Schema: ZodType, ZodSchema: ZodType, late, get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  }, coerce, any: anyType, array: arrayType, bigint: bigIntType, boolean: booleanType, date: dateType, discriminatedUnion: discriminatedUnionType, effect: effectsType, enum: enumType, function: functionType, instanceof: instanceOfType, intersection: intersectionType, lazy: lazyType, literal: literalType, map: mapType, nan: nanType, nativeEnum: nativeEnumType, never: neverType, null: nullType, nullable: nullableType, number: numberType, object: objectType, oboolean, onumber, optional: optionalType, ostring, pipeline: pipelineType, preprocess: preprocessType, promise: promiseType, record: recordType, set: setType, strictObject: strictObjectType, string: stringType, symbol: symbolType, transformer: effectsType, tuple: tupleType, undefined: undefinedType, union: unionType, unknown: unknownType, void: voidType, NEVER, ZodIssueCode, quotelessJson, ZodError });
  Edge2 = Edge || (Edge = {}), Edge2[Edge2.EXTEND = 1] = "EXTEND", Edge2[Edge2.WRAP = 2] = "WRAP", Edge2[Edge2.CROP = 3] = "CROP";
  JimpClassSchema = z.object({ bitmap: z.object({ data: z.union([z.instanceof(Buffer2), z.instanceof(Uint8Array)]), width: z.number(), height: z.number() }) });
  BlitOptionsSchemaComplex = z.object({ src: JimpClassSchema, x: z.number().optional(), y: z.number().optional(), srcX: z.number().optional(), srcY: z.number().optional(), srcW: z.number().optional(), srcH: z.number().optional() });
  BlitOptionsSchema = z.union([JimpClassSchema, BlitOptionsSchemaComplex]);
  methods$h = { blit(e4, t) {
    const i = BlitOptionsSchema.parse(t);
    let { src: r, x: n = 0, y: a = 0, srcX: o = 0, srcY: s = 0, srcW: l = r.bitmap.width, srcH: u = r.bitmap.height } = "bitmap" in i ? { src: i } : i;
    if (!("bitmap" in r))
      throw new Error("The source must be a Jimp image");
    if (typeof n != "number" || typeof a != "number")
      throw new Error("x and y must be numbers");
    n = Math.round(n), a = Math.round(a), o = Math.round(o), s = Math.round(s), l = Math.round(l), u = Math.round(u);
    const h = e4.bitmap.width, c = e4.bitmap.height;
    return scan(r, o, s, l, u, function(t2, i2, l2) {
      const u2 = n + t2 - o, f = a + i2 - s;
      if (u2 >= 0 && f >= 0 && h - u2 > 0 && c - f > 0) {
        const t3 = e4.getPixelIndex(u2, f), i3 = { r: r.bitmap.data[l2] || 0, g: r.bitmap.data[l2 + 1] || 0, b: r.bitmap.data[l2 + 2] || 0, a: r.bitmap.data[l2 + 3] || 0 }, n2 = { r: e4.bitmap.data[t3] || 0, g: e4.bitmap.data[t3 + 1] || 0, b: e4.bitmap.data[t3 + 2] || 0, a: e4.bitmap.data[t3 + 3] || 0 };
        e4.bitmap.data[t3] = (i3.a * (i3.r - n2.r) - n2.r + 255 >> 8) + n2.r, e4.bitmap.data[t3 + 1] = (i3.a * (i3.g - n2.g) - n2.g + 255 >> 8) + n2.g, e4.bitmap.data[t3 + 2] = (i3.a * (i3.b - n2.b) - n2.b + 255 >> 8) + n2.b, e4.bitmap.data[t3 + 3] = limit255(n2.a + i3.a);
      }
    }), e4;
  } };
  mulTable = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];
  shgTable = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
  methods$g = { blur(e4, t) {
    if (typeof t != "number")
      throw new Error("r must be a number");
    if (t < 1)
      throw new Error("r must be greater than 0");
    let i, r, n, a, o, s, l, u, h, c, f, d, p;
    const m = e4.bitmap.width - 1, _ = e4.bitmap.height - 1, g = t + 1, b2 = mulTable[t], y = shgTable[t], w = [], v = [], x = [], E = [], k = [], S = [];
    let A = 2;
    for (;A-- > 0; ) {
      for (d = 0, p = 0, s = 0;s < e4.bitmap.height; s++) {
        for (i = e4.bitmap.data[p] * g, r = e4.bitmap.data[p + 1] * g, n = e4.bitmap.data[p + 2] * g, a = e4.bitmap.data[p + 3] * g, l = 1;l <= t; l++)
          u = p + ((l > m ? m : l) << 2), i += e4.bitmap.data[u++], r += e4.bitmap.data[u++], n += e4.bitmap.data[u++], a += e4.bitmap.data[u];
        for (o = 0;o < e4.bitmap.width; o++)
          w[d] = i, v[d] = r, x[d] = n, E[d] = a, s === 0 && (k[o] = ((u = o + g) < m ? u : m) << 2, S[o] = (u = o - t) > 0 ? u << 2 : 0), h = p + k[o], c = p + S[o], i += e4.bitmap.data[h++] - e4.bitmap.data[c++], r += e4.bitmap.data[h++] - e4.bitmap.data[c++], n += e4.bitmap.data[h++] - e4.bitmap.data[c++], a += e4.bitmap.data[h] - e4.bitmap.data[c++], d++;
        p += e4.bitmap.width << 2;
      }
      for (o = 0;o < e4.bitmap.width; o++) {
        for (f = o, i = w[f] * g, r = v[f] * g, n = x[f] * g, a = E[f] * g, l = 1;l <= t; l++)
          f += l > _ ? 0 : e4.bitmap.width, i += w[f], r += v[f], n += x[f], a += E[f];
        for (d = o << 2, s = 0;s < e4.bitmap.height; s++)
          e4.bitmap.data[d] = limit255(i * b2 >>> y), e4.bitmap.data[d + 1] = limit255(r * b2 >>> y), e4.bitmap.data[d + 2] = limit255(n * b2 >>> y), e4.bitmap.data[d + 3] = limit255(a * b2 >>> y), o === 0 && (k[s] = ((u = s + g) < _ ? u : _) * e4.bitmap.width, S[s] = (u = s - t) > 0 ? u * e4.bitmap.width : 0), h = o + k[s], c = o + S[s], i += w[h] - w[c], r += v[h] - v[c], n += x[h] - x[c], a += E[h] - E[c], d += e4.bitmap.width << 2;
      }
    }
    return e4;
  }, gaussian(e4, t) {
    if (typeof t != "number")
      throw new Error("r must be a number");
    if (t < 1)
      throw new Error("r must be greater than 0");
    const i = Math.ceil(2.57 * t), r = 2 * i + 1, n = t * t * 2, a = n * Math.PI, o = [];
    for (let e5 = 0;e5 < r; e5++) {
      const t2 = [];
      for (let o2 = 0;o2 < r; o2++) {
        const r2 = (o2 - i) ** 2 + (e5 - i) ** 2;
        t2[o2] = Math.exp(-r2 / n) / a;
      }
      o.push(t2);
    }
    for (let t2 = 0;t2 < e4.bitmap.height; t2++)
      for (let n2 = 0;n2 < e4.bitmap.width; n2++) {
        let a2 = 0, s = 0, l = 0, u = 0, h = 0;
        for (let c = 0;c < r; c++) {
          for (let f2 = 0;f2 < r; f2++) {
            const r2 = Math.min(e4.bitmap.width - 1, Math.max(0, f2 + n2 - i)), d = Math.min(e4.bitmap.height - 1, Math.max(0, c + t2 - i)), p = o[c][f2], m = d * e4.bitmap.width + r2 << 2;
            a2 += e4.bitmap.data[m] * p, s += e4.bitmap.data[m + 1] * p, l += e4.bitmap.data[m + 2] * p, u += e4.bitmap.data[m + 3] * p, h += p;
          }
          const f = t2 * e4.bitmap.width + n2 << 2;
          e4.bitmap.data[f] = Math.round(a2 / h), e4.bitmap.data[f + 1] = Math.round(s / h), e4.bitmap.data[f + 2] = Math.round(l / h), e4.bitmap.data[f + 3] = Math.round(u / h);
        }
      }
    return e4;
  } };
  CircleOptionsSchema = z.object({ x: z.number().optional(), y: z.number().optional(), radius: z.number().min(0).optional() });
  methods$f = { circle(e4, t = {}) {
    const i = CircleOptionsSchema.parse(t), r = i.radius || (e4.bitmap.width > e4.bitmap.height ? e4.bitmap.height : e4.bitmap.width) / 2, n = typeof i.x == "number" ? i.x : e4.bitmap.width / 2, a = typeof i.y == "number" ? i.y : e4.bitmap.height / 2;
    return e4.scan((t2, i2, o) => {
      const s = Math.sqrt(Math.pow(t2 - n, 2) + Math.pow(i2 - a, 2));
      r - s <= 0 ? e4.bitmap.data[o + 3] = 0 : r - s < 1 && (e4.bitmap.data[o + 3] = 255 * (r - s));
    }), e4;
  } };
  ConvolutionMatrixSchema = z.array(z.number()).min(1).array();
  ConvolutionComplexOptionsSchema = z.object({ kernel: ConvolutionMatrixSchema, edgeHandling: z.nativeEnum(Edge).optional() });
  ConvolutionOptionsSchema = z.union([ConvolutionMatrixSchema, ConvolutionComplexOptionsSchema]);
  ConvoluteComplexOptionsSchema = z.object({ kernel: ConvolutionMatrixSchema, x: z.number().optional(), y: z.number().optional(), w: z.number().optional(), h: z.number().optional() });
  ConvoluteOptionsSchema = z.union([ConvolutionMatrixSchema, ConvoluteComplexOptionsSchema]);
  PixelateSize = z.number().min(1).max(1 / 0);
  PixelateComplexOptionsSchema = z.object({ size: PixelateSize, x: z.number().optional(), y: z.number().optional(), w: z.number().optional(), h: z.number().optional() });
  PixelateOptionsSchema = z.union([PixelateSize, PixelateComplexOptionsSchema]);
  HueActionSchema = z.object({ apply: z.literal("hue"), params: z.tuple([z.number().min(-360).max(360)]) });
  SpinActionSchema = z.object({ apply: z.literal("spin"), params: z.tuple([z.number().min(-360).max(360)]) });
  LightenActionSchema = z.object({ apply: z.literal("lighten"), params: z.tuple([z.number().min(0).max(100)]).optional() });
  RGBColorSchema = z.object({ r: z.number().min(0).max(255), g: z.number().min(0).max(255), b: z.number().min(0).max(255) });
  MixActionSchema = z.object({ apply: z.literal("mix"), params: z.union([z.tuple([RGBColorSchema]), z.tuple([RGBColorSchema, z.number().min(0).max(100)])]) });
  TintActionSchema = z.object({ apply: z.literal("tint"), params: z.tuple([z.number().min(0).max(100)]).optional() });
  ShadeActionSchema = z.object({ apply: z.literal("shade"), params: z.tuple([z.number().min(0).max(100)]).optional() });
  XorActionSchema = z.object({ apply: z.literal("xor"), params: z.tuple([RGBColorSchema]) });
  RedActionSchema = z.object({ apply: z.literal("red"), params: z.tuple([z.number().min(-255).max(255)]) });
  GreenActionSchema = z.object({ apply: z.literal("green"), params: z.tuple([z.number().min(-255).max(255)]) });
  BlueActionSchema = z.object({ apply: z.literal("blue"), params: z.tuple([z.number().min(-255).max(255)]) });
  BrightenActionSchema = z.object({ apply: z.literal("brighten"), params: z.tuple([z.number().min(0).max(100)]).optional() });
  DarkenActionSchema = z.object({ apply: z.literal("darken"), params: z.tuple([z.number().min(0).max(100)]).optional() });
  DesaturateActionSchema = z.object({ apply: z.literal("desaturate"), params: z.tuple([z.number().min(0).max(100)]).optional() });
  SaturateActionSchema = z.object({ apply: z.literal("saturate"), params: z.tuple([z.number().min(0).max(100)]).optional() });
  GrayscaleActionSchema = z.object({ apply: z.literal("greyscale"), params: z.tuple([]).optional() });
  ColorActionNameSchema = z.union([HueActionSchema, SpinActionSchema, LightenActionSchema, MixActionSchema, TintActionSchema, ShadeActionSchema, XorActionSchema, RedActionSchema, GreenActionSchema, BlueActionSchema, BrightenActionSchema, DarkenActionSchema, DesaturateActionSchema, SaturateActionSchema, GrayscaleActionSchema]);
  normalizeValue = function(e4, t, i) {
    return 255 * (e4 - t) / (i - t);
  };
  getBounds = function(e4) {
    return [e4.findIndex((e5) => e5 > 0), 255 - e4.slice().reverse().findIndex((e5) => e5 > 0)];
  };
  methods$e = { normalize(e4) {
    const t = histogram(e4), i = { r: getBounds(t.r), g: getBounds(t.g), b: getBounds(t.b) };
    return e4.scan((t2, r, n) => {
      const a = e4.bitmap.data[n + 0], o = e4.bitmap.data[n + 1], s = e4.bitmap.data[n + 2];
      e4.bitmap.data[n + 0] = normalizeValue(a, i.r[0], i.r[1]), e4.bitmap.data[n + 1] = normalizeValue(o, i.g[0], i.g[1]), e4.bitmap.data[n + 2] = normalizeValue(s, i.b[0], i.b[1]);
    }), e4;
  }, invert: (e4) => (e4.scan((t, i, r) => {
    e4.bitmap.data[r] = 255 - e4.bitmap.data[r], e4.bitmap.data[r + 1] = 255 - e4.bitmap.data[r + 1], e4.bitmap.data[r + 2] = 255 - e4.bitmap.data[r + 2];
  }), e4), brightness(e4, t) {
    if (typeof t != "number")
      throw new Error("val must be numbers");
    return e4.scan((i, r, n) => {
      e4.bitmap.data[n] = limit255(e4.bitmap.data[n] * t), e4.bitmap.data[n + 1] = limit255(e4.bitmap.data[n + 1] * t), e4.bitmap.data[n + 2] = limit255(e4.bitmap.data[n + 2] * t);
    }), e4;
  }, contrast(e4, t) {
    if (typeof t != "number")
      throw new Error("val must be numbers");
    if (t < -1 || t > 1)
      throw new Error("val must be a number between -1 and +1");
    const i = (t + 1) / (1 - t);
    function r(e5) {
      return (e5 = Math.floor(i * (e5 - 127) + 127)) < 0 ? 0 : e5 > 255 ? 255 : e5;
    }
    return e4.scan((t2, i2, n) => {
      e4.bitmap.data[n] = r(e4.bitmap.data[n]), e4.bitmap.data[n + 1] = r(e4.bitmap.data[n + 1]), e4.bitmap.data[n + 2] = r(e4.bitmap.data[n + 2]);
    }), e4;
  }, posterize(e4, t) {
    if (typeof t != "number")
      throw new Error("n must be numbers");
    return t < 2 && (t = 2), e4.scan((i, r, n) => {
      const a = e4.bitmap.data[n], o = e4.bitmap.data[n + 1], s = e4.bitmap.data[n + 2];
      e4.bitmap.data[n] = Math.floor(a / 255 * (t - 1)) / (t - 1) * 255, e4.bitmap.data[n + 1] = Math.floor(o / 255 * (t - 1)) / (t - 1) * 255, e4.bitmap.data[n + 2] = Math.floor(s / 255 * (t - 1)) / (t - 1) * 255;
    }), e4;
  }, greyscale: (e4) => (e4.scan((t, i, r) => {
    const n = 0.2126 * e4.bitmap.data[r] + 0.7152 * e4.bitmap.data[r + 1] + 0.0722 * e4.bitmap.data[r + 2];
    e4.bitmap.data[r] = n, e4.bitmap.data[r + 1] = n, e4.bitmap.data[r + 2] = n;
  }), e4), opacity(e4, t) {
    if (typeof t != "number")
      throw new Error("f must be a number");
    if (t < 0 || t > 1)
      throw new Error("f must be a number from 0 to 1");
    return e4.scan((i, r, n) => {
      const a = e4.bitmap.data[n + 3] * t;
      e4.bitmap.data[n + 3] = a;
    }), e4;
  }, sepia: (e4) => (e4.scan((t, i, r) => {
    let n = e4.bitmap.data[r], a = e4.bitmap.data[r + 1], o = e4.bitmap.data[r + 2];
    n = 0.393 * n + 0.769 * a + 0.189 * o, a = 0.349 * n + 0.686 * a + 0.168 * o, o = 0.272 * n + 0.534 * a + 0.131 * o, e4.bitmap.data[r] = n < 255 ? n : 255, e4.bitmap.data[r + 1] = a < 255 ? a : 255, e4.bitmap.data[r + 2] = o < 255 ? o : 255;
  }), e4), fade(e4, t) {
    if (typeof t != "number")
      throw new Error("f must be a number");
    if (t < 0 || t > 1)
      throw new Error("f must be a number from 0 to 1");
    return this.opacity(e4, 1 - t);
  }, convolution(e4, t) {
    const i = ConvolutionOptionsSchema.parse(t), { kernel: r, edgeHandling: n = Edge.EXTEND } = "kernel" in i ? i : { kernel: i, edgeHandling: undefined };
    if (!r[0])
      throw new Error("kernel must be a matrix");
    const a = Buffer2.from(e4.bitmap.data), o = r.length, s = r[0].length, l = Math.floor(o / 2), u = Math.floor(s / 2), h = -l, c = -u;
    let f, d, p, m, _, g, b2, y, w, v;
    return e4.scan((t2, i2, o2) => {
      m = 0, p = 0, d = 0;
      for (let a2 = h;a2 <= l; a2++)
        for (let o3 = c;o3 <= u; o3++)
          y = t2 + o3, w = i2 + a2, f = r[a2 + l][o3 + u], v = e4.getPixelIndex(y, w, n), v === -1 ? (b2 = 0, g = 0, _ = 0) : (_ = e4.bitmap.data[v + 0], g = e4.bitmap.data[v + 1], b2 = e4.bitmap.data[v + 2]), d += f * _, p += f * g, m += f * b2;
      d < 0 && (d = 0), p < 0 && (p = 0), m < 0 && (m = 0), d > 255 && (d = 255), p > 255 && (p = 255), m > 255 && (m = 255), a[o2 + 0] = d, a[o2 + 1] = p, a[o2 + 2] = m;
    }), e4.bitmap.data = a, e4;
  }, opaque: (e4) => (e4.scan((t, i, r) => {
    e4.bitmap.data[r + 3] = 255;
  }), e4), pixelate(e4, t) {
    const i = PixelateOptionsSchema.parse(t), { size: r, x: n = 0, y: a = 0, w: o = e4.bitmap.width - n, h: s = e4.bitmap.height - a } = typeof i == "number" ? { size: i } : i, l = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 0.25, 2 / 16], [1 / 16, 2 / 16, 1 / 16]], u = clone(e4);
    return scan(u, n, a, o, s, (t2, i2, n2) => {
      t2 = r * Math.floor(t2 / r), i2 = r * Math.floor(i2 / r);
      const a2 = applyKernel(u, l, t2, i2);
      e4.bitmap.data[n2] = a2[0], e4.bitmap.data[n2 + 1] = a2[1], e4.bitmap.data[n2 + 2] = a2[2], e4.bitmap.data[n2 + 3] = a2[3];
    }), e4;
  }, convolute(e4, t) {
    const i = ConvoluteOptionsSchema.parse(t), { kernel: r, x: n = 0, y: a = 0, w: o = e4.bitmap.width - n, h: s = e4.bitmap.height - a } = "kernel" in i ? i : { kernel: i }, l = clone(e4);
    return scan(l, n, a, o, s, (t2, i2, n2) => {
      const a2 = applyKernel(l, r, t2, i2);
      e4.bitmap.data[n2] = limit255(a2[0]), e4.bitmap.data[n2 + 1] = limit255(a2[1]), e4.bitmap.data[n2 + 2] = limit255(a2[2]), e4.bitmap.data[n2 + 3] = limit255(a2[3]);
    }), e4;
  }, color(e4, t) {
    if (!t || !Array.isArray(t))
      throw new Error("actions must be an array");
    return t.forEach((e5) => ColorActionNameSchema.parse(e5)), t = t.map((e5) => (e5.apply !== "xor" && e5.apply !== "mix" || (e5.params[0] = tinycolor(e5.params[0]).toRgb()), e5)), e4.scan((i, r, n) => {
      let a = { r: e4.bitmap.data[n], g: e4.bitmap.data[n + 1], b: e4.bitmap.data[n + 2] };
      const o = (e5, t2) => limit255(a[e5] + t2);
      t.forEach((e5) => {
        if (e5.apply === "mix")
          a = mix(a, e5.params[0], e5.params[1]);
        else if (e5.apply === "tint")
          a = mix(a, { r: 255, g: 255, b: 255 }, e5.params?.[0]);
        else if (e5.apply === "shade")
          a = mix(a, { r: 0, g: 0, b: 0 }, e5.params?.[0]);
        else if (e5.apply === "xor")
          a = { r: a.r ^ e5.params[0].r, g: a.g ^ e5.params[0].g, b: a.b ^ e5.params[0].b };
        else if (e5.apply === "red")
          a.r = o("r", e5.params[0]);
        else if (e5.apply === "green")
          a.g = o("g", e5.params[0]);
        else if (e5.apply === "blue")
          a.b = o("b", e5.params[0]);
        else {
          e5.apply === "hue" && (e5.apply = "spin");
          const t2 = tinycolor(a), i2 = t2[e5.apply].bind(t2);
          if (!i2)
            throw new Error("action " + e5.apply + " not supported");
          a = i2(...e5.params || []).toRgb();
        }
      }), e4.bitmap.data[n] = a.r, e4.bitmap.data[n + 1] = a.g, e4.bitmap.data[n + 2] = a.b;
    }), e4;
  } };
  lib$1 = {};
  ieee754 = {
    read: function(e4, t, i, r, n) {
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var a, o, s = 8 * n - r - 1, l = (1 << s) - 1, u = l >> 1, h = -7, c = i ? n - 1 : 0, f = i ? -1 : 1, d = e4[t + c];
      for (c += f, a = d & (1 << -h) - 1, d >>= -h, h += s;h > 0; a = 256 * a + e4[t + c], c += f, h -= 8)
        ;
      for (o = a & (1 << -h) - 1, a >>= -h, h += r;h > 0; o = 256 * o + e4[t + c], c += f, h -= 8)
        ;
      if (a === 0)
        a = 1 - u;
      else {
        if (a === l)
          return o ? NaN : 1 / 0 * (d ? -1 : 1);
        o += Math.pow(2, r), a -= u;
      }
      return (d ? -1 : 1) * o * Math.pow(2, a - r);
    },
    write: function(e4, t, i, r, n, a) {
      var o, s, l, u = 8 * a - n - 1, h = (1 << u) - 1, c = h >> 1, f = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : a - 1, p = r ? 1 : -1, m = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, o = h) : (o = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), (t += o + c >= 1 ? f / l : f * Math.pow(2, 1 - c)) * l >= 2 && (o++, l /= 2), o + c >= h ? (s = 0, o = h) : o + c >= 1 ? (s = (t * l - 1) * Math.pow(2, n), o += c) : (s = t * Math.pow(2, c - 1) * Math.pow(2, n), o = 0));n >= 8; e4[i + d] = 255 & s, d += p, s /= 256, n -= 8)
        ;
      for (o = o << n | s, u += n;u > 0; e4[i + d] = 255 & o, d += p, o /= 256, u -= 8)
        ;
      e4[i + d - p] |= 128 * m;
    }
  };
  (function(e4) {
    Object.defineProperty(e4, "__esModule", { value: true }), e4.AnsiStringType = e4.StringType = e4.BufferType = e4.Uint8ArrayType = e4.IgnoreType = e4.Float80_LE = e4.Float80_BE = e4.Float64_LE = e4.Float64_BE = e4.Float32_LE = e4.Float32_BE = e4.Float16_LE = e4.Float16_BE = e4.INT64_BE = e4.UINT64_BE = e4.INT64_LE = e4.UINT64_LE = e4.INT32_LE = e4.INT32_BE = e4.INT24_BE = e4.INT24_LE = e4.INT16_LE = e4.INT16_BE = e4.INT8 = e4.UINT32_BE = e4.UINT32_LE = e4.UINT24_BE = e4.UINT24_LE = e4.UINT16_BE = e4.UINT16_LE = e4.UINT8 = undefined;
    const t = ieee754;
    function i(e5) {
      return new DataView(e5.buffer, e5.byteOffset);
    }
    e4.UINT8 = { len: 1, get: (e5, t2) => i(e5).getUint8(t2), put: (e5, t2, r2) => (i(e5).setUint8(t2, r2), t2 + 1) }, e4.UINT16_LE = { len: 2, get: (e5, t2) => i(e5).getUint16(t2, true), put: (e5, t2, r2) => (i(e5).setUint16(t2, r2, true), t2 + 2) }, e4.UINT16_BE = { len: 2, get: (e5, t2) => i(e5).getUint16(t2), put: (e5, t2, r2) => (i(e5).setUint16(t2, r2), t2 + 2) }, e4.UINT24_LE = { len: 3, get(e5, t2) {
      const r2 = i(e5);
      return r2.getUint8(t2) + (r2.getUint16(t2 + 1, true) << 8);
    }, put(e5, t2, r2) {
      const n = i(e5);
      return n.setUint8(t2, 255 & r2), n.setUint16(t2 + 1, r2 >> 8, true), t2 + 3;
    } }, e4.UINT24_BE = { len: 3, get(e5, t2) {
      const r2 = i(e5);
      return (r2.getUint16(t2) << 8) + r2.getUint8(t2 + 2);
    }, put(e5, t2, r2) {
      const n = i(e5);
      return n.setUint16(t2, r2 >> 8), n.setUint8(t2 + 2, 255 & r2), t2 + 3;
    } }, e4.UINT32_LE = { len: 4, get: (e5, t2) => i(e5).getUint32(t2, true), put: (e5, t2, r2) => (i(e5).setUint32(t2, r2, true), t2 + 4) }, e4.UINT32_BE = { len: 4, get: (e5, t2) => i(e5).getUint32(t2), put: (e5, t2, r2) => (i(e5).setUint32(t2, r2), t2 + 4) }, e4.INT8 = { len: 1, get: (e5, t2) => i(e5).getInt8(t2), put: (e5, t2, r2) => (i(e5).setInt8(t2, r2), t2 + 1) }, e4.INT16_BE = { len: 2, get: (e5, t2) => i(e5).getInt16(t2), put: (e5, t2, r2) => (i(e5).setInt16(t2, r2), t2 + 2) }, e4.INT16_LE = { len: 2, get: (e5, t2) => i(e5).getInt16(t2, true), put: (e5, t2, r2) => (i(e5).setInt16(t2, r2, true), t2 + 2) }, e4.INT24_LE = { len: 3, get(t2, i2) {
      const r2 = e4.UINT24_LE.get(t2, i2);
      return r2 > 8388607 ? r2 - 16777216 : r2;
    }, put(e5, t2, r2) {
      const n = i(e5);
      return n.setUint8(t2, 255 & r2), n.setUint16(t2 + 1, r2 >> 8, true), t2 + 3;
    } }, e4.INT24_BE = { len: 3, get(t2, i2) {
      const r2 = e4.UINT24_BE.get(t2, i2);
      return r2 > 8388607 ? r2 - 16777216 : r2;
    }, put(e5, t2, r2) {
      const n = i(e5);
      return n.setUint16(t2, r2 >> 8), n.setUint8(t2 + 2, 255 & r2), t2 + 3;
    } }, e4.INT32_BE = { len: 4, get: (e5, t2) => i(e5).getInt32(t2), put: (e5, t2, r2) => (i(e5).setInt32(t2, r2), t2 + 4) }, e4.INT32_LE = { len: 4, get: (e5, t2) => i(e5).getInt32(t2, true), put: (e5, t2, r2) => (i(e5).setInt32(t2, r2, true), t2 + 4) }, e4.UINT64_LE = { len: 8, get: (e5, t2) => i(e5).getBigUint64(t2, true), put: (e5, t2, r2) => (i(e5).setBigUint64(t2, r2, true), t2 + 8) }, e4.INT64_LE = { len: 8, get: (e5, t2) => i(e5).getBigInt64(t2, true), put: (e5, t2, r2) => (i(e5).setBigInt64(t2, r2, true), t2 + 8) }, e4.UINT64_BE = { len: 8, get: (e5, t2) => i(e5).getBigUint64(t2), put: (e5, t2, r2) => (i(e5).setBigUint64(t2, r2), t2 + 8) }, e4.INT64_BE = { len: 8, get: (e5, t2) => i(e5).getBigInt64(t2), put: (e5, t2, r2) => (i(e5).setBigInt64(t2, r2), t2 + 8) }, e4.Float16_BE = { len: 2, get(e5, i2) {
      return t.read(e5, i2, false, 10, this.len);
    }, put(e5, i2, r2) {
      return t.write(e5, r2, i2, false, 10, this.len), i2 + this.len;
    } }, e4.Float16_LE = { len: 2, get(e5, i2) {
      return t.read(e5, i2, true, 10, this.len);
    }, put(e5, i2, r2) {
      return t.write(e5, r2, i2, true, 10, this.len), i2 + this.len;
    } }, e4.Float32_BE = { len: 4, get: (e5, t2) => i(e5).getFloat32(t2), put: (e5, t2, r2) => (i(e5).setFloat32(t2, r2), t2 + 4) }, e4.Float32_LE = { len: 4, get: (e5, t2) => i(e5).getFloat32(t2, true), put: (e5, t2, r2) => (i(e5).setFloat32(t2, r2, true), t2 + 4) }, e4.Float64_BE = { len: 8, get: (e5, t2) => i(e5).getFloat64(t2), put: (e5, t2, r2) => (i(e5).setFloat64(t2, r2), t2 + 8) }, e4.Float64_LE = { len: 8, get: (e5, t2) => i(e5).getFloat64(t2, true), put: (e5, t2, r2) => (i(e5).setFloat64(t2, r2, true), t2 + 8) }, e4.Float80_BE = { len: 10, get(e5, i2) {
      return t.read(e5, i2, false, 63, this.len);
    }, put(e5, i2, r2) {
      return t.write(e5, r2, i2, false, 63, this.len), i2 + this.len;
    } }, e4.Float80_LE = { len: 10, get(e5, i2) {
      return t.read(e5, i2, true, 63, this.len);
    }, put(e5, i2, r2) {
      return t.write(e5, r2, i2, true, 63, this.len), i2 + this.len;
    } };
    e4.IgnoreType = class {
      constructor(e5) {
        this.len = e5;
      }
      get(e5, t2) {
      }
    };
    e4.Uint8ArrayType = class {
      constructor(e5) {
        this.len = e5;
      }
      get(e5, t2) {
        return e5.subarray(t2, t2 + this.len);
      }
    };
    e4.BufferType = class {
      constructor(e5) {
        this.len = e5;
      }
      get(e5, t2) {
        return Buffer2.from(e5.subarray(t2, t2 + this.len));
      }
    };
    e4.StringType = class {
      constructor(e5, t2) {
        this.len = e5, this.encoding = t2;
      }
      get(e5, t2) {
        return Buffer2.from(e5).toString(this.encoding, t2, t2 + this.len);
      }
    };

    class r {
      constructor(e5) {
        this.len = e5;
      }
      static decode(e5, t2, i2) {
        let n = "";
        for (let a = t2;a < i2; ++a)
          n += r.codePointToString(r.singleByteDecoder(e5[a]));
        return n;
      }
      static inRange(e5, t2, i2) {
        return t2 <= e5 && e5 <= i2;
      }
      static codePointToString(e5) {
        return e5 <= 65535 ? String.fromCharCode(e5) : (e5 -= 65536, String.fromCharCode(55296 + (e5 >> 10), 56320 + (1023 & e5)));
      }
      static singleByteDecoder(e5) {
        if (r.inRange(e5, 0, 127))
          return e5;
        const t2 = r.windows1252[e5 - 128];
        if (t2 === null)
          throw Error("invaliding encoding");
        return t2;
      }
      get(e5, t2 = 0) {
        return r.decode(e5, t2, t2 + this.len);
      }
    }
    e4.AnsiStringType = r, r.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
  })(lib$1);
  core$1 = {};
  ReadStreamTokenizer$1 = {};
  AbstractTokenizer$1 = {};
  lib = {};
  EndOfFileStream = {};
  (function(e4) {
    Object.defineProperty(e4, "__esModule", { value: true }), e4.EndOfStreamError = e4.defaultMessages = undefined, e4.defaultMessages = "End-Of-Stream";

    class t extends Error {
      constructor() {
        super(e4.defaultMessages);
      }
    }
    e4.EndOfStreamError = t;
  })(EndOfFileStream);
  StreamReader = {};
  Deferred$1 = {};
  Object.defineProperty(Deferred$1, "__esModule", { value: true }), Deferred$1.Deferred = undefined;
  Deferred$1.Deferred = Deferred, function(e4) {
    Object.defineProperty(e4, "__esModule", { value: true }), e4.StreamReader = e4.EndOfStreamError = undefined;
    const t = EndOfFileStream, i = Deferred$1;
    var r = EndOfFileStream;
    Object.defineProperty(e4, "EndOfStreamError", { enumerable: true, get: function() {
      return r.EndOfStreamError;
    } });
    e4.StreamReader = class {
      constructor(e5) {
        if (this.s = e5, this.deferred = null, this.endOfStream = false, this.peekQueue = [], !e5.read || !e5.once)
          throw new Error("Expected an instance of stream.Readable");
        this.s.once("end", () => this.reject(new t.EndOfStreamError)), this.s.once("error", (e6) => this.reject(e6)), this.s.once("close", () => this.reject(new Error("Stream closed")));
      }
      async peek(e5, t2, i2) {
        const r2 = await this.read(e5, t2, i2);
        return this.peekQueue.push(e5.subarray(t2, t2 + r2)), r2;
      }
      async read(e5, i2, r2) {
        if (r2 === 0)
          return 0;
        if (this.peekQueue.length === 0 && this.endOfStream)
          throw new t.EndOfStreamError;
        let n = r2, a = 0;
        for (;this.peekQueue.length > 0 && n > 0; ) {
          const t2 = this.peekQueue.pop();
          if (!t2)
            throw new Error("peekData should be defined");
          const r3 = Math.min(t2.length, n);
          e5.set(t2.subarray(0, r3), i2 + a), a += r3, n -= r3, r3 < t2.length && this.peekQueue.push(t2.subarray(r3));
        }
        for (;n > 0 && !this.endOfStream; ) {
          const t2 = Math.min(n, 1048576), r3 = await this.readFromStream(e5, i2 + a, t2);
          if (a += r3, r3 < t2)
            break;
          n -= r3;
        }
        return a;
      }
      async readFromStream(e5, t2, r2) {
        const n = this.s.read(r2);
        if (n)
          return e5.set(n, t2), n.length;
        {
          const n2 = { buffer: e5, offset: t2, length: r2, deferred: new i.Deferred };
          return this.deferred = n2.deferred, this.s.once("readable", () => {
            this.readDeferred(n2);
          }), n2.deferred.promise;
        }
      }
      readDeferred(e5) {
        const t2 = this.s.read(e5.length);
        t2 ? (e5.buffer.set(t2, e5.offset), e5.deferred.resolve(t2.length), this.deferred = null) : this.s.once("readable", () => {
          this.readDeferred(e5);
        });
      }
      reject(e5) {
        this.endOfStream = true, this.deferred && (this.deferred.reject(e5), this.deferred = null);
      }
    };
  }(StreamReader), function(e4) {
    Object.defineProperty(e4, "__esModule", { value: true }), e4.StreamReader = e4.EndOfStreamError = undefined;
    var t = EndOfFileStream;
    Object.defineProperty(e4, "EndOfStreamError", { enumerable: true, get: function() {
      return t.EndOfStreamError;
    } });
    var i = StreamReader;
    Object.defineProperty(e4, "StreamReader", { enumerable: true, get: function() {
      return i.StreamReader;
    } });
  }(lib), Object.defineProperty(AbstractTokenizer$1, "__esModule", { value: true }), AbstractTokenizer$1.AbstractTokenizer = undefined;
  peek_readable_1$2 = lib;
  AbstractTokenizer$1.AbstractTokenizer = AbstractTokenizer, Object.defineProperty(ReadStreamTokenizer$1, "__esModule", { value: true }), ReadStreamTokenizer$1.ReadStreamTokenizer = undefined;
  AbstractTokenizer_1$1 = AbstractTokenizer$1;
  peek_readable_1$1 = lib;
  maxBufferSize = 256000;
  ReadStreamTokenizer$1.ReadStreamTokenizer = ReadStreamTokenizer;
  BufferTokenizer$1 = {};
  Object.defineProperty(BufferTokenizer$1, "__esModule", { value: true }), BufferTokenizer$1.BufferTokenizer = undefined;
  peek_readable_1 = lib;
  AbstractTokenizer_1 = AbstractTokenizer$1;
  BufferTokenizer$1.BufferTokenizer = BufferTokenizer, function(e4) {
    Object.defineProperty(e4, "__esModule", { value: true }), e4.fromBuffer = e4.fromStream = e4.EndOfStreamError = undefined;
    const t = ReadStreamTokenizer$1, i = BufferTokenizer$1;
    var r = lib;
    Object.defineProperty(e4, "EndOfStreamError", { enumerable: true, get: function() {
      return r.EndOfStreamError;
    } }), e4.fromStream = function(e5, i2) {
      return i2 = i2 || {}, new t.ReadStreamTokenizer(e5, i2);
    }, e4.fromBuffer = function(e5, t2) {
      return new i.BufferTokenizer(e5, t2);
    };
  }(core$1);
  util = { stringToBytes: (e4) => [...e4].map((e5) => e5.charCodeAt(0)), tarHeaderChecksumMatches: (e4, t = 0) => {
    const i = parseInt(e4.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
    if (isNaN(i))
      return false;
    let r = 256;
    for (let i2 = t;i2 < t + 148; i2++)
      r += e4[i2];
    for (let i2 = t + 156;i2 < t + 512; i2++)
      r += e4[i2];
    return i === r;
  }, uint32SyncSafeToken: { get: (e4, t) => 127 & e4[t + 3] | e4[t + 2] << 7 | e4[t + 1] << 14 | e4[t] << 21, len: 4 } };
  supported$1 = { extensions: ["jpg", "png", "apng", "gif", "webp", "flif", "xcf", "cr2", "cr3", "orf", "arw", "dng", "nef", "rw2", "raf", "tif", "bmp", "icns", "jxr", "psd", "indd", "zip", "tar", "rar", "gz", "bz2", "7z", "dmg", "mp4", "mid", "mkv", "webm", "mov", "avi", "mpg", "mp2", "mp3", "m4a", "oga", "ogg", "ogv", "opus", "flac", "wav", "spx", "amr", "pdf", "epub", "exe", "swf", "rtf", "wasm", "woff", "woff2", "eot", "ttf", "otf", "ico", "flv", "ps", "xz", "sqlite", "nes", "crx", "xpi", "cab", "deb", "ar", "rpm", "Z", "lz", "cfb", "mxf", "mts", "blend", "bpg", "docx", "pptx", "xlsx", "3gp", "3g2", "jp2", "jpm", "jpx", "mj2", "aif", "qcp", "odt", "ods", "odp", "xml", "mobi", "heic", "cur", "ktx", "ape", "wv", "dcm", "ics", "glb", "pcap", "dsf", "lnk", "alias", "voc", "ac3", "m4v", "m4p", "m4b", "f4v", "f4p", "f4b", "f4a", "mie", "asf", "ogm", "ogx", "mpc", "arrow", "shp", "aac", "mp1", "it", "s3m", "xm", "ai", "skp", "avif", "eps", "lzh", "pgp", "asar", "stl", "chm", "3mf", "zst", "jxl", "vcf"], mimeTypes: ["image/jpeg", "image/png", "image/gif", "image/webp", "image/flif", "image/x-xcf", "image/x-canon-cr2", "image/x-canon-cr3", "image/tiff", "image/bmp", "image/vnd.ms-photo", "image/vnd.adobe.photoshop", "application/x-indesign", "application/epub+zip", "application/x-xpinstall", "application/vnd.oasis.opendocument.text", "application/vnd.oasis.opendocument.spreadsheet", "application/vnd.oasis.opendocument.presentation", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/zip", "application/x-tar", "application/x-rar-compressed", "application/gzip", "application/x-bzip2", "application/x-7z-compressed", "application/x-apple-diskimage", "application/x-apache-arrow", "video/mp4", "audio/midi", "video/x-matroska", "video/webm", "video/quicktime", "video/vnd.avi", "audio/vnd.wave", "audio/qcelp", "audio/x-ms-asf", "video/x-ms-asf", "application/vnd.ms-asf", "video/mpeg", "video/3gpp", "audio/mpeg", "audio/mp4", "audio/opus", "video/ogg", "audio/ogg", "application/ogg", "audio/x-flac", "audio/ape", "audio/wavpack", "audio/amr", "application/pdf", "application/x-msdownload", "application/x-shockwave-flash", "application/rtf", "application/wasm", "font/woff", "font/woff2", "application/vnd.ms-fontobject", "font/ttf", "font/otf", "image/x-icon", "video/x-flv", "application/postscript", "application/eps", "application/x-xz", "application/x-sqlite3", "application/x-nintendo-nes-rom", "application/x-google-chrome-extension", "application/vnd.ms-cab-compressed", "application/x-deb", "application/x-unix-archive", "application/x-rpm", "application/x-compress", "application/x-lzip", "application/x-cfb", "application/x-mie", "application/mxf", "video/mp2t", "application/x-blender", "image/bpg", "image/jp2", "image/jpx", "image/jpm", "image/mj2", "audio/aiff", "application/xml", "application/x-mobipocket-ebook", "image/heif", "image/heif-sequence", "image/heic", "image/heic-sequence", "image/icns", "image/ktx", "application/dicom", "audio/x-musepack", "text/calendar", "text/vcard", "model/gltf-binary", "application/vnd.tcpdump.pcap", "audio/x-dsf", "application/x.ms.shortcut", "application/x.apple.alias", "audio/x-voc", "audio/vnd.dolby.dd-raw", "audio/x-m4a", "image/apng", "image/x-olympus-orf", "image/x-sony-arw", "image/x-adobe-dng", "image/x-nikon-nef", "image/x-panasonic-rw2", "image/x-fujifilm-raf", "video/x-m4v", "video/3gpp2", "application/x-esri-shape", "audio/aac", "audio/x-it", "audio/x-s3m", "audio/x-xm", "video/MP1S", "video/MP2P", "application/vnd.sketchup.skp", "image/avif", "application/x-lzh-compressed", "application/pgp-encrypted", "application/x-asar", "model/stl", "application/vnd.ms-htmlhelp", "model/3mf", "image/jxl", "application/zstd"] };
  Token = lib$1;
  strtok3 = core$1;
  ({ stringToBytes, tarHeaderChecksumMatches, uint32SyncSafeToken } = util);
  supported = supported$1;
  minimumBytes = 4100;
  stream2 = (readableStream) => new Promise((resolve, reject) => {
    const stream = eval("require")("stream");
    readableStream.on("error", reject), readableStream.once("readable", async () => {
      const e4 = new stream.PassThrough;
      let t;
      t = stream.pipeline ? stream.pipeline(readableStream, e4, () => {
      }) : readableStream.pipe(e4);
      const i = readableStream.read(minimumBytes) || readableStream.read() || Buffer2.alloc(0);
      try {
        const t2 = await fromBuffer(i);
        e4.fileType = t2;
      } catch (e5) {
        reject(e5);
      }
      resolve(t);
    });
  });
  fileType = { fromStream, fromTokenizer, fromBuffer, stream: stream2 };
  Object.defineProperty(fileType, "extensions", { get: () => new Set(supported.extensions) }), Object.defineProperty(fileType, "mimeTypes", { get: () => new Set(supported.mimeTypes) });
  core = fileType;
  fileType$1 = getDefaultExportFromCjs(core);
  writeFile = async () => {
    throw new Error("Not supported");
  };
  Mime$1.prototype.define = function(e4, t) {
    for (let i in e4) {
      let r = e4[i].map(function(e5) {
        return e5.toLowerCase();
      });
      i = i.toLowerCase();
      for (let e5 = 0;e5 < r.length; e5++) {
        const n = r[e5];
        if (n[0] !== "*") {
          if (!t && n in this._types)
            throw new Error('Attempt to change mapping for "' + n + '" extension from "' + this._types[n] + '" to "' + i + '". Pass `force=true` to allow this, otherwise remove "' + n + '" from the list of extensions for "' + i + '".');
          this._types[n] = i;
        }
      }
      if (t || !this._extensions[i]) {
        const e5 = r[0];
        this._extensions[i] = e5[0] !== "*" ? e5 : e5.substr(1);
      }
    }
  }, Mime$1.prototype.getType = function(e4) {
    let t = (e4 = String(e4)).replace(/^.*[/\\]/, "").toLowerCase(), i = t.replace(/^.*\./, "").toLowerCase(), r = t.length < e4.length;
    return (i.length < t.length - 1 || !r) && this._types[i] || null;
  }, Mime$1.prototype.getExtension = function(e4) {
    return (e4 = /^\s*([^;\s]*)/.test(e4) && RegExp.$1) && this._extensions[e4.toLowerCase()] || null;
  };
  Mime_1 = Mime$1;
  standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  Mime = Mime_1;
  lite = new Mime(standard);
  mime = getDefaultExportFromCjs(lite);
  HorizontalAlign2 = HorizontalAlign || (HorizontalAlign = {}), HorizontalAlign2[HorizontalAlign2.LEFT = 1] = "LEFT", HorizontalAlign2[HorizontalAlign2.CENTER = 2] = "CENTER", HorizontalAlign2[HorizontalAlign2.RIGHT = 4] = "RIGHT", VerticalAlign2 = VerticalAlign || (VerticalAlign = {}), VerticalAlign2[VerticalAlign2.TOP = 8] = "TOP", VerticalAlign2[VerticalAlign2.MIDDLE = 16] = "MIDDLE", VerticalAlign2[VerticalAlign2.BOTTOM = 32] = "BOTTOM", BlendMode2 = BlendMode || (BlendMode = {}), BlendMode2.SRC_OVER = "srcOver", BlendMode2.DST_OVER = "dstOver", BlendMode2.MULTIPLY = "multiply", BlendMode2.ADD = "add", BlendMode2.SCREEN = "screen", BlendMode2.OVERLAY = "overlay", BlendMode2.DARKEN = "darken", BlendMode2.LIGHTEN = "lighten", BlendMode2.HARD_LIGHT = "hardLight", BlendMode2.DIFFERENCE = "difference", BlendMode2.EXCLUSION = "exclusion";
  names = [srcOver, dstOver, multiply, add, screen, overlay, darken, lighten, hardLight, difference, exclusion];
  compositeModes = Object.freeze({ __proto__: null, add, darken, difference, dstOver, exclusion, hardLight, lighten, multiply, names, overlay, screen, srcOver });
  jpeg$1 = { parseSections: function(e4, t) {
    var i, r;
    for (e4.setBigEndian(true);e4.remainingLength() > 0 && r !== 218; ) {
      if (e4.nextUInt8() !== 255)
        throw new Error("Invalid JPEG section offset");
      i = (r = e4.nextUInt8()) >= 208 && r <= 217 || r === 218 ? 0 : e4.nextUInt16() - 2, t(r, e4.branch(0, i)), e4.skip(i);
    }
  }, getSizeFromSOFSection: function(e4) {
    return e4.skip(1), { height: e4.nextUInt16(), width: e4.nextUInt16() };
  }, getSectionName: function(e4) {
    var t, i;
    switch (e4) {
      case 216:
        t = "SOI";
        break;
      case 196:
        t = "DHT";
        break;
      case 219:
        t = "DQT";
        break;
      case 221:
        t = "DRI";
        break;
      case 218:
        t = "SOS";
        break;
      case 254:
        t = "COM";
        break;
      case 217:
        t = "EOI";
        break;
      default:
        e4 >= 224 && e4 <= 239 ? (t = "APP", i = e4 - 224) : e4 >= 192 && e4 <= 207 && e4 !== 196 && e4 !== 200 && e4 !== 204 ? (t = "SOF", i = e4 - 192) : e4 >= 208 && e4 <= 215 && (t = "RST", i = e4 - 208);
    }
    var r = { name: t };
    return typeof i == "number" && (r.index = i), r;
  } };
  exif$2 = { IFD0: 1, IFD1: 2, GPSIFD: 3, SubIFD: 4, InteropIFD: 5, parseTags: function(e4, t) {
    var i, r, n, a;
    try {
      i = readHeader(e4);
    } catch (e5) {
      return false;
    }
    var o = i.openWithOffset(e4.nextUInt32()), s = this.IFD0;
    readIFDSection(i, o, function(e5, i2, a2) {
      switch (e5) {
        case 34853:
          n = i2[0];
          break;
        case 34665:
          r = i2[0];
          break;
        default:
          t(s, e5, i2, a2);
      }
    });
    var l = o.nextUInt32();
    if (l !== 0) {
      var u = i.openWithOffset(l);
      readIFDSection(i, u, t.bind(null, this.IFD1));
    }
    if (n) {
      var h = i.openWithOffset(n);
      readIFDSection(i, h, t.bind(null, this.GPSIFD));
    }
    if (r) {
      var c = i.openWithOffset(r), f = this.InteropIFD;
      readIFDSection(i, c, function(e5, i2, r2) {
        e5 === 40965 ? a = i2[0] : t(f, e5, i2, r2);
      });
    }
    if (a) {
      var d = i.openWithOffset(a);
      readIFDSection(i, d, t.bind(null, this.InteropIFD));
    }
    return true;
  } };
  hours = 3600;
  minutes = 60;
  date$1 = { parseDateWithSpecFormat, parseDateWithTimezoneFormat, parseExifDate };
  exif$1 = exif$2;
  date = date$1;
  degreeTags = [{ section: exif$1.GPSIFD, type: 2, name: "GPSLatitude", refType: 1, refName: "GPSLatitudeRef", posVal: "N" }, { section: exif$1.GPSIFD, type: 4, name: "GPSLongitude", refType: 3, refName: "GPSLongitudeRef", posVal: "E" }];
  dateTags = [{ section: exif$1.SubIFD, type: 306, name: "ModifyDate" }, { section: exif$1.SubIFD, type: 36867, name: "DateTimeOriginal" }, { section: exif$1.SubIFD, type: 36868, name: "CreateDate" }, { section: exif$1.SubIFD, type: 306, name: "ModifyDate" }];
  simplify$1 = { castDegreeValues: function(e4, t) {
    degreeTags.forEach(function(i) {
      var r = e4(i);
      if (r) {
        var n = e4({ section: i.section, type: i.refType, name: i.refName }) === i.posVal ? 1 : -1, a = (r[0] + r[1] / 60 + r[2] / 3600) * n;
        t(i, a);
      }
    });
  }, castDateValues: function(e4, t) {
    dateTags.forEach(function(i) {
      var r = e4(i);
      if (r) {
        var n = date.parseExifDate(r);
        n !== undefined && t(i, n);
      }
    });
  }, simplifyValue: function(e4, t) {
    return Array.isArray(e4) && (e4 = e4.map(function(e5) {
      return t === 10 || t === 5 ? e5[0] / e5[1] : e5;
    })).length === 1 && (e4 = e4[0]), e4;
  } };
  jpeg = jpeg$1;
  exif = exif$2;
  simplify = simplify$1;
  ExifResult.prototype = { hasThumbnail: function(e4) {
    return !(!this.thumbnailOffset || !this.thumbnailLength) && (typeof e4 != "string" || (e4.toLowerCase().trim() === "image/jpeg" ? this.thumbnailType === 6 : e4.toLowerCase().trim() === "image/tiff" && this.thumbnailType === 1));
  }, getThumbnailOffset: function() {
    return this.app1Offset + 6 + this.thumbnailOffset;
  }, getThumbnailLength: function() {
    return this.thumbnailLength;
  }, getThumbnailBuffer: function() {
    return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
  }, _getThumbnailStream: function() {
    return this.startMarker.openWithOffset(this.getThumbnailOffset());
  }, getImageSize: function() {
    return this.imageSize;
  }, getThumbnailSize: function() {
    var e4, t = this._getThumbnailStream();
    return jpeg.parseSections(t, function(t2, i) {
      jpeg.getSectionName(t2).name === "SOF" && (e4 = jpeg.getSizeFromSOFSection(i));
    }), e4;
  } }, Parser$1.prototype = { enableBinaryFields: function(e4) {
    return this.flags.readBinaryTags = !!e4, this;
  }, enablePointers: function(e4) {
    return this.flags.hidePointers = !e4, this;
  }, enableTagNames: function(e4) {
    return this.flags.resolveTagNames = !!e4, this;
  }, enableImageSize: function(e4) {
    return this.flags.imageSize = !!e4, this;
  }, enableReturnTags: function(e4) {
    return this.flags.returnTags = !!e4, this;
  }, enableSimpleValues: function(e4) {
    return this.flags.simplifyValues = !!e4, this;
  }, parse: function() {
    var e4, t, i, r, n, a, o, s, l, u = this.stream.mark(), h = u.openWithOffset(0), c = this.flags;
    return c.resolveTagNames && (o = requireExifTags()), c.resolveTagNames ? (e4 = {}, s = function(t2) {
      return e4[t2.name];
    }, l = function(t2, i2) {
      e4[t2.name] = i2;
    }) : (e4 = [], s = function(t2) {
      var i2;
      for (i2 = 0;i2 < e4.length; ++i2)
        if (e4[i2].type === t2.type && e4[i2].section === t2.section)
          return e4.value;
    }, l = function(t2, i2) {
      var r2;
      for (r2 = 0;r2 < e4.length; ++r2)
        if (e4[r2].type === t2.type && e4[r2].section === t2.section)
          return void (e4.value = i2);
    }), jpeg.parseSections(h, function(s2, l2) {
      var h2 = l2.offsetFrom(u);
      s2 === 225 ? exif.parseTags(l2, function(t2, a2, s3, l3) {
        if (c.readBinaryTags || l3 !== 7) {
          if (a2 === 513) {
            if (i = s3[0], c.hidePointers)
              return;
          } else if (a2 === 514) {
            if (r = s3[0], c.hidePointers)
              return;
          } else if (a2 === 259 && (n = s3[0], c.hidePointers))
            return;
          if (c.returnTags)
            if (c.simplifyValues && (s3 = simplify.simplifyValue(s3, l3)), c.resolveTagNames) {
              var u2 = (t2 === exif.GPSIFD ? o.gps : o.exif)[a2];
              u2 || (u2 = o.exif[a2]), e4.hasOwnProperty(u2) || (e4[u2] = s3);
            } else
              e4.push({ section: t2, type: a2, value: s3 });
        }
      }) && (a = h2) : c.imageSize && jpeg.getSectionName(s2).name === "SOF" && (t = jpeg.getSizeFromSOFSection(l2));
    }), c.simplifyValues && (simplify.castDegreeValues(s, l), simplify.castDateValues(s, l)), new ExifResult(u, e4, t, i, r, n, a);
  } };
  parser = Parser$1;
  Parser = parser;
  exifParser = { create: function(e4, t) {
    if (e4 instanceof (t = t || getGlobal()).ArrayBuffer) {
      var i = requireDomBufferstream();
      return new Parser(new i(e4, 0, e4.byteLength, true, t));
    }
    var r = requireBufferstream();
    return new Parser(new r(e4, 0, e4.length, true));
  } };
  EXIFParser = getDefaultExportFromCjs(exifParser);
  __defProp$2 = Object.defineProperty;
  __defNormalProp$2 = (e4, t, i) => (t in e4) ? __defProp$2(e4, t, { enumerable: true, configurable: true, writable: true, value: i }) : e4[t] = i;
  __publicField$2 = (e4, t, i) => __defNormalProp$2(e4, typeof t != "symbol" ? t + "" : t, i);
  emptyBitmap = { data: Buffer2.alloc(0), width: 0, height: 0 };
  ResizeStrategy2 = ResizeStrategy || (ResizeStrategy = {}), ResizeStrategy2.NEAREST_NEIGHBOR = "nearestNeighbor", ResizeStrategy2.BILINEAR = "bilinearInterpolation", ResizeStrategy2.BICUBIC = "bicubicInterpolation", ResizeStrategy2.HERMITE = "hermiteInterpolation", ResizeStrategy2.BEZIER = "bezierInterpolation", Resize.prototype.initialize = function() {
    if (!(this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0))
      throw console.log(this), new Error("Invalid settings specified for the resizer.");
    this.configurePasses();
  }, Resize.prototype.configurePasses = function() {
    this.widthOriginal === this.targetWidth ? this.resizeWidth = this.bypassResizer : (this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth, this.ratioWeightWidthPass < 1 && this.interpolationPass ? (this.initializeFirstPassBuffers(true), this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB) : (this.initializeFirstPassBuffers(false), this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB)), this.heightOriginal === this.targetHeight ? this.resizeHeight = this.bypassResizer : (this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight, this.ratioWeightHeightPass < 1 && this.interpolationPass ? (this.initializeSecondPassBuffers(true), this.resizeHeight = this.resizeHeightInterpolated) : (this.initializeSecondPassBuffers(false), this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB));
  }, Resize.prototype._resizeWidthInterpolatedRGBChannels = function(e4, t) {
    const i = t ? 4 : 3, r = this.ratioWeightWidthPass, n = this.widthBuffer;
    let a, o, s = 0, l = 0, u = 0, h = 0, c = 0;
    for (a = 0;s < 1 / 3; a += i, s += r)
      for (l = a, u = 0;l < this.widthPassResultSize; u += this.originalWidthMultipliedByChannels, l += this.targetWidthMultipliedByChannels)
        n[l] = e4[u], n[l + 1] = e4[u + 1], n[l + 2] = e4[u + 2], t && (n[l + 3] = e4[u + 3]);
    for (s -= 1 / 3, o = this.widthOriginal - 1;s < o; a += i, s += r)
      for (c = s % 1, h = 1 - c, l = a, u = Math.floor(s) * i;l < this.widthPassResultSize; u += this.originalWidthMultipliedByChannels, l += this.targetWidthMultipliedByChannels)
        n[l + 0] = e4[u + 0] * h + e4[u + i + 0] * c, n[l + 1] = e4[u + 1] * h + e4[u + i + 1] * c, n[l + 2] = e4[u + 2] * h + e4[u + i + 2] * c, t && (n[l + 3] = e4[u + 3] * h + e4[u + i + 3] * c);
    for (o = this.originalWidthMultipliedByChannels - i;a < this.targetWidthMultipliedByChannels; a += i)
      for (l = a, u = o;l < this.widthPassResultSize; u += this.originalWidthMultipliedByChannels, l += this.targetWidthMultipliedByChannels)
        n[l] = e4[u], n[l + 1] = e4[u + 1], n[l + 2] = e4[u + 2], t && (n[l + 3] = e4[u + 3]);
    return n;
  }, Resize.prototype._resizeWidthRGBChannels = function(e4, t) {
    const i = t ? 4 : 3, r = this.ratioWeightWidthPass, n = 1 / r, a = this.originalWidthMultipliedByChannels - i + 1, o = this.targetWidthMultipliedByChannels - i + 1, s = this.outputWidthWorkBench, l = this.widthBuffer, u = this.outputWidthWorkBenchOpaquePixelsCount;
    let h = 0, c = 0, f = 0, d = 0, p = 0, m = 0, _ = 0, g = 1, b2 = 0, y = 0, w = 0, v = 0;
    do {
      for (p = 0;p < this.originalHeightMultipliedByChannels; )
        s[p++] = 0, s[p++] = 0, s[p++] = 0, t && (s[p++] = 0, u[p / i - 1] = 0);
      h = r;
      do {
        for (c = 1 + f - d, g = Math.min(h, c), p = 0, m = f;p < this.originalHeightMultipliedByChannels; m += a)
          b2 = e4[m], y = e4[++m], w = e4[++m], v = t ? e4[++m] : 255, s[p++] += (v ? b2 : 0) * g, s[p++] += (v ? y : 0) * g, s[p++] += (v ? w : 0) * g, t && (s[p++] += v * g, u[p / i - 1] += v ? g : 0);
        if (!(h >= c)) {
          d += h;
          break;
        }
        f += i, d = f, h -= c;
      } while (h > 0 && f < this.originalWidthMultipliedByChannels);
      for (p = 0, m = _;p < this.originalHeightMultipliedByChannels; m += o)
        h = t ? u[p / i] : 1, g = t ? h ? 1 / h : 0 : n, l[m] = s[p++] * g, l[++m] = s[p++] * g, l[++m] = s[p++] * g, t && (l[++m] = s[p++] * n);
      _ += i;
    } while (_ < this.targetWidthMultipliedByChannels);
    return l;
  }, Resize.prototype._resizeHeightRGBChannels = function(e4, t) {
    const i = this.ratioWeightHeightPass, r = 1 / i, n = this.outputHeightWorkBench, a = this.heightBuffer, o = this.outputHeightWorkBenchOpaquePixelsCount;
    let s = 0, l = 0, u = 0, h = 0, c = 0, f = 0, d = 0, p = 1, m = 0, _ = 0, g = 0, b2 = 0;
    do {
      for (c = 0;c < this.targetWidthMultipliedByChannels; )
        n[c++] = 0, n[c++] = 0, n[c++] = 0, t && (n[c++] = 0, o[c / 4 - 1] = 0);
      s = i;
      do {
        for (l = 1 + u - h, p = Math.min(s, l), d = u, c = 0;c < this.targetWidthMultipliedByChannels; )
          m = e4[d++], _ = e4[d++], g = e4[d++], b2 = t ? e4[d++] : 255, n[c++] += (b2 ? m : 0) * p, n[c++] += (b2 ? _ : 0) * p, n[c++] += (b2 ? g : 0) * p, t && (n[c++] += b2 * p, o[c / 4 - 1] += b2 ? p : 0);
        if (!(s >= l)) {
          h += s;
          break;
        }
        u = d, h = u, s -= l;
      } while (s > 0 && u < this.widthPassResultSize);
      for (c = 0;c < this.targetWidthMultipliedByChannels; )
        s = t ? o[c / 4] : 1, p = t ? s ? 1 / s : 0 : r, a[f++] = Math.round(n[c++] * p), a[f++] = Math.round(n[c++] * p), a[f++] = Math.round(n[c++] * p), t && (a[f++] = Math.round(n[c++] * r));
    } while (f < this.finalResultSize);
    return a;
  }, Resize.prototype.resizeWidthInterpolatedRGB = function(e4) {
    return this._resizeWidthInterpolatedRGBChannels(e4, false);
  }, Resize.prototype.resizeWidthInterpolatedRGBA = function(e4) {
    return this._resizeWidthInterpolatedRGBChannels(e4, true);
  }, Resize.prototype.resizeWidthRGB = function(e4) {
    return this._resizeWidthRGBChannels(e4, false);
  }, Resize.prototype.resizeWidthRGBA = function(e4) {
    return this._resizeWidthRGBChannels(e4, true);
  }, Resize.prototype.resizeHeightInterpolated = function(e4) {
    const t = this.ratioWeightHeightPass, i = this.heightBuffer;
    let r, n = 0, a = 0, o = 0, s = 0, l = 0, u = 0, h = 0;
    for (;n < 1 / 3; n += t)
      for (o = 0;o < this.targetWidthMultipliedByChannels; )
        i[a++] = Math.round(e4[o++]);
    for (n -= 1 / 3, r = this.heightOriginal - 1;n < r; n += t)
      for (h = n % 1, u = 1 - h, s = Math.floor(n) * this.targetWidthMultipliedByChannels, l = s + this.targetWidthMultipliedByChannels, o = 0;o < this.targetWidthMultipliedByChannels; ++o)
        i[a++] = Math.round(e4[s++] * u + e4[l++] * h);
    for (;a < this.finalResultSize; )
      for (o = 0, s = r * this.targetWidthMultipliedByChannels;o < this.targetWidthMultipliedByChannels; ++o)
        i[a++] = Math.round(e4[s++]);
    return i;
  }, Resize.prototype.resizeHeightRGB = function(e4) {
    return this._resizeHeightRGBChannels(e4, false);
  }, Resize.prototype.resizeHeightRGBA = function(e4) {
    return this._resizeHeightRGBChannels(e4, true);
  }, Resize.prototype.resize = function(e4) {
    this.resizeCallback(this.resizeHeight(this.resizeWidth(e4)));
  }, Resize.prototype.bypassResizer = function(e4) {
    return e4;
  }, Resize.prototype.initializeFirstPassBuffers = function(e4) {
    this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize), e4 || (this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels), this.colorChannels > 3 && (this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal)));
  }, Resize.prototype.initializeSecondPassBuffers = function(e4) {
    this.heightBuffer = this.generateUint8Buffer(this.finalResultSize), e4 || (this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels), this.colorChannels > 3 && (this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth)));
  }, Resize.prototype.generateFloatBuffer = function(e4) {
    try {
      return new Float32Array(e4);
    } catch (e5) {
      return console.error(e5), [];
    }
  }, Resize.prototype.generateFloat64Buffer = function(e4) {
    try {
      return new Float64Array(e4);
    } catch (e5) {
      return console.error(e5), [];
    }
  }, Resize.prototype.generateUint8Buffer = function(e4) {
    try {
      return new Uint8Array(e4);
    } catch (e5) {
      return console.error(e5), [];
    }
  };
  operations = { nearestNeighbor(e4, t) {
    const { width: i, height: r } = e4, n = t.width, a = t.height, o = e4.data, s = t.data;
    for (let e5 = 0;e5 < a; e5++)
      for (let t2 = 0;t2 < n; t2++) {
        let l = 4 * (e5 * n + t2);
        let u = 4 * (Math.floor(e5 * r / a) * i + Math.floor(t2 * i / n));
        s[l++] = o[u++], s[l++] = o[u++], s[l++] = o[u++], s[l++] = o[u++];
      }
  }, bilinearInterpolation(e4, t) {
    const { width: i, height: r } = e4, n = t.width, a = t.height, o = e4.data, s = t.data, l = function(e5, t2, i2, r2, n2) {
      return t2 === r2 ? i2 : Math.round((e5 - t2) * n2 + (r2 - e5) * i2);
    }, u = function(e5, t2, r2, n2, a2, u2, h, c) {
      let f = 4 * (h * i + n2) + t2, d = 4 * (h * i + a2) + t2;
      const p = l(r2, n2, o[f], a2, o[d]);
      if (c === h)
        s[e5 + t2] = p;
      else {
        f = 4 * (c * i + n2) + t2, d = 4 * (c * i + a2) + t2;
        const m = l(r2, n2, o[f], a2, o[d]);
        s[e5 + t2] = l(u2, h, p, c, m);
      }
    };
    for (let e5 = 0;e5 < a; e5++)
      for (let t2 = 0;t2 < n; t2++) {
        const o2 = 4 * (e5 * n + t2), s2 = t2 * i / n, l2 = Math.floor(s2), h = Math.min(Math.ceil(s2), i - 1), c = e5 * r / a, f = Math.floor(c), d = Math.min(Math.ceil(c), r - 1);
        u(o2, 0, s2, l2, h, c, f, d), u(o2, 1, s2, l2, h, c, f, d), u(o2, 2, s2, l2, h, c, f, d), u(o2, 3, s2, l2, h, c, f, d);
      }
  }, _interpolate2D(e4, t, i, r) {
    const n = e4.data, a = t.data, o = e4.width, s = e4.height, l = t.width, u = t.height, h = Math.max(1, Math.floor(o / l)), c = l * h, f = Math.max(1, Math.floor(s / u)), d = u * f, p = Buffer2.alloc(c * s * 4);
    for (let e5 = 0;e5 < s; e5++)
      for (let t2 = 0;t2 < c; t2++) {
        const i2 = t2 * (o - 1) / c, a2 = Math.floor(i2), s2 = i2 - a2, l2 = 4 * (e5 * o + a2), u2 = 4 * (e5 * c + t2);
        for (let e6 = 0;e6 < 4; e6++) {
          const t3 = l2 + e6, i3 = a2 > 0 ? n[t3 - 4] : 2 * n[t3] - n[t3 + 4], h2 = n[t3], c2 = n[t3 + 4], f2 = a2 < o - 2 ? n[t3 + 8] : 2 * n[t3 + 4] - n[t3];
          p[u2 + e6] = r(i3, h2, c2, f2, s2);
        }
      }
    const m = Buffer2.alloc(c * d * 4);
    for (let e5 = 0;e5 < d; e5++)
      for (let t2 = 0;t2 < c; t2++) {
        const i2 = e5 * (s - 1) / d, n2 = Math.floor(i2), a2 = i2 - n2, o2 = 4 * (n2 * c + t2), l2 = 4 * (e5 * c + t2);
        for (let e6 = 0;e6 < 4; e6++) {
          const t3 = o2 + e6, i3 = n2 > 0 ? p[t3 - 4 * c] : 2 * p[t3] - p[t3 + 4 * c], u2 = p[t3], h2 = p[t3 + 4 * c], f2 = n2 < s - 2 ? p[t3 + 8 * c] : 2 * p[t3 + 4 * c] - p[t3];
          m[l2 + e6] = r(i3, u2, h2, f2, a2);
        }
      }
    const _ = h * f;
    if (_ > 1)
      for (let e5 = 0;e5 < u; e5++)
        for (let t2 = 0;t2 < l; t2++) {
          let i2 = 0, r2 = 0, n2 = 0, o2 = 0, s2 = 0;
          for (let a2 = 0;a2 < f; a2++) {
            const l2 = e5 * f + a2;
            for (let e6 = 0;e6 < h; e6++) {
              const a3 = 4 * (l2 * c + (t2 * h + e6)), u3 = m[a3 + 3];
              u3 && (i2 += m[a3], r2 += m[a3 + 1], n2 += m[a3 + 2], s2++), o2 += u3;
            }
          }
          const u2 = 4 * (e5 * l + t2);
          a[u2] = s2 ? Math.round(i2 / s2) : 0, a[u2 + 1] = s2 ? Math.round(r2 / s2) : 0, a[u2 + 2] = s2 ? Math.round(n2 / s2) : 0, a[u2 + 3] = Math.round(o2 / _);
        }
    else
      t.data = m;
  }, bicubicInterpolation(e4, t, i) {
    return this._interpolate2D(e4, t, i, function(e5, t2, i2, r, n) {
      const a = r - i2 - e5 + t2, o = e5 - t2 - a, s = i2 - e5, l = t2;
      return Math.max(0, Math.min(255, a * (n * n * n) + o * (n * n) + s * n + l));
    });
  }, hermiteInterpolation(e4, t, i) {
    return this._interpolate2D(e4, t, i, function(e5, t2, i2, r, n) {
      const a = t2, o = 0.5 * (i2 - e5), s = e5 - 2.5 * t2 + 2 * i2 - 0.5 * r, l = 0.5 * (r - e5) + 1.5 * (t2 - i2);
      return Math.max(0, Math.min(255, Math.round(((l * n + s) * n + o) * n + a)));
    });
  }, bezierInterpolation(e4, t, i) {
    return this._interpolate2D(e4, t, i, function(e5, t2, i2, r, n) {
      const a = 1 - n, o = t2 * a * a * a, s = 3 * (t2 + (i2 - e5) / 4) * a * a * n, l = 3 * (i2 - (r - t2) / 4) * a * n * n, u = i2 * n * n * n;
      return Math.max(0, Math.min(255, Math.round(o + s + l + u)));
    });
  } };
  ResizeOptionsSchema = z.union([z.object({ w: z.number().min(0), h: z.number().min(0).optional(), mode: z.nativeEnum(ResizeStrategy).optional() }), z.object({ w: z.number().min(0).optional(), h: z.number().min(0), mode: z.nativeEnum(ResizeStrategy).optional() })]);
  ScaleToFitOptionsSchema = z.object({ w: z.number().min(0), h: z.number().min(0), mode: z.nativeEnum(ResizeStrategy).optional() });
  ScaleComplexOptionsSchema = z.object({ f: z.number().min(0), mode: z.nativeEnum(ResizeStrategy).optional() });
  methods$d = { resize(e4, t) {
    const { mode: i } = ResizeOptionsSchema.parse(t);
    let r, n;
    if (typeof t.w == "number")
      r = t.w, n = t.h ?? e4.bitmap.height * (r / e4.bitmap.width);
    else {
      if (typeof t.h != "number")
        throw new Error("w must be a number");
      n = t.h, r = t.w ?? e4.bitmap.width * (n / e4.bitmap.height);
    }
    if (r = Math.round(r) || 1, n = Math.round(n) || 1, i && typeof operations[i] == "function") {
      const t2 = { data: Buffer2.alloc(r * n * 4), width: r, height: n };
      operations[i](e4.bitmap, t2), e4.bitmap = t2;
    } else {
      new Resize(e4.bitmap.width, e4.bitmap.height, r, n, true, true, (t2) => {
        e4.bitmap.data = Buffer2.from(t2), e4.bitmap.width = r, e4.bitmap.height = n;
      }).resize(e4.bitmap.data);
    }
    return e4;
  }, scale(e4, t) {
    const { f: i, mode: r } = typeof t == "number" ? { f: t } : ScaleComplexOptionsSchema.parse(t), n = e4.bitmap.width * i, a = e4.bitmap.height * i;
    return this.resize(e4, { w: n, h: a, mode: r });
  }, scaleToFit(e4, t) {
    const { h: i, w: r, mode: n } = ScaleToFitOptionsSchema.parse(t), a = r / i > e4.bitmap.width / e4.bitmap.height ? i / e4.bitmap.height : r / e4.bitmap.width;
    return this.scale(e4, { f: a, mode: n });
  } };
  ContainOptionsSchema = z.object({ w: z.number(), h: z.number(), align: z.number().optional(), mode: z.nativeEnum(ResizeStrategy).optional() });
  methods$c = { contain(e4, t) {
    const { w: i, h: r, align: n = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode: a } = ContainOptionsSchema.parse(t), o = 7 & n, s = n >> 3;
    if ((o === 0 || o & o - 1) && (s === 0 || s & s - 1))
      throw new Error("only use one flag per alignment direction");
    const l = o >> 1, u = s >> 1, h = i / r > e4.bitmap.width / e4.bitmap.height ? r / e4.bitmap.height : i / e4.bitmap.width, c = methods$d.scale(clone(e4), { f: h, mode: a });
    return (e4 = methods$d.resize(e4, { w: i, h: r, mode: a })).scan((t2, i2, r2) => {
      e4.bitmap.data.writeUInt32BE(e4.background, r2);
    }), e4 = methods$h.blit(e4, { src: c, x: (e4.bitmap.width - c.bitmap.width) / 2 * l, y: (e4.bitmap.height - c.bitmap.height) / 2 * u });
  } };
  CropOptionsSchema = z.object({ x: z.number(), y: z.number(), w: z.number(), h: z.number() });
  AutocropComplexOptionsSchema = z.object({ tolerance: z.number().min(0).max(1).optional(), cropOnlyFrames: z.boolean().optional(), cropSymmetric: z.boolean().optional(), leaveBorder: z.number().optional(), ignoreSides: z.object({ north: z.boolean().optional(), south: z.boolean().optional(), east: z.boolean().optional(), west: z.boolean().optional() }).optional() });
  methods$b = { crop(e4, t) {
    let { x: i, y: r, w: n, h: a } = CropOptionsSchema.parse(t);
    if (i = Math.round(i), r = Math.round(r), n = Math.round(n), a = Math.round(a), i === 0 && n === e4.bitmap.width) {
      const t2 = n * r + i << 2, o = t2 + (a * n << 2);
      e4.bitmap.data = e4.bitmap.data.slice(t2, o);
    } else {
      const t2 = Buffer2.allocUnsafe(n * a * 4);
      let o = 0;
      scan(e4, i, r, n, a, function(i2, r2, n2) {
        const a2 = e4.bitmap.data.readUInt32BE(n2);
        t2.writeUInt32BE(a2, o), o += 4;
      }), e4.bitmap.data = t2;
    }
    return e4.bitmap.width = n, e4.bitmap.height = a, e4;
  }, autocrop(e4, t = {}) {
    const { tolerance: i = 0.0002, cropOnlyFrames: r = true, cropSymmetric: n = false, leaveBorder: a = 0, ignoreSides: o } = typeof t == "number" ? { tolerance: t } : AutocropComplexOptionsSchema.parse(t), s = e4.bitmap.width, l = e4.bitmap.height, u = { north: false, south: false, east: false, west: false, ...o };
    let h = e4.getPixelColor(0, 0);
    const c = intToRGBA$1(h);
    let f = 0, d = 0, p = 0, m = 0;
    if (h = e4.getPixelColor(0, 0), !u.north)
      e:
        for (let t2 = 0;t2 < l - 1; t2++) {
          for (let r2 = 0;r2 < s; r2++) {
            if (colorDiff(c, intToRGBA$1(e4.getPixelColor(r2, t2))) > i)
              break e;
          }
          f++;
        }
    if (h = e4.getPixelColor(s, 0), !u.west)
      e:
        for (let t2 = 0;t2 < s - 1; t2++) {
          for (let r2 = 0 + f;r2 < l; r2++) {
            if (colorDiff(c, intToRGBA$1(e4.getPixelColor(t2, r2))) > i)
              break e;
          }
          m++;
        }
    if (h = e4.getPixelColor(0, l), !u.south)
      e:
        for (let t2 = l - 1;t2 >= f + 1; t2--) {
          for (let r2 = s - d - 1;r2 >= 0; r2--) {
            if (colorDiff(c, intToRGBA$1(e4.getPixelColor(r2, t2))) > i)
              break e;
          }
          p++;
        }
    if (h = e4.getPixelColor(s, l), !u.east)
      e:
        for (let t2 = s - 1;t2 >= 0 + m + 1; t2--) {
          for (let r2 = l - 1;r2 >= 0 + f; r2--) {
            if (colorDiff(c, intToRGBA$1(e4.getPixelColor(t2, r2))) > i)
              break e;
          }
          d++;
        }
    let _ = false;
    if (m -= a, d -= a, f -= a, p -= a, n) {
      const e5 = Math.min(d, m), t2 = Math.min(f, p);
      m = e5, d = e5, f = t2, p = t2;
    }
    m = m >= 0 ? m : 0, d = d >= 0 ? d : 0, f = f >= 0 ? f : 0, p = p >= 0 ? p : 0;
    const g = s - (m + d), b2 = l - (p + f);
    return _ = r ? d !== 0 && f !== 0 && m !== 0 && p !== 0 : d !== 0 || f !== 0 || m !== 0 || p !== 0, _ && this.crop(e4, { x: m, y: f, w: g, h: b2 }), e4;
  } };
  CoverOptionsSchema = z.object({ w: z.number(), h: z.number(), align: z.number().optional(), mode: z.nativeEnum(ResizeStrategy).optional() });
  methods$a = { cover(e4, t) {
    const { w: i, h: r, align: n = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode: a } = CoverOptionsSchema.parse(t), o = 7 & n, s = n >> 3;
    if ((o === 0 || o & o - 1) && (s === 0 || s & s - 1))
      throw new Error("only use one flag per alignment direction");
    const l = o >> 1, u = s >> 1, h = i / r > e4.bitmap.width / e4.bitmap.height ? i / e4.bitmap.width : r / e4.bitmap.height;
    return e4 = methods$d.scale(e4, { f: h, mode: a }), e4 = methods$b.crop(e4, { x: (e4.bitmap.width - i) / 2 * l, y: (e4.bitmap.height - r) / 2 * u, w: i, h: r });
  } };
  DisplaceOptionsSchema = z.object({ map: JimpClassSchema, offset: z.number() });
  methods$9 = { displace(e4, t) {
    const { map: i, offset: r } = DisplaceOptionsSchema.parse(t), n = clone(e4);
    return e4.scan((t2, a, o) => {
      let s = i.bitmap.data[o] / 256 * r;
      s = Math.round(s);
      const l = e4.getPixelIndex(t2 + s, a);
      e4.bitmap.data[l] = n.bitmap.data[o], e4.bitmap.data[l + 1] = n.bitmap.data[o + 1], e4.bitmap.data[l + 2] = n.bitmap.data[o + 2];
    }), e4;
  } };
  methods$8 = { dither(e4) {
    const t = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
    return e4.scan((i, r, n) => {
      const a = t[((3 & r) << 2) + i % 4];
      e4.bitmap.data[n] = Math.min(e4.bitmap.data[n] + a, 255), e4.bitmap.data[n + 1] = Math.min(e4.bitmap.data[n + 1] + a, 255), e4.bitmap.data[n + 2] = Math.min(e4.bitmap.data[n + 2] + a, 255);
    }), e4;
  } };
  FisheyeOptionsSchema = z.object({ radius: z.number().min(0).optional() });
  methods$7 = { fisheye(e4, t = {}) {
    const { radius: i = 2.5 } = FisheyeOptionsSchema.parse(t), r = clone(e4), { width: n, height: a } = r.bitmap;
    return r.scan((t2, o) => {
      const s = t2 / n, l = o / a, u = Math.sqrt(Math.pow(s - 0.5, 2) + Math.pow(l - 0.5, 2)), h = 2 * Math.pow(u, i), c = (s - 0.5) / u, f = (l - 0.5) / u, d = Math.round((h * c + 0.5) * n), p = Math.round((h * f + 0.5) * a), m = r.getPixelColor(d, p);
      e4.setPixelColor(m, t2, o);
    }), e4.setPixelColor(r.getPixelColor(n / 2, a / 2), n / 2, a / 2), e4;
  } };
  FlipOptionsSchema = z.object({ horizontal: z.boolean().optional(), vertical: z.boolean().optional() });
  methods$6 = { flip(e4, t) {
    const { horizontal: i, vertical: r } = FlipOptionsSchema.parse(t), n = Buffer2.alloc(e4.bitmap.data.length);
    return e4.scan((t2, a, o) => {
      const s = i ? e4.bitmap.width - 1 - t2 : t2, l = r ? e4.bitmap.height - 1 - a : a, u = e4.bitmap.width * l + s << 2, h = e4.bitmap.data.readUInt32BE(o);
      n.writeUInt32BE(h, u);
    }), e4.bitmap.data = Buffer2.from(n), e4;
  } };
  Converter$1.prototype.convert = function(e4) {
    var t, i, r, n = {}, a = this.srcAlphabet.length, o = this.dstAlphabet.length, s = e4.length, l = typeof e4 == "string" ? "" : [];
    if (!this.isValid(e4))
      throw new Error('Number "' + e4 + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
    if (this.srcAlphabet === this.dstAlphabet)
      return e4;
    for (t = 0;t < s; t++)
      n[t] = this.srcAlphabet.indexOf(e4[t]);
    do {
      for (i = 0, r = 0, t = 0;t < s; t++)
        (i = i * a + n[t]) >= o ? (n[r++] = parseInt(i / o, 10), i %= o) : r > 0 && (n[r++] = 0);
      s = r, l = this.dstAlphabet.slice(i, i + 1).concat(l);
    } while (r !== 0);
    return l;
  }, Converter$1.prototype.isValid = function(e4) {
    for (var t = 0;t < e4.length; ++t)
      if (this.srcAlphabet.indexOf(e4[t]) === -1)
        return false;
    return true;
  };
  converter = Converter$1;
  Converter = converter;
  anyBase.BIN = "01", anyBase.OCT = "01234567", anyBase.DEC = "0123456789", anyBase.HEX = "0123456789abcdef";
  anyBase_1 = anyBase;
  anyBase$1 = getDefaultExportFromCjs(anyBase_1);
  __defProp$1 = Object.defineProperty;
  __defNormalProp$1 = (e4, t, i) => (t in e4) ? __defProp$1(e4, t, { enumerable: true, configurable: true, writable: true, value: i }) : e4[t] = i;
  __publicField$1 = (e4, t, i) => __defNormalProp$1(e4, typeof t != "symbol" ? t + "" : t, i);
  c$1 = [];
  alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_";
  maxHashLength = [NaN, NaN];
  for (let e4 = 2;e4 < 65; e4++) {
    const t = anyBase$1(anyBase$1.BIN, alphabet.slice(0, e4))(new Array(65).join("1"));
    maxHashLength.push(t.length);
  }
  methods$5 = { pHash: (e4) => new ImagePHash().getHash(e4), hash(e4, t = 64) {
    if (t < 2 || t > 64)
      throw new Error("base must be a number between 2 and 64");
    const i = alphabet.slice(0, t), r = this.pHash(e4), n = maxHashLength[t];
    return anyBase$1(anyBase$1.BIN, i)(r).padStart(n, "0");
  }, distanceFromHash(e4, t) {
    const i = new ImagePHash, r = i.getHash(e4);
    return i.distance(r, t);
  } };
  MaskOptionsObjectSchema = z.object({ src: JimpClassSchema, x: z.number().optional(), y: z.number().optional() });
  MaskOptionsSchema = z.union([JimpClassSchema, MaskOptionsObjectSchema]);
  methods$4 = { mask(e4, t) {
    let i, r, n;
    MaskOptionsSchema.parse(t), "bitmap" in t ? (i = t, r = 0, n = 0) : (i = t.src, r = t.x ?? 0, n = t.y ?? 0), r = Math.round(r), n = Math.round(n);
    const a = e4.bitmap.width, o = e4.bitmap.height;
    return i.scan(function(t2, s, l) {
      const u = r + t2, h = n + s;
      if (u >= 0 && h >= 0 && u < a && h < o) {
        const t3 = e4.getPixelIndex(u, h), { data: r2 } = i.bitmap, n2 = (r2[l + 0] + r2[l + 1] + r2[l + 2]) / 3;
        e4.bitmap.data[t3 + 3] *= n2 / 255;
      }
    }), e4;
  } };
  PrintOptionsSchema = z.object({ x: z.number(), y: z.number(), text: z.union([z.union([z.string(), z.number()]), z.object({ text: z.union([z.string(), z.number()]), alignmentX: z.nativeEnum(HorizontalAlign).optional(), alignmentY: z.nativeEnum(VerticalAlign).optional() })]), maxWidth: z.number().optional(), maxHeight: z.number().optional(), cb: z.function(z.tuple([z.object({ x: z.number(), y: z.number() })])).optional() });
  methods$3 = { print(e4, { font: t, ...i }) {
    let r, n, { x: a, y: o, text: s, maxWidth: l = 1 / 0, maxHeight: u = 1 / 0, cb: h = () => {
    } } = PrintOptionsSchema.parse(i);
    typeof s == "object" && s.text !== null && s.text !== undefined ? (r = s.alignmentX || HorizontalAlign.LEFT, n = s.alignmentY || VerticalAlign.TOP, { text: s } = s) : (r = HorizontalAlign.LEFT, n = VerticalAlign.TOP, s = s.toString()), typeof s == "number" && (s = s.toString()), u !== 1 / 0 && n === VerticalAlign.BOTTOM ? o += u - measureTextHeight(t, s, l) : u !== 1 / 0 && n === VerticalAlign.MIDDLE && (o += u / 2 - measureTextHeight(t, s, l) / 2);
    const c = Object.entries(t.chars).find((e5) => e5[1].xadvance)?.[1].xadvance;
    if (typeof c != "number")
      throw new Error("Could not find default character width");
    const { lines: f, longestLine: d } = splitLines(t, s, l);
    return f.forEach((i2) => {
      const n2 = i2.join(" "), s2 = xOffsetBasedOnAlignment(t, n2, l, r);
      printText(e4, t, a + s2, o, n2, c), o += t.common.lineHeight;
    }), h.bind(e4)({ x: a + d, y: o }), e4;
  } };
  RotateOptionsSchema = z.union([z.number(), z.object({ deg: z.number(), mode: z.union([z.boolean(), z.nativeEnum(ResizeStrategy)]).optional() })]);
  methods$2 = { rotate(e4, t) {
    const i = RotateOptionsSchema.parse(t), r = typeof i == "number" ? { deg: i } : i, { mode: n = true } = r;
    let { deg: a } = r;
    if (a %= 360, a % 360 == 0)
      return e4;
    return a % 90 == 0 && (n || e4.bitmap.width === e4.bitmap.height || a % 180 == 0) ? matrixRotate(e4, a) : advancedRotate(e4, a, n), e4;
  } };
  ThresholdOptionsSchema = z.object({ max: z.number().min(0).max(255), replace: z.number().min(0).max(255).optional(), autoGreyscale: z.boolean().optional() });
  methods$1 = { threshold(e4, t) {
    let { max: i, replace: r = 255, autoGreyscale: n = true } = ThresholdOptionsSchema.parse(t);
    return i = limit255(i), r = limit255(r), n && methods$e.greyscale(e4), e4.scan((t2, n2, a) => {
      const o = e4.bitmap.data[a] < i ? e4.bitmap.data[a] : r;
      e4.bitmap.data[a] = o, e4.bitmap.data[a + 1] = o, e4.bitmap.data[a + 2] = o;
    }), e4;
  } };
  __defProp2 = Object.defineProperty;
  __defNormalProp = (e4, t, i) => (t in e4) ? __defProp2(e4, t, { enumerable: true, configurable: true, writable: true, value: i }) : e4[t] = i;
  __export2 = (e4, t) => {
    for (var i in t)
      __defProp2(e4, i, { get: t[i], enumerable: true });
  };
  __publicField = (e4, t, i) => (__defNormalProp(e4, typeof t != "symbol" ? t + "" : t, i), i);
  constants_exports = {};
  __export2(constants_exports, { bt709: () => bt709_exports });
  bt709_exports = {};
  __export2(bt709_exports, { Y: () => Y, x: () => x$1, y: () => y$1 });
  Y = ((e4) => (e4[e4.RED = 0.2126] = "RED", e4[e4.GREEN = 0.7152] = "GREEN", e4[e4.BLUE = 0.0722] = "BLUE", e4[e4.WHITE = 1] = "WHITE", e4))(Y || {});
  x$1 = ((e4) => (e4[e4.RED = 0.64] = "RED", e4[e4.GREEN = 0.3] = "GREEN", e4[e4.BLUE = 0.15] = "BLUE", e4[e4.WHITE = 0.3127] = "WHITE", e4))(x$1 || {});
  y$1 = ((e4) => (e4[e4.RED = 0.33] = "RED", e4[e4.GREEN = 0.6] = "GREEN", e4[e4.BLUE = 0.06] = "BLUE", e4[e4.WHITE = 0.329] = "WHITE", e4))(y$1 || {});
  conversion_exports = {};
  __export2(conversion_exports, { lab2rgb: () => lab2rgb, lab2xyz: () => lab2xyz, rgb2hsl: () => rgb2hsl, rgb2lab: () => rgb2lab, rgb2xyz: () => rgb2xyz, xyz2lab: () => xyz2lab, xyz2rgb: () => xyz2rgb });
  arithmetic_exports = {};
  __export2(arithmetic_exports, { degrees2radians: () => degrees2radians, inRange0to255: () => inRange0to255, inRange0to255Rounded: () => inRange0to255Rounded, intInRange: () => intInRange, max3: () => max3, min3: () => min3, stableSort: () => stableSort });
  refX = 0.95047;
  refY = 1;
  refZ = 1.08883;
  refX2 = 0.95047;
  refY2 = 1;
  refZ2 = 1.08883;
  distance_exports = {};
  __export2(distance_exports, { AbstractDistanceCalculator: () => AbstractDistanceCalculator, AbstractEuclidean: () => AbstractEuclidean, AbstractManhattan: () => AbstractManhattan, CIE94GraphicArts: () => CIE94GraphicArts, CIE94Textiles: () => CIE94Textiles, CIEDE2000: () => CIEDE2000, CMetric: () => CMetric, Euclidean: () => Euclidean, EuclideanBT709: () => EuclideanBT709, EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha, Manhattan: () => Manhattan, ManhattanBT709: () => ManhattanBT709, ManhattanNommyde: () => ManhattanNommyde, PNGQuant: () => PNGQuant });
  AbstractDistanceCalculator = class {
    constructor() {
      __publicField(this, "_maxDistance"), __publicField(this, "_whitePoint"), this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
    }
    setWhitePoint(e4, t, i, r) {
      this._whitePoint = { r: e4 > 0 ? 255 / e4 : 0, g: t > 0 ? 255 / t : 0, b: i > 0 ? 255 / i : 0, a: r > 0 ? 255 / r : 0 }, this._maxDistance = this.calculateRaw(e4, t, i, r, 0, 0, 0, 0);
    }
    calculateNormalized(e4, t) {
      return this.calculateRaw(e4.r, e4.g, e4.b, e4.a, t.r, t.g, t.b, t.a) / this._maxDistance;
    }
  };
  AbstractCIE94 = class extends AbstractDistanceCalculator {
    calculateRaw(e4, t, i, r, n, a, o, s) {
      const l = rgb2lab(inRange0to255(e4 * this._whitePoint.r), inRange0to255(t * this._whitePoint.g), inRange0to255(i * this._whitePoint.b)), u = rgb2lab(inRange0to255(n * this._whitePoint.r), inRange0to255(a * this._whitePoint.g), inRange0to255(o * this._whitePoint.b)), h = l.L - u.L, c = l.a - u.a, f = l.b - u.b, d = Math.sqrt(l.a * l.a + l.b * l.b), p = d - Math.sqrt(u.a * u.a + u.b * u.b);
      let m = c * c + f * f - p * p;
      m = m < 0 ? 0 : Math.sqrt(m);
      const _ = (s - r) * this._whitePoint.a * this._kA;
      return Math.sqrt((h / this._Kl) ** 2 + (p / (1 + this._K1 * d)) ** 2 + (m / (1 + this._K2 * d)) ** 2 + _ ** 2);
    }
  };
  CIE94Textiles = class extends AbstractCIE94 {
    _setDefaults() {
      this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 12.5 / 255;
    }
  };
  CIE94GraphicArts = class extends AbstractCIE94 {
    _setDefaults() {
      this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 25 / 255;
    }
  };
  _CIEDE2000 = class extends AbstractDistanceCalculator {
    _setDefaults() {
    }
    static _calculatehp(e4, t) {
      const i = Math.atan2(e4, t);
      return i >= 0 ? i : i + _CIEDE2000._deg360InRad;
    }
    static _calculateRT(e4, t) {
      const i = t ** 7, r = 2 * Math.sqrt(i / (i + _CIEDE2000._pow25to7)), n = _CIEDE2000._deg30InRad * Math.exp(-(((e4 - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
      return -Math.sin(2 * n) * r;
    }
    static _calculateT(e4) {
      return 1 - 0.17 * Math.cos(e4 - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(2 * e4) + 0.32 * Math.cos(3 * e4 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(4 * e4 - _CIEDE2000._deg63InRad);
    }
    static _calculate_ahp(e4, t, i, r) {
      const n = i + r;
      return e4 === 0 ? n : t <= _CIEDE2000._deg180InRad ? n / 2 : n < _CIEDE2000._deg360InRad ? (n + _CIEDE2000._deg360InRad) / 2 : (n - _CIEDE2000._deg360InRad) / 2;
    }
    static _calculate_dHp(e4, t, i, r) {
      let n;
      return n = e4 === 0 ? 0 : t <= _CIEDE2000._deg180InRad ? i - r : i <= r ? i - r + _CIEDE2000._deg360InRad : i - r - _CIEDE2000._deg360InRad, 2 * Math.sqrt(e4) * Math.sin(n / 2);
    }
    calculateRaw(e4, t, i, r, n, a, o, s) {
      const l = rgb2lab(inRange0to255(e4 * this._whitePoint.r), inRange0to255(t * this._whitePoint.g), inRange0to255(i * this._whitePoint.b)), u = rgb2lab(inRange0to255(n * this._whitePoint.r), inRange0to255(a * this._whitePoint.g), inRange0to255(o * this._whitePoint.b)), h = (s - r) * this._whitePoint.a * _CIEDE2000._kA, c = this.calculateRawInLab(l, u);
      return Math.sqrt(c + h * h);
    }
    calculateRawInLab(e4, t) {
      const { L: i, a: r, b: n } = e4, a = t.L, o = t.a, s = t.b, l = ((Math.sqrt(r * r + n * n) + Math.sqrt(o * o + s * s)) / 2) ** 7, u = 0.5 * (1 - Math.sqrt(l / (l + _CIEDE2000._pow25to7))), h = (1 + u) * r, c = (1 + u) * o, f = Math.sqrt(h * h + n * n), d = Math.sqrt(c * c + s * s), p = f * d, m = _CIEDE2000._calculatehp(n, h), _ = _CIEDE2000._calculatehp(s, c), g = Math.abs(m - _), b2 = a - i, y = d - f, w = _CIEDE2000._calculate_dHp(p, g, _, m), v = _CIEDE2000._calculate_ahp(p, g, m, _), x = (f + d) / 2, E = ((i + a) / 2 - 50) ** 2, k = y / (1 + 0.045 * x), S = w / (1 + 0.015 * _CIEDE2000._calculateT(v) * x);
      return (b2 / (1 + 0.015 * E / Math.sqrt(20 + E))) ** 2 + k ** 2 + S ** 2 + _CIEDE2000._calculateRT(v, x) * k * S;
    }
  };
  CIEDE2000 = _CIEDE2000;
  __publicField(CIEDE2000, "_kA", 25 / 255), __publicField(CIEDE2000, "_pow25to7", 25 ** 7), __publicField(CIEDE2000, "_deg360InRad", degrees2radians(360)), __publicField(CIEDE2000, "_deg180InRad", degrees2radians(180)), __publicField(CIEDE2000, "_deg30InRad", degrees2radians(30)), __publicField(CIEDE2000, "_deg6InRad", degrees2radians(6)), __publicField(CIEDE2000, "_deg63InRad", degrees2radians(63)), __publicField(CIEDE2000, "_deg275InRad", degrees2radians(275)), __publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));
  CMetric = class extends AbstractDistanceCalculator {
    calculateRaw(e4, t, i, r, n, a, o, s) {
      const l = (e4 + n) / 2 * this._whitePoint.r, u = (e4 - n) * this._whitePoint.r, h = (t - a) * this._whitePoint.g, c = (i - o) * this._whitePoint.b, f = ((512 + l) * u * u >> 8) + 4 * h * h + ((767 - l) * c * c >> 8), d = (s - r) * this._whitePoint.a;
      return Math.sqrt(f + d * d);
    }
    _setDefaults() {
    }
  };
  AbstractEuclidean = class extends AbstractDistanceCalculator {
    calculateRaw(e4, t, i, r, n, a, o, s) {
      const l = n - e4, u = a - t, h = o - i, c = s - r;
      return Math.sqrt(this._kR * l * l + this._kG * u * u + this._kB * h * h + this._kA * c * c);
    }
  };
  Euclidean = class extends AbstractEuclidean {
    _setDefaults() {
      this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
    }
  };
  EuclideanBT709 = class extends AbstractEuclidean {
    _setDefaults() {
      this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
    }
  };
  EuclideanBT709NoAlpha = class extends AbstractEuclidean {
    _setDefaults() {
      this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 0;
    }
  };
  AbstractManhattan = class extends AbstractDistanceCalculator {
    calculateRaw(e4, t, i, r, n, a, o, s) {
      let l = n - e4, u = a - t, h = o - i, c = s - r;
      return l < 0 && (l = 0 - l), u < 0 && (u = 0 - u), h < 0 && (h = 0 - h), c < 0 && (c = 0 - c), this._kR * l + this._kG * u + this._kB * h + this._kA * c;
    }
  };
  Manhattan = class extends AbstractManhattan {
    _setDefaults() {
      this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
    }
  };
  ManhattanNommyde = class extends AbstractManhattan {
    _setDefaults() {
      this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
    }
  };
  ManhattanBT709 = class extends AbstractManhattan {
    _setDefaults() {
      this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
    }
  };
  PNGQuant = class extends AbstractDistanceCalculator {
    calculateRaw(e4, t, i, r, n, a, o, s) {
      const l = (s - r) * this._whitePoint.a;
      return this._colordifferenceCh(e4 * this._whitePoint.r, n * this._whitePoint.r, l) + this._colordifferenceCh(t * this._whitePoint.g, a * this._whitePoint.g, l) + this._colordifferenceCh(i * this._whitePoint.b, o * this._whitePoint.b, l);
    }
    _colordifferenceCh(e4, t, i) {
      const r = e4 - t, n = r + i;
      return r * r + n * n;
    }
    _setDefaults() {
    }
  };
  palette_exports = {};
  __export2(palette_exports, { AbstractPaletteQuantizer: () => AbstractPaletteQuantizer, ColorHistogram: () => ColorHistogram, NeuQuant: () => NeuQuant, NeuQuantFloat: () => NeuQuantFloat, RGBQuant: () => RGBQuant, WuColorCube: () => WuColorCube, WuQuant: () => WuQuant });
  AbstractPaletteQuantizer = class {
    quantizeSync() {
      for (const e4 of this.quantize())
        if (e4.palette)
          return e4.palette;
      throw new Error("unreachable");
    }
  };
  Point = class {
    constructor() {
      __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), __publicField(this, "uint32"), __publicField(this, "rgba"), this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
    }
    static createByQuadruplet(e4) {
      const t = new Point;
      return t.r = 0 | e4[0], t.g = 0 | e4[1], t.b = 0 | e4[2], t.a = 0 | e4[3], t._loadUINT32(), t._loadQuadruplet(), t;
    }
    static createByRGBA(e4, t, i, r) {
      const n = new Point;
      return n.r = 0 | e4, n.g = 0 | t, n.b = 0 | i, n.a = 0 | r, n._loadUINT32(), n._loadQuadruplet(), n;
    }
    static createByUint32(e4) {
      const t = new Point;
      return t.uint32 = e4 >>> 0, t._loadRGBA(), t._loadQuadruplet(), t;
    }
    from(e4) {
      this.r = e4.r, this.g = e4.g, this.b = e4.b, this.a = e4.a, this.uint32 = e4.uint32, this.rgba[0] = e4.r, this.rgba[1] = e4.g, this.rgba[2] = e4.b, this.rgba[3] = e4.a;
    }
    getLuminosity(e4) {
      let t = this.r, i = this.g, r = this.b;
      return e4 && (t = Math.min(255, 255 - this.a + this.a * t / 255), i = Math.min(255, 255 - this.a + this.a * i / 255), r = Math.min(255, 255 - this.a + this.a * r / 255)), 0.2126 * t + 0.7152 * i + 0.0722 * r;
    }
    _loadUINT32() {
      this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
    }
    _loadRGBA() {
      this.r = 255 & this.uint32, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
    }
    _loadQuadruplet() {
      this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
    }
  };
  PointContainer = class {
    constructor() {
      __publicField(this, "_pointArray"), __publicField(this, "_width"), __publicField(this, "_height"), this._width = 0, this._height = 0, this._pointArray = [];
    }
    getWidth() {
      return this._width;
    }
    getHeight() {
      return this._height;
    }
    setWidth(e4) {
      this._width = e4;
    }
    setHeight(e4) {
      this._height = e4;
    }
    getPointArray() {
      return this._pointArray;
    }
    clone() {
      const e4 = new PointContainer;
      e4._width = this._width, e4._height = this._height;
      for (let t = 0, i = this._pointArray.length;t < i; t++)
        e4._pointArray[t] = Point.createByUint32(0 | this._pointArray[t].uint32);
      return e4;
    }
    toUint32Array() {
      const e4 = this._pointArray.length, t = new Uint32Array(e4);
      for (let i = 0;i < e4; i++)
        t[i] = this._pointArray[i].uint32;
      return t;
    }
    toUint8Array() {
      return new Uint8Array(this.toUint32Array().buffer);
    }
    static fromHTMLImageElement(e4) {
      const { naturalWidth: t, naturalHeight: i } = e4, r = document.createElement("canvas");
      r.width = t, r.height = i;
      return r.getContext("2d").drawImage(e4, 0, 0, t, i, 0, 0, t, i), PointContainer.fromHTMLCanvasElement(r);
    }
    static fromHTMLCanvasElement(e4) {
      const { width: t, height: i } = e4, r = e4.getContext("2d").getImageData(0, 0, t, i);
      return PointContainer.fromImageData(r);
    }
    static fromImageData(e4) {
      const { width: t, height: i } = e4;
      return PointContainer.fromUint8Array(e4.data, t, i);
    }
    static fromUint8Array(e4, t, i) {
      switch (Object.prototype.toString.call(e4)) {
        case "[object Uint8ClampedArray]":
        case "[object Uint8Array]":
          break;
        default:
          e4 = new Uint8Array(e4);
      }
      const r = new Uint32Array(e4.buffer);
      return PointContainer.fromUint32Array(r, t, i);
    }
    static fromUint32Array(e4, t, i) {
      const r = new PointContainer;
      r._width = t, r._height = i;
      for (let t2 = 0, i2 = e4.length;t2 < i2; t2++)
        r._pointArray[t2] = Point.createByUint32(0 | e4[t2]);
      return r;
    }
    static fromBuffer(e4, t, i) {
      const r = new Uint32Array(e4.buffer, e4.byteOffset, e4.byteLength / Uint32Array.BYTES_PER_ELEMENT);
      return PointContainer.fromUint32Array(r, t, i);
    }
  };
  hueGroups = 10;
  Palette = class {
    constructor() {
      __publicField(this, "_pointContainer"), __publicField(this, "_pointArray", []), __publicField(this, "_i32idx", {}), this._pointContainer = new PointContainer, this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
    }
    add(e4) {
      this._pointArray.push(e4), this._pointContainer.setWidth(this._pointArray.length);
    }
    has(e4) {
      for (let t = this._pointArray.length - 1;t >= 0; t--)
        if (e4.uint32 === this._pointArray[t].uint32)
          return true;
      return false;
    }
    getNearestColor(e4, t) {
      return this._pointArray[0 | this._getNearestIndex(e4, t)];
    }
    getPointContainer() {
      return this._pointContainer;
    }
    _nearestPointFromCache(e4) {
      return typeof this._i32idx[e4] == "number" ? this._i32idx[e4] : -1;
    }
    _getNearestIndex(e4, t) {
      let i = this._nearestPointFromCache("" + t.uint32);
      if (i >= 0)
        return i;
      let r = Number.MAX_VALUE;
      i = 0;
      for (let n = 0, a = this._pointArray.length;n < a; n++) {
        const a2 = this._pointArray[n], o = e4.calculateRaw(t.r, t.g, t.b, t.a, a2.r, a2.g, a2.b, a2.a);
        o < r && (r = o, i = n);
      }
      return this._i32idx[t.uint32] = i, i;
    }
    sort() {
      this._i32idx = {}, this._pointArray.sort((e4, t) => {
        const i = rgb2hsl(e4.r, e4.g, e4.b), r = rgb2hsl(t.r, t.g, t.b), n = e4.r === e4.g && e4.g === e4.b ? 0 : 1 + hueGroup(i.h, hueGroups), a = (t.r === t.g && t.g === t.b ? 0 : 1 + hueGroup(r.h, hueGroups)) - n;
        if (a)
          return -a;
        const o = e4.getLuminosity(true), s = t.getLuminosity(true);
        if (s - o != 0)
          return s - o;
        const l = (100 * r.s | 0) - (100 * i.s | 0);
        return l ? -l : 0;
      });
    }
  };
  utils_exports = {};
  __export2(utils_exports, { HueStatistics: () => HueStatistics, Palette: () => Palette, Point: () => Point, PointContainer: () => PointContainer, ProgressTracker: () => ProgressTracker, arithmetic: () => arithmetic_exports });
  HueGroup = class {
    constructor() {
      __publicField(this, "num", 0), __publicField(this, "cols", []);
    }
  };
  HueStatistics = class {
    constructor(e4, t) {
      __publicField(this, "_numGroups"), __publicField(this, "_minCols"), __publicField(this, "_stats"), __publicField(this, "_groupsFull"), this._numGroups = e4, this._minCols = t, this._stats = [];
      for (let t2 = 0;t2 <= e4; t2++)
        this._stats[t2] = new HueGroup;
      this._groupsFull = 0;
    }
    check(e4) {
      this._groupsFull === this._numGroups + 1 && (this.check = () => {
      });
      const t = 255 & e4, i = e4 >>> 8 & 255, r = e4 >>> 16 & 255, n = t === i && i === r ? 0 : 1 + hueGroup(rgb2hsl(t, i, r).h, this._numGroups), a = this._stats[n], o = this._minCols;
      a.num++, a.num > o || (a.num === o && this._groupsFull++, a.num <= o && this._stats[n].cols.push(e4));
    }
    injectIntoDictionary(e4) {
      for (let t = 0;t <= this._numGroups; t++)
        this._stats[t].num <= this._minCols && this._stats[t].cols.forEach((t2) => {
          e4[t2] ? e4[t2]++ : e4[t2] = 1;
        });
    }
    injectIntoArray(e4) {
      for (let t = 0;t <= this._numGroups; t++)
        this._stats[t].num <= this._minCols && this._stats[t].cols.forEach((t2) => {
          e4.indexOf(t2) === -1 && e4.push(t2);
        });
    }
  };
  _ProgressTracker = class {
    constructor(e4, t) {
      __publicField(this, "progress"), __publicField(this, "_step"), __publicField(this, "_range"), __publicField(this, "_last"), __publicField(this, "_progressRange"), this._range = e4, this._progressRange = t, this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0), this._last = -this._step, this.progress = 0;
    }
    shouldNotify(e4) {
      return e4 - this._last >= this._step && (this._last = e4, this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange), true);
    }
  };
  ProgressTracker = _ProgressTracker;
  __publicField(ProgressTracker, "steps", 100);
  networkBiasShift = 3;
  Neuron = class {
    constructor(e4) {
      __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), this.r = this.g = this.b = this.a = e4;
    }
    toPoint() {
      return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
    }
    subtract(e4, t, i, r) {
      this.r -= 0 | e4, this.g -= 0 | t, this.b -= 0 | i, this.a -= 0 | r;
    }
  };
  _NeuQuant = class extends AbstractPaletteQuantizer {
    constructor(e4, t = 256) {
      super(), __publicField(this, "_pointArray"), __publicField(this, "_networkSize"), __publicField(this, "_network"), __publicField(this, "_sampleFactor"), __publicField(this, "_radPower"), __publicField(this, "_freq"), __publicField(this, "_bias"), __publicField(this, "_distance"), this._distance = e4, this._pointArray = [], this._sampleFactor = 1, this._networkSize = t, this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
    }
    sample(e4) {
      this._pointArray = this._pointArray.concat(e4.getPointArray());
    }
    *quantize() {
      this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
    }
    _init() {
      this._freq = [], this._bias = [], this._radPower = [], this._network = [];
      for (let e4 = 0;e4 < this._networkSize; e4++)
        this._network[e4] = new Neuron((e4 << networkBiasShift + 8) / this._networkSize | 0), this._freq[e4] = _NeuQuant._initialBias / this._networkSize | 0, this._bias[e4] = 0;
    }
    *_learn() {
      let e4 = this._sampleFactor;
      const t = this._pointArray.length;
      t < _NeuQuant._minpicturebytes && (e4 = 1);
      const i = 30 + (e4 - 1) / 3 | 0, r = t / e4 | 0;
      let n, a = r / _NeuQuant._nCycles | 0, o = _NeuQuant._initAlpha, s = (this._networkSize >> 3) * _NeuQuant._radiusBias, l = s >> _NeuQuant._radiusBiasShift;
      l <= 1 && (l = 0);
      for (let e5 = 0;e5 < l; e5++)
        this._radPower[e5] = o * ((l * l - e5 * e5) * _NeuQuant._radBias / (l * l)) >>> 0;
      n = t < _NeuQuant._minpicturebytes ? 1 : t % _NeuQuant._prime1 != 0 ? _NeuQuant._prime1 : t % _NeuQuant._prime2 != 0 ? _NeuQuant._prime2 : t % _NeuQuant._prime3 != 0 ? _NeuQuant._prime3 : _NeuQuant._prime4;
      const u = new ProgressTracker(r, 99);
      for (let e5 = 0, h = 0;e5 < r; ) {
        u.shouldNotify(e5) && (yield { progress: u.progress });
        const r2 = this._pointArray[h], c = r2.b << networkBiasShift, f = r2.g << networkBiasShift, d = r2.r << networkBiasShift, p = r2.a << networkBiasShift, m = this._contest(c, f, d, p);
        if (this._alterSingle(o, m, c, f, d, p), l !== 0 && this._alterNeighbour(l, m, c, f, d, p), h += n, h >= t && (h -= t), e5++, a === 0 && (a = 1), e5 % a == 0) {
          o -= o / i | 0, s -= s / _NeuQuant._radiusDecrease | 0, l = s >> _NeuQuant._radiusBiasShift, l <= 1 && (l = 0);
          for (let e6 = 0;e6 < l; e6++)
            this._radPower[e6] = o * ((l * l - e6 * e6) * _NeuQuant._radBias / (l * l)) >>> 0;
        }
      }
    }
    _buildPalette() {
      const e4 = new Palette;
      return this._network.forEach((t) => {
        e4.add(t.toPoint());
      }), e4.sort(), e4;
    }
    _alterNeighbour(e4, t, i, r, n, a) {
      let o = t - e4;
      o < -1 && (o = -1);
      let s = t + e4;
      s > this._networkSize && (s = this._networkSize);
      let l = t + 1, u = t - 1, h = 1;
      for (;l < s || u > o; ) {
        const e5 = this._radPower[h++] / _NeuQuant._alphaRadBias;
        if (l < s) {
          const t2 = this._network[l++];
          t2.subtract(e5 * (t2.r - n), e5 * (t2.g - r), e5 * (t2.b - i), e5 * (t2.a - a));
        }
        if (u > o) {
          const t2 = this._network[u--];
          t2.subtract(e5 * (t2.r - n), e5 * (t2.g - r), e5 * (t2.b - i), e5 * (t2.a - a));
        }
      }
    }
    _alterSingle(e4, t, i, r, n, a) {
      e4 /= _NeuQuant._initAlpha;
      const o = this._network[t];
      o.subtract(e4 * (o.r - n), e4 * (o.g - r), e4 * (o.b - i), e4 * (o.a - a));
    }
    _contest(e4, t, i, r) {
      const n = 1020 << networkBiasShift;
      let a = ~(1 << 31), o = a, s = -1, l = s;
      for (let u = 0;u < this._networkSize; u++) {
        const h = this._network[u], c = this._distance.calculateNormalized(h, { r: i, g: t, b: e4, a: r }) * n | 0;
        c < a && (a = c, s = u);
        const f = c - (this._bias[u] >> _NeuQuant._initialBiasShift - networkBiasShift);
        f < o && (o = f, l = u);
        const d = this._freq[u] >> _NeuQuant._betaShift;
        this._freq[u] -= d, this._bias[u] += d << _NeuQuant._gammaShift;
      }
      return this._freq[s] += _NeuQuant._beta, this._bias[s] -= _NeuQuant._betaGamma, l;
    }
  };
  NeuQuant = _NeuQuant;
  __publicField(NeuQuant, "_prime1", 499), __publicField(NeuQuant, "_prime2", 491), __publicField(NeuQuant, "_prime3", 487), __publicField(NeuQuant, "_prime4", 503), __publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4), __publicField(NeuQuant, "_nCycles", 100), __publicField(NeuQuant, "_initialBiasShift", 16), __publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift), __publicField(NeuQuant, "_gammaShift", 10), __publicField(NeuQuant, "_betaShift", 10), __publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift), __publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift), __publicField(NeuQuant, "_radiusBiasShift", 6), __publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift), __publicField(NeuQuant, "_radiusDecrease", 30), __publicField(NeuQuant, "_alphaBiasShift", 10), __publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift), __publicField(NeuQuant, "_radBiasShift", 8), __publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift), __publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift), __publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);
  networkBiasShift2 = 3;
  NeuronFloat = class {
    constructor(e4) {
      __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), this.r = this.g = this.b = this.a = e4;
    }
    toPoint() {
      return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
    }
    subtract(e4, t, i, r) {
      this.r -= e4, this.g -= t, this.b -= i, this.a -= r;
    }
  };
  _NeuQuantFloat = class extends AbstractPaletteQuantizer {
    constructor(e4, t = 256) {
      super(), __publicField(this, "_pointArray"), __publicField(this, "_networkSize"), __publicField(this, "_network"), __publicField(this, "_sampleFactor"), __publicField(this, "_radPower"), __publicField(this, "_freq"), __publicField(this, "_bias"), __publicField(this, "_distance"), this._distance = e4, this._pointArray = [], this._sampleFactor = 1, this._networkSize = t, this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
    }
    sample(e4) {
      this._pointArray = this._pointArray.concat(e4.getPointArray());
    }
    *quantize() {
      this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
    }
    _init() {
      this._freq = [], this._bias = [], this._radPower = [], this._network = [];
      for (let e4 = 0;e4 < this._networkSize; e4++)
        this._network[e4] = new NeuronFloat((e4 << networkBiasShift2 + 8) / this._networkSize), this._freq[e4] = _NeuQuantFloat._initialBias / this._networkSize, this._bias[e4] = 0;
    }
    *_learn() {
      let e4 = this._sampleFactor;
      const t = this._pointArray.length;
      t < _NeuQuantFloat._minpicturebytes && (e4 = 1);
      const i = 30 + (e4 - 1) / 3, r = t / e4;
      let n, a = r / _NeuQuantFloat._nCycles | 0, o = _NeuQuantFloat._initAlpha, s = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias, l = s >> _NeuQuantFloat._radiusBiasShift;
      l <= 1 && (l = 0);
      for (let e5 = 0;e5 < l; e5++)
        this._radPower[e5] = o * ((l * l - e5 * e5) * _NeuQuantFloat._radBias / (l * l));
      n = t < _NeuQuantFloat._minpicturebytes ? 1 : t % _NeuQuantFloat._prime1 != 0 ? _NeuQuantFloat._prime1 : t % _NeuQuantFloat._prime2 != 0 ? _NeuQuantFloat._prime2 : t % _NeuQuantFloat._prime3 != 0 ? _NeuQuantFloat._prime3 : _NeuQuantFloat._prime4;
      const u = new ProgressTracker(r, 99);
      for (let e5 = 0, h = 0;e5 < r; ) {
        u.shouldNotify(e5) && (yield { progress: u.progress });
        const r2 = this._pointArray[h], c = r2.b << networkBiasShift2, f = r2.g << networkBiasShift2, d = r2.r << networkBiasShift2, p = r2.a << networkBiasShift2, m = this._contest(c, f, d, p);
        if (this._alterSingle(o, m, c, f, d, p), l !== 0 && this._alterNeighbour(l, m, c, f, d, p), h += n, h >= t && (h -= t), e5++, a === 0 && (a = 1), e5 % a == 0) {
          o -= o / i, s -= s / _NeuQuantFloat._radiusDecrease, l = s >> _NeuQuantFloat._radiusBiasShift, l <= 1 && (l = 0);
          for (let e6 = 0;e6 < l; e6++)
            this._radPower[e6] = o * ((l * l - e6 * e6) * _NeuQuantFloat._radBias / (l * l));
        }
      }
    }
    _buildPalette() {
      const e4 = new Palette;
      return this._network.forEach((t) => {
        e4.add(t.toPoint());
      }), e4.sort(), e4;
    }
    _alterNeighbour(e4, t, i, r, n, a) {
      let o = t - e4;
      o < -1 && (o = -1);
      let s = t + e4;
      s > this._networkSize && (s = this._networkSize);
      let l = t + 1, u = t - 1, h = 1;
      for (;l < s || u > o; ) {
        const e5 = this._radPower[h++] / _NeuQuantFloat._alphaRadBias;
        if (l < s) {
          const t2 = this._network[l++];
          t2.subtract(e5 * (t2.r - n), e5 * (t2.g - r), e5 * (t2.b - i), e5 * (t2.a - a));
        }
        if (u > o) {
          const t2 = this._network[u--];
          t2.subtract(e5 * (t2.r - n), e5 * (t2.g - r), e5 * (t2.b - i), e5 * (t2.a - a));
        }
      }
    }
    _alterSingle(e4, t, i, r, n, a) {
      e4 /= _NeuQuantFloat._initAlpha;
      const o = this._network[t];
      o.subtract(e4 * (o.r - n), e4 * (o.g - r), e4 * (o.b - i), e4 * (o.a - a));
    }
    _contest(e4, t, i, r) {
      const n = 1020 << networkBiasShift2;
      let a = ~(1 << 31), o = a, s = -1, l = s;
      for (let u = 0;u < this._networkSize; u++) {
        const h = this._network[u], c = this._distance.calculateNormalized(h, { r: i, g: t, b: e4, a: r }) * n;
        c < a && (a = c, s = u);
        const f = c - (this._bias[u] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
        f < o && (o = f, l = u);
        const d = this._freq[u] >> _NeuQuantFloat._betaShift;
        this._freq[u] -= d, this._bias[u] += d << _NeuQuantFloat._gammaShift;
      }
      return this._freq[s] += _NeuQuantFloat._beta, this._bias[s] -= _NeuQuantFloat._betaGamma, l;
    }
  };
  NeuQuantFloat = _NeuQuantFloat;
  __publicField(NeuQuantFloat, "_prime1", 499), __publicField(NeuQuantFloat, "_prime2", 491), __publicField(NeuQuantFloat, "_prime3", 487), __publicField(NeuQuantFloat, "_prime4", 503), __publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4), __publicField(NeuQuantFloat, "_nCycles", 100), __publicField(NeuQuantFloat, "_initialBiasShift", 16), __publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift), __publicField(NeuQuantFloat, "_gammaShift", 10), __publicField(NeuQuantFloat, "_betaShift", 10), __publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift), __publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift), __publicField(NeuQuantFloat, "_radiusBiasShift", 6), __publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift), __publicField(NeuQuantFloat, "_radiusDecrease", 30), __publicField(NeuQuantFloat, "_alphaBiasShift", 10), __publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift), __publicField(NeuQuantFloat, "_radBiasShift", 8), __publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift), __publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift), __publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);
  _ColorHistogram = class {
    constructor(e4, t) {
      __publicField(this, "_method"), __publicField(this, "_hueStats"), __publicField(this, "_histogram"), __publicField(this, "_initColors"), __publicField(this, "_minHueCols"), this._method = e4, this._minHueCols = t << 2, this._initColors = t << 2, this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols), this._histogram = Object.create(null);
    }
    sample(e4) {
      switch (this._method) {
        case 1:
          this._colorStats1D(e4);
          break;
        case 2:
          this._colorStats2D(e4);
      }
    }
    getImportanceSortedColorsIDXI32() {
      const e4 = stableSort(Object.keys(this._histogram), (e5, t2) => this._histogram[t2] - this._histogram[e5]);
      if (e4.length === 0)
        return [];
      let t;
      switch (this._method) {
        case 1:
          const i = Math.min(e4.length, this._initColors), r = e4[i - 1], n = this._histogram[r];
          t = e4.slice(0, i);
          let a = i;
          const o = e4.length;
          for (;a < o && this._histogram[e4[a]] === n; )
            t.push(e4[a++]);
          this._hueStats.injectIntoArray(t);
          break;
        case 2:
          t = e4;
          break;
        default:
          throw new Error("Incorrect method");
      }
      return t.map((e5) => +e5);
    }
    _colorStats1D(e4) {
      const t = this._histogram, i = e4.getPointArray(), r = i.length;
      for (let e5 = 0;e5 < r; e5++) {
        const r2 = i[e5].uint32;
        this._hueStats.check(r2), r2 in t ? t[r2]++ : t[r2] = 1;
      }
    }
    _colorStats2D(e4) {
      const t = e4.getWidth(), i = e4.getHeight(), r = e4.getPointArray(), n = _ColorHistogram._boxSize[0], a = _ColorHistogram._boxSize[1], o = n * a, s = this._makeBoxes(t, i, n, a), l = this._histogram;
      s.forEach((e5) => {
        let i2 = Math.round(e5.w * e5.h / o) * _ColorHistogram._boxPixels;
        i2 < 2 && (i2 = 2);
        const n2 = {};
        this._iterateBox(e5, t, (e6) => {
          const t2 = r[e6].uint32;
          this._hueStats.check(t2), t2 in l ? l[t2]++ : (t2 in n2) ? ++n2[t2] >= i2 && (l[t2] = n2[t2]) : n2[t2] = 1;
        });
      }), this._hueStats.injectIntoDictionary(l);
    }
    _iterateBox(e4, t, i) {
      const r = e4, n = r.y * t + r.x, a = (r.y + r.h - 1) * t + (r.x + r.w - 1), o = t - r.w + 1;
      let s = 0, l = n;
      do {
        i.call(this, l), l += ++s % r.w == 0 ? o : 1;
      } while (l <= a);
    }
    _makeBoxes(e4, t, i, r) {
      const n = e4 % i, a = t % r, o = e4 - n, s = t - a, l = [];
      for (let u = 0;u < t; u += r)
        for (let t2 = 0;t2 < e4; t2 += i)
          l.push({ x: t2, y: u, w: t2 === o ? n : i, h: u === s ? a : r });
      return l;
    }
  };
  ColorHistogram = _ColorHistogram;
  __publicField(ColorHistogram, "_boxSize", [64, 64]), __publicField(ColorHistogram, "_boxPixels", 2), __publicField(ColorHistogram, "_hueGroups", 10);
  RemovedColor = class {
    constructor(e4, t, i) {
      __publicField(this, "index"), __publicField(this, "color"), __publicField(this, "distance"), this.index = e4, this.color = t, this.distance = i;
    }
  };
  RGBQuant = class extends AbstractPaletteQuantizer {
    constructor(e4, t = 256, i = 2) {
      super(), __publicField(this, "_colors"), __publicField(this, "_initialDistance"), __publicField(this, "_distanceIncrement"), __publicField(this, "_histogram"), __publicField(this, "_distance"), this._distance = e4, this._colors = t, this._histogram = new ColorHistogram(i, t), this._initialDistance = 0.01, this._distanceIncrement = 0.005;
    }
    sample(e4) {
      this._histogram.sample(e4);
    }
    *quantize() {
      const e4 = this._histogram.getImportanceSortedColorsIDXI32();
      if (e4.length === 0)
        throw new Error("No colors in image");
      yield* this._buildPalette(e4);
    }
    *_buildPalette(e4) {
      const t = new Palette, i = t.getPointContainer().getPointArray(), r = new Array(e4.length);
      for (let t2 = 0;t2 < e4.length; t2++)
        i.push(Point.createByUint32(e4[t2])), r[t2] = 1;
      const n = i.length, a = [];
      let o = n, s = this._initialDistance;
      const l = new ProgressTracker(o - this._colors, 99);
      for (;o > this._colors; ) {
        a.length = 0;
        for (let e5 = 0;e5 < n; e5++) {
          if (l.shouldNotify(n - o) && (yield { progress: l.progress }), r[e5] === 0)
            continue;
          const t2 = i[e5];
          for (let l2 = e5 + 1;l2 < n; l2++) {
            if (r[l2] === 0)
              continue;
            const e6 = i[l2], n2 = this._distance.calculateNormalized(t2, e6);
            n2 < s && (a.push(new RemovedColor(l2, e6, n2)), r[l2] = 0, o--);
          }
        }
        s += o > 3 * this._colors ? this._initialDistance : this._distanceIncrement;
      }
      if (o < this._colors) {
        stableSort(a, (e6, t2) => t2.distance - e6.distance);
        let e5 = 0;
        for (;o < this._colors && e5 < a.length; ) {
          r[a[e5].index] = 1, o++, e5++;
        }
      }
      let u = i.length;
      for (let e5 = u - 1;e5 >= 0; e5--)
        r[e5] === 0 && (e5 !== u - 1 && (i[e5] = i[u - 1]), --u);
      i.length = u, t.sort(), yield { palette: t, progress: 100 };
    }
  };
  WuColorCube = class {
    constructor() {
      __publicField(this, "redMinimum"), __publicField(this, "redMaximum"), __publicField(this, "greenMinimum"), __publicField(this, "greenMaximum"), __publicField(this, "blueMinimum"), __publicField(this, "blueMaximum"), __publicField(this, "volume"), __publicField(this, "alphaMinimum"), __publicField(this, "alphaMaximum");
    }
  };
  _WuQuant = class extends AbstractPaletteQuantizer {
    constructor(e4, t = 256, i = 5) {
      super(), __publicField(this, "_reds"), __publicField(this, "_greens"), __publicField(this, "_blues"), __publicField(this, "_alphas"), __publicField(this, "_sums"), __publicField(this, "_weights"), __publicField(this, "_momentsRed"), __publicField(this, "_momentsGreen"), __publicField(this, "_momentsBlue"), __publicField(this, "_momentsAlpha"), __publicField(this, "_moments"), __publicField(this, "_table"), __publicField(this, "_pixels"), __publicField(this, "_cubes"), __publicField(this, "_colors"), __publicField(this, "_significantBitsPerChannel"), __publicField(this, "_maxSideIndex"), __publicField(this, "_alphaMaxSideIndex"), __publicField(this, "_sideSize"), __publicField(this, "_alphaSideSize"), __publicField(this, "_distance"), this._distance = e4, this._setQuality(i), this._initialize(t);
    }
    sample(e4) {
      const t = e4.getPointArray();
      for (let e5 = 0, i = t.length;e5 < i; e5++)
        this._addColor(t[e5]);
      this._pixels = this._pixels.concat(t);
    }
    *quantize() {
      yield* this._preparePalette();
      const e4 = new Palette;
      for (let t = 0;t < this._colors; t++)
        if (this._sums[t] > 0) {
          const i = this._sums[t], r = this._reds[t] / i, n = this._greens[t] / i, a = this._blues[t] / i, o = this._alphas[t] / i, s = Point.createByRGBA(0 | r, 0 | n, 0 | a, 0 | o);
          e4.add(s);
        }
      e4.sort(), yield { palette: e4, progress: 100 };
    }
    *_preparePalette() {
      yield* this._calculateMoments();
      let e4 = 0;
      const t = createArray1D(this._colors);
      for (let i2 = 1;i2 < this._colors; ++i2) {
        this._cut(this._cubes[e4], this._cubes[i2]) ? (t[e4] = this._cubes[e4].volume > 1 ? this._calculateVariance(this._cubes[e4]) : 0, t[i2] = this._cubes[i2].volume > 1 ? this._calculateVariance(this._cubes[i2]) : 0) : (t[e4] = 0, i2--), e4 = 0;
        let r2 = t[0];
        for (let n2 = 1;n2 <= i2; ++n2)
          t[n2] > r2 && (r2 = t[n2], e4 = n2);
        if (r2 <= 0) {
          this._colors = i2 + 1;
          break;
        }
      }
      const i = [], r = [], n = [], a = [];
      for (let e5 = 0;e5 < this._colors; ++e5) {
        const t2 = _WuQuant._volume(this._cubes[e5], this._weights);
        t2 > 0 ? (i[e5] = _WuQuant._volume(this._cubes[e5], this._momentsRed) / t2 | 0, r[e5] = _WuQuant._volume(this._cubes[e5], this._momentsGreen) / t2 | 0, n[e5] = _WuQuant._volume(this._cubes[e5], this._momentsBlue) / t2 | 0, a[e5] = _WuQuant._volume(this._cubes[e5], this._momentsAlpha) / t2 | 0) : (i[e5] = 0, r[e5] = 0, n[e5] = 0, a[e5] = 0);
      }
      this._reds = createArray1D(this._colors + 1), this._greens = createArray1D(this._colors + 1), this._blues = createArray1D(this._colors + 1), this._alphas = createArray1D(this._colors + 1), this._sums = createArray1D(this._colors + 1);
      for (let e5 = 0, t2 = this._pixels.length;e5 < t2; e5++) {
        const t3 = this._pixels[e5];
        let o = -1, s = Number.MAX_VALUE;
        for (let e6 = 0;e6 < this._colors; e6++) {
          const l = i[e6], u = r[e6], h = n[e6], c = a[e6], f = this._distance.calculateRaw(l, u, h, c, t3.r, t3.g, t3.b, t3.a);
          f < s && (s = f, o = e6);
        }
        this._reds[o] += t3.r, this._greens[o] += t3.g, this._blues[o] += t3.b, this._alphas[o] += t3.a, this._sums[o]++;
      }
    }
    _addColor(e4) {
      const t = 8 - this._significantBitsPerChannel, i = 1 + (e4.r >> t), r = 1 + (e4.g >> t), n = 1 + (e4.b >> t), a = 1 + (e4.a >> t);
      this._weights[a][i][r][n]++, this._momentsRed[a][i][r][n] += e4.r, this._momentsGreen[a][i][r][n] += e4.g, this._momentsBlue[a][i][r][n] += e4.b, this._momentsAlpha[a][i][r][n] += e4.a, this._moments[a][i][r][n] += this._table[e4.r] + this._table[e4.g] + this._table[e4.b] + this._table[e4.a];
    }
    *_calculateMoments() {
      const e4 = [], t = [], i = [], r = [], n = [], a = [], o = createArray3D(this._sideSize, this._sideSize, this._sideSize), s = createArray3D(this._sideSize, this._sideSize, this._sideSize), l = createArray3D(this._sideSize, this._sideSize, this._sideSize), u = createArray3D(this._sideSize, this._sideSize, this._sideSize), h = createArray3D(this._sideSize, this._sideSize, this._sideSize), c = createArray3D(this._sideSize, this._sideSize, this._sideSize);
      let f = 0;
      const d = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
      for (let p = 1;p <= this._alphaMaxSideIndex; ++p) {
        fillArray3D(o, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(s, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(l, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(u, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(h, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(c, this._sideSize, this._sideSize, this._sideSize, 0);
        for (let m = 1;m <= this._maxSideIndex; ++m, ++f) {
          d.shouldNotify(f) && (yield { progress: d.progress }), fillArray1D(e4, this._sideSize, 0), fillArray1D(t, this._sideSize, 0), fillArray1D(i, this._sideSize, 0), fillArray1D(r, this._sideSize, 0), fillArray1D(n, this._sideSize, 0), fillArray1D(a, this._sideSize, 0);
          for (let f2 = 1;f2 <= this._maxSideIndex; ++f2) {
            let d2 = 0, _ = 0, g = 0, b2 = 0, y = 0, w = 0;
            for (let v = 1;v <= this._maxSideIndex; ++v)
              d2 += this._weights[p][m][f2][v], _ += this._momentsRed[p][m][f2][v], g += this._momentsGreen[p][m][f2][v], b2 += this._momentsBlue[p][m][f2][v], y += this._momentsAlpha[p][m][f2][v], w += this._moments[p][m][f2][v], e4[v] += d2, t[v] += _, i[v] += g, r[v] += b2, n[v] += y, a[v] += w, o[m][f2][v] = o[m - 1][f2][v] + e4[v], s[m][f2][v] = s[m - 1][f2][v] + t[v], l[m][f2][v] = l[m - 1][f2][v] + i[v], u[m][f2][v] = u[m - 1][f2][v] + r[v], h[m][f2][v] = h[m - 1][f2][v] + n[v], c[m][f2][v] = c[m - 1][f2][v] + a[v], this._weights[p][m][f2][v] = this._weights[p - 1][m][f2][v] + o[m][f2][v], this._momentsRed[p][m][f2][v] = this._momentsRed[p - 1][m][f2][v] + s[m][f2][v], this._momentsGreen[p][m][f2][v] = this._momentsGreen[p - 1][m][f2][v] + l[m][f2][v], this._momentsBlue[p][m][f2][v] = this._momentsBlue[p - 1][m][f2][v] + u[m][f2][v], this._momentsAlpha[p][m][f2][v] = this._momentsAlpha[p - 1][m][f2][v] + h[m][f2][v], this._moments[p][m][f2][v] = this._moments[p - 1][m][f2][v] + c[m][f2][v];
          }
        }
      }
    }
    static _volumeFloat(e4, t) {
      return t[e4.alphaMaximum][e4.redMaximum][e4.greenMaximum][e4.blueMaximum] - t[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] - t[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] + t[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - t[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMaximum] + t[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] + t[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] - t[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (t[e4.alphaMaximum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] - t[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] - t[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + t[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] - t[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] + t[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] + t[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum] - t[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
    }
    static _volume(e4, t) {
      return 0 | _WuQuant._volumeFloat(e4, t);
    }
    static _top(e4, t, i, r) {
      let n;
      switch (t) {
        case _WuQuant._alpha:
          n = r[i][e4.redMaximum][e4.greenMaximum][e4.blueMaximum] - r[i][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] - r[i][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] + r[i][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (r[i][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] - r[i][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] - r[i][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] + r[i][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
          break;
        case _WuQuant._red:
          n = r[e4.alphaMaximum][i][e4.greenMaximum][e4.blueMaximum] - r[e4.alphaMaximum][i][e4.greenMinimum][e4.blueMaximum] - r[e4.alphaMinimum][i][e4.greenMaximum][e4.blueMaximum] + r[e4.alphaMinimum][i][e4.greenMinimum][e4.blueMaximum] - (r[e4.alphaMaximum][i][e4.greenMaximum][e4.blueMinimum] - r[e4.alphaMaximum][i][e4.greenMinimum][e4.blueMinimum] - r[e4.alphaMinimum][i][e4.greenMaximum][e4.blueMinimum] + r[e4.alphaMinimum][i][e4.greenMinimum][e4.blueMinimum]);
          break;
        case _WuQuant._green:
          n = r[e4.alphaMaximum][e4.redMaximum][i][e4.blueMaximum] - r[e4.alphaMaximum][e4.redMinimum][i][e4.blueMaximum] - r[e4.alphaMinimum][e4.redMaximum][i][e4.blueMaximum] + r[e4.alphaMinimum][e4.redMinimum][i][e4.blueMaximum] - (r[e4.alphaMaximum][e4.redMaximum][i][e4.blueMinimum] - r[e4.alphaMaximum][e4.redMinimum][i][e4.blueMinimum] - r[e4.alphaMinimum][e4.redMaximum][i][e4.blueMinimum] + r[e4.alphaMinimum][e4.redMinimum][i][e4.blueMinimum]);
          break;
        case _WuQuant._blue:
          n = r[e4.alphaMaximum][e4.redMaximum][e4.greenMaximum][i] - r[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][i] - r[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][i] + r[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][i] - (r[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][i] - r[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][i] - r[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][i] + r[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][i]);
          break;
        default:
          throw new Error("impossible");
      }
      return 0 | n;
    }
    static _bottom(e4, t, i) {
      switch (t) {
        case _WuQuant._alpha:
          return -i[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMaximum] + i[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] + i[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] - i[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (-i[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] + i[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + i[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] - i[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
        case _WuQuant._red:
          return -i[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] + i[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] + i[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] - i[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (-i[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] + i[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum] + i[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] - i[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
        case _WuQuant._green:
          return -i[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] + i[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] + i[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] - i[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (-i[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + i[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum] + i[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] - i[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
        case _WuQuant._blue:
          return -i[e4.alphaMaximum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] + i[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + i[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] - i[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum] - (-i[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] + i[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + i[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] - i[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
        default:
          return 0;
      }
    }
    _calculateVariance(e4) {
      const t = _WuQuant._volume(e4, this._momentsRed), i = _WuQuant._volume(e4, this._momentsGreen), r = _WuQuant._volume(e4, this._momentsBlue), n = _WuQuant._volume(e4, this._momentsAlpha);
      return _WuQuant._volumeFloat(e4, this._moments) - (t * t + i * i + r * r + n * n) / _WuQuant._volume(e4, this._weights);
    }
    _maximize(e4, t, i, r, n, a, o, s, l) {
      const u = 0 | _WuQuant._bottom(e4, t, this._momentsRed), h = 0 | _WuQuant._bottom(e4, t, this._momentsGreen), c = 0 | _WuQuant._bottom(e4, t, this._momentsBlue), f = 0 | _WuQuant._bottom(e4, t, this._momentsAlpha), d = 0 | _WuQuant._bottom(e4, t, this._weights);
      let p = 0, m = -1;
      for (let _ = i;_ < r; ++_) {
        let i2 = u + _WuQuant._top(e4, t, _, this._momentsRed), r2 = h + _WuQuant._top(e4, t, _, this._momentsGreen), g = c + _WuQuant._top(e4, t, _, this._momentsBlue), b2 = f + _WuQuant._top(e4, t, _, this._momentsAlpha), y = d + _WuQuant._top(e4, t, _, this._weights);
        if (y !== 0) {
          let e5 = i2 * i2 + r2 * r2 + g * g + b2 * b2, t2 = e5 / y;
          i2 = n - i2, r2 = a - r2, g = o - g, b2 = s - b2, y = l - y, y !== 0 && (e5 = i2 * i2 + r2 * r2 + g * g + b2 * b2, t2 += e5 / y, t2 > p && (p = t2, m = _));
        }
      }
      return { max: p, position: m };
    }
    _cut(e4, t) {
      let i;
      const r = _WuQuant._volume(e4, this._momentsRed), n = _WuQuant._volume(e4, this._momentsGreen), a = _WuQuant._volume(e4, this._momentsBlue), o = _WuQuant._volume(e4, this._momentsAlpha), s = _WuQuant._volume(e4, this._weights), l = this._maximize(e4, _WuQuant._red, e4.redMinimum + 1, e4.redMaximum, r, n, a, o, s), u = this._maximize(e4, _WuQuant._green, e4.greenMinimum + 1, e4.greenMaximum, r, n, a, o, s), h = this._maximize(e4, _WuQuant._blue, e4.blueMinimum + 1, e4.blueMaximum, r, n, a, o, s), c = this._maximize(e4, _WuQuant._alpha, e4.alphaMinimum + 1, e4.alphaMaximum, r, n, a, o, s);
      if (c.max >= l.max && c.max >= u.max && c.max >= h.max) {
        if (i = _WuQuant._alpha, c.position < 0)
          return false;
      } else
        i = l.max >= c.max && l.max >= u.max && l.max >= h.max ? _WuQuant._red : u.max >= c.max && u.max >= l.max && u.max >= h.max ? _WuQuant._green : _WuQuant._blue;
      switch (t.redMaximum = e4.redMaximum, t.greenMaximum = e4.greenMaximum, t.blueMaximum = e4.blueMaximum, t.alphaMaximum = e4.alphaMaximum, i) {
        case _WuQuant._red:
          t.redMinimum = e4.redMaximum = l.position, t.greenMinimum = e4.greenMinimum, t.blueMinimum = e4.blueMinimum, t.alphaMinimum = e4.alphaMinimum;
          break;
        case _WuQuant._green:
          t.greenMinimum = e4.greenMaximum = u.position, t.redMinimum = e4.redMinimum, t.blueMinimum = e4.blueMinimum, t.alphaMinimum = e4.alphaMinimum;
          break;
        case _WuQuant._blue:
          t.blueMinimum = e4.blueMaximum = h.position, t.redMinimum = e4.redMinimum, t.greenMinimum = e4.greenMinimum, t.alphaMinimum = e4.alphaMinimum;
          break;
        case _WuQuant._alpha:
          t.alphaMinimum = e4.alphaMaximum = c.position, t.blueMinimum = e4.blueMinimum, t.redMinimum = e4.redMinimum, t.greenMinimum = e4.greenMinimum;
      }
      return e4.volume = (e4.redMaximum - e4.redMinimum) * (e4.greenMaximum - e4.greenMinimum) * (e4.blueMaximum - e4.blueMinimum) * (e4.alphaMaximum - e4.alphaMinimum), t.volume = (t.redMaximum - t.redMinimum) * (t.greenMaximum - t.greenMinimum) * (t.blueMaximum - t.blueMinimum) * (t.alphaMaximum - t.alphaMinimum), true;
    }
    _initialize(e4) {
      this._colors = e4, this._cubes = [];
      for (let t = 0;t < e4; t++)
        this._cubes[t] = new WuColorCube;
      this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
      for (let e5 = 0;e5 < 256; ++e5)
        this._table[e5] = e5 * e5;
      this._pixels = [];
    }
    _setQuality(e4 = 5) {
      this._significantBitsPerChannel = e4, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
    }
  };
  WuQuant = _WuQuant;
  __publicField(WuQuant, "_alpha", 3), __publicField(WuQuant, "_red", 2), __publicField(WuQuant, "_green", 1), __publicField(WuQuant, "_blue", 0);
  image_exports = {};
  __export2(image_exports, { AbstractImageQuantizer: () => AbstractImageQuantizer, ErrorDiffusionArray: () => ErrorDiffusionArray, ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel, ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma, NearestColor: () => NearestColor });
  AbstractImageQuantizer = class {
    quantizeSync(e4, t) {
      for (const i of this.quantize(e4, t))
        if (i.pointContainer)
          return i.pointContainer;
      throw new Error("unreachable");
    }
  };
  NearestColor = class extends AbstractImageQuantizer {
    constructor(e4) {
      super(), __publicField(this, "_distance"), this._distance = e4;
    }
    *quantize(e4, t) {
      const i = e4.getPointArray(), r = e4.getWidth(), n = e4.getHeight(), a = new ProgressTracker(n, 99);
      for (let e5 = 0;e5 < n; e5++) {
        a.shouldNotify(e5) && (yield { progress: a.progress });
        for (let n2 = 0, a2 = e5 * r;n2 < r; n2++, a2++) {
          const e6 = i[a2];
          e6.from(t.getNearestColor(this._distance, e6));
        }
      }
      yield { pointContainer: e4, progress: 100 };
    }
  };
  ErrorDiffusionArrayKernel = ((e4) => (e4[e4.FloydSteinberg = 0] = "FloydSteinberg", e4[e4.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", e4[e4.Stucki = 2] = "Stucki", e4[e4.Atkinson = 3] = "Atkinson", e4[e4.Jarvis = 4] = "Jarvis", e4[e4.Burkes = 5] = "Burkes", e4[e4.Sierra = 6] = "Sierra", e4[e4.TwoSierra = 7] = "TwoSierra", e4[e4.SierraLite = 8] = "SierraLite", e4))(ErrorDiffusionArrayKernel || {});
  ErrorDiffusionArray = class extends AbstractImageQuantizer {
    constructor(e4, t, i = true, r = 0, n = false) {
      super(), __publicField(this, "_minColorDistance"), __publicField(this, "_serpentine"), __publicField(this, "_kernel"), __publicField(this, "_calculateErrorLikeGIMP"), __publicField(this, "_distance"), this._setKernel(t), this._distance = e4, this._minColorDistance = r, this._serpentine = i, this._calculateErrorLikeGIMP = n;
    }
    *quantize(e4, t) {
      const i = e4.getPointArray(), r = new Point, n = e4.getWidth(), a = e4.getHeight(), o = [];
      let s = 1, l = 1;
      for (const e5 of this._kernel) {
        const t2 = e5[2] + 1;
        l < t2 && (l = t2);
      }
      for (let e5 = 0;e5 < l; e5++)
        this._fillErrorLine(o[e5] = [], n);
      const u = new ProgressTracker(a, 99);
      for (let e5 = 0;e5 < a; e5++) {
        u.shouldNotify(e5) && (yield { progress: u.progress }), this._serpentine && (s *= -1);
        const l2 = e5 * n, h = s === 1 ? 0 : n - 1, c = s === 1 ? n : -1;
        this._fillErrorLine(o[0], n), o.push(o.shift());
        const f = o[0];
        for (let u2 = h, d = l2 + h;u2 !== c; u2 += s, d += s) {
          const l3 = i[d], h2 = f[u2];
          r.from(l3);
          const c2 = Point.createByRGBA(inRange0to255Rounded(l3.r + h2[0]), inRange0to255Rounded(l3.g + h2[1]), inRange0to255Rounded(l3.b + h2[2]), inRange0to255Rounded(l3.a + h2[3])), p = t.getNearestColor(this._distance, c2);
          if (l3.from(p), this._minColorDistance) {
            if (this._distance.calculateNormalized(r, p) < this._minColorDistance)
              continue;
          }
          let m, _, g, b2;
          this._calculateErrorLikeGIMP ? (m = c2.r - p.r, _ = c2.g - p.g, g = c2.b - p.b, b2 = c2.a - p.a) : (m = r.r - p.r, _ = r.g - p.g, g = r.b - p.b, b2 = r.a - p.a);
          const y = s === 1 ? 0 : this._kernel.length - 1, w = s === 1 ? this._kernel.length : -1;
          for (let t2 = y;t2 !== w; t2 += s) {
            const i2 = this._kernel[t2][1] * s, r2 = this._kernel[t2][2];
            if (i2 + u2 >= 0 && i2 + u2 < n && r2 + e5 >= 0 && r2 + e5 < a) {
              const e6 = this._kernel[t2][0], n2 = o[r2][i2 + u2];
              n2[0] += m * e6, n2[1] += _ * e6, n2[2] += g * e6, n2[3] += b2 * e6;
            }
          }
        }
      }
      yield { pointContainer: e4, progress: 100 };
    }
    _fillErrorLine(e4, t) {
      e4.length > t && (e4.length = t);
      const i = e4.length;
      for (let t2 = 0;t2 < i; t2++) {
        const i2 = e4[t2];
        i2[0] = i2[1] = i2[2] = i2[3] = 0;
      }
      for (let r = i;r < t; r++)
        e4[r] = [0, 0, 0, 0];
    }
    _setKernel(e4) {
      switch (e4) {
        case 0:
          this._kernel = [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]];
          break;
        case 1:
          this._kernel = [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]];
          break;
        case 2:
          this._kernel = [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]];
          break;
        case 3:
          this._kernel = [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]];
          break;
        case 4:
          this._kernel = [[7 / 48, 1, 0], [5 / 48, 2, 0], [3 / 48, -2, 1], [5 / 48, -1, 1], [7 / 48, 0, 1], [5 / 48, 1, 1], [3 / 48, 2, 1], [1 / 48, -2, 2], [3 / 48, -1, 2], [5 / 48, 0, 2], [3 / 48, 1, 2], [1 / 48, 2, 2]];
          break;
        case 5:
          this._kernel = [[0.25, 1, 0], [4 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [0.25, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1]];
          break;
        case 6:
          this._kernel = [[5 / 32, 1, 0], [3 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [5 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1], [2 / 32, -1, 2], [3 / 32, 0, 2], [2 / 32, 1, 2]];
          break;
        case 7:
          this._kernel = [[0.25, 1, 0], [3 / 16, 2, 0], [1 / 16, -2, 1], [2 / 16, -1, 1], [3 / 16, 0, 1], [2 / 16, 1, 1], [1 / 16, 2, 1]];
          break;
        case 8:
          this._kernel = [[0.5, 1, 0], [1 / 4, -1, 1], [1 / 4, 0, 1]];
          break;
        default:
          throw new Error(`ErrorDiffusionArray: unknown kernel = ${e4}`);
      }
    }
  };
  ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
    constructor(e4, t = 16, i = 1) {
      super(), __publicField(this, "_distance"), __publicField(this, "_weights"), __publicField(this, "_errorQueueSize"), this._distance = e4, this._errorQueueSize = t, this._weights = ErrorDiffusionRiemersma._createWeights(i, t);
    }
    *quantize(e4, t) {
      const i = e4.getPointArray(), r = e4.getWidth(), n = e4.getHeight(), a = [];
      let o = 0;
      for (let e5 = 0;e5 < this._errorQueueSize; e5++)
        a[e5] = { r: 0, g: 0, b: 0, a: 0 };
      yield* hilbertCurve(r, n, (e5, n2) => {
        const s = i[e5 + n2 * r];
        let { r: l, g: u, b: h, a: c } = s;
        for (let e6 = 0;e6 < this._errorQueueSize; e6++) {
          const t2 = this._weights[e6], i2 = a[(e6 + o) % this._errorQueueSize];
          l += i2.r * t2, u += i2.g * t2, h += i2.b * t2, c += i2.a * t2;
        }
        const f = Point.createByRGBA(inRange0to255Rounded(l), inRange0to255Rounded(u), inRange0to255Rounded(h), inRange0to255Rounded(c)), d = t.getNearestColor(this._distance, f);
        o = (o + 1) % this._errorQueueSize;
        const p = (o + this._errorQueueSize - 1) % this._errorQueueSize;
        a[p].r = s.r - d.r, a[p].g = s.g - d.g, a[p].b = s.b - d.b, a[p].a = s.a - d.a, s.from(d);
      }), yield { pointContainer: e4, progress: 100 };
    }
    static _createWeights(e4, t) {
      const i = [], r = Math.exp(Math.log(t) / (t - 1));
      for (let n = 0, a = 1;n < t; n++)
        i[n] = (a + 0.5 | 0) / t * e4, a *= r;
      return i;
    }
  };
  quality_exports = {};
  __export2(quality_exports, { ssim: () => ssim });
  K1 = 0.01;
  K2 = 0.03;
  typeof setImmediate == "function" ? setImmediate : typeof process != "undefined" && (process == null || process.nextTick);
  QuantizeOptionsSchema = z.object({ colors: z.number().optional(), colorDistanceFormula: z.union([z.literal("cie94-textiles"), z.literal("cie94-graphic-arts"), z.literal("ciede2000"), z.literal("color-metric"), z.literal("euclidean"), z.literal("euclidean-bt709-noalpha"), z.literal("euclidean-bt709"), z.literal("manhattan"), z.literal("manhattan-bt709"), z.literal("manhattan-nommyde"), z.literal("pngquant")]).optional(), paletteQuantization: z.union([z.literal("neuquant"), z.literal("neuquant-float"), z.literal("rgbquant"), z.literal("wuquant")]).optional(), imageQuantization: z.union([z.literal("nearest"), z.literal("riemersma"), z.literal("floyd-steinberg"), z.literal("false-floyd-steinberg"), z.literal("stucki"), z.literal("atkinson"), z.literal("jarvis"), z.literal("burkes"), z.literal("sierra"), z.literal("two-sierra"), z.literal("sierra-lite")]).optional() });
  methods = { quantize(e4, t) {
    const { colors: i, colorDistanceFormula: r, paletteQuantization: n, imageQuantization: a } = QuantizeOptionsSchema.parse(t), o = utils_exports.PointContainer.fromUint8Array(e4.bitmap.data, e4.bitmap.width, e4.bitmap.height), s = applyPaletteSync(o, buildPaletteSync([o], { colors: i, colorDistanceFormula: r, paletteQuantization: n }), { colorDistanceFormula: r, imageQuantization: a });
    return e4.bitmap.data = Buffer2.from(s.toUint8Array()), e4;
  } };
  parseBmfontAscii = function(e4) {
    if (!e4)
      throw new Error("no data provided");
    var t = { pages: [], chars: [], kernings: [] }, i = (e4 = e4.toString().trim()).split(/\r\n?|\n/g);
    if (i.length === 0)
      throw new Error("no data in BMFont file");
    for (var r = 0;r < i.length; r++) {
      var n = splitLine(i[r], r);
      if (n)
        if (n.key === "page") {
          if (typeof n.data.id != "number")
            throw new Error("malformed file at line " + r + " -- needs page id=N");
          if (typeof n.data.file != "string")
            throw new Error("malformed file at line " + r + ' -- needs page file="path"');
          t.pages[n.data.id] = n.data.file;
        } else
          n.key === "chars" || n.key === "kernings" || (n.key === "char" ? t.chars.push(n.data) : n.key === "kerning" ? t.kernings.push(n.data) : t[n.key] = n.data);
    }
    return t;
  };
  parseASCII = getDefaultExportFromCjs(parseBmfontAscii);
  GLYPH_DESIGNER_ERROR = "chasrset";
  parseAttribs = function(e4) {
    for (var t in e4 = Object.assign({}, e4), GLYPH_DESIGNER_ERROR in e4 && (e4.charset = e4[GLYPH_DESIGNER_ERROR], delete e4[GLYPH_DESIGNER_ERROR]), e4)
      t !== "face" && t !== "charset" && (e4[t] = t === "padding" || t === "spacing" ? parseIntList(e4[t]) : parseInt(e4[t], 10));
    return e4;
  };
  xmlParseFromString = self.DOMParser !== undefined ? function(e4) {
    return new self.DOMParser().parseFromString(e4, "application/xml");
  } : self.ActiveXObject !== undefined && new self.ActiveXObject("Microsoft.XMLDOM") ? function(e4) {
    var t = new self.ActiveXObject("Microsoft.XMLDOM");
    return t.async = "false", t.loadXML(e4), t;
  } : function(e4) {
    var t = document.createElement("div");
    return t.innerHTML = e4, t;
  };
  parseAttributes = parseAttribs;
  parseFromString = xmlParseFromString;
  NAME_MAP = { scaleh: "scaleH", scalew: "scaleW", stretchh: "stretchH", lineheight: "lineHeight", alphachnl: "alphaChnl", redchnl: "redChnl", greenchnl: "greenChnl", bluechnl: "blueChnl" };
  browser = function(e4) {
    e4 = e4.toString();
    var t = parseFromString(e4), i = { pages: [], chars: [], kernings: [] };
    ["info", "common"].forEach(function(e5) {
      var r2 = t.getElementsByTagName(e5)[0];
      r2 && (i[e5] = parseAttributes(getAttribs(r2)));
    });
    var r = t.getElementsByTagName("pages")[0];
    if (!r)
      throw new Error("malformed file -- no <pages> element");
    for (var n = r.getElementsByTagName("page"), a = 0;a < n.length; a++) {
      var o = n[a], s = parseInt(o.getAttribute("id"), 10), l = o.getAttribute("file");
      if (isNaN(s))
        throw new Error('malformed file -- page "id" attribute is NaN');
      if (!l)
        throw new Error('malformed file -- needs page "file" attribute');
      i.pages[parseInt(s, 10)] = l;
    }
    return ["chars", "kernings"].forEach(function(e5) {
      var r2 = t.getElementsByTagName(e5)[0];
      if (r2)
        for (var n2 = e5.substring(0, e5.length - 1), a2 = r2.getElementsByTagName(n2), o2 = 0;o2 < a2.length; o2++) {
          var s2 = a2[o2];
          i[e5].push(parseAttributes(getAttribs(s2)));
        }
    }), i;
  };
  parseXML = getDefaultExportFromCjs(browser);
  HEADER$1 = [66, 77, 70];
  parseBmfontBinary = function(e4) {
    if (e4.length < 6)
      throw new Error("invalid buffer length for BMFont");
    var t = HEADER$1.every(function(t2, i2) {
      return e4.readUInt8(i2) === t2;
    });
    if (!t)
      throw new Error("BMFont missing BMF byte header");
    var i = 3;
    if (e4.readUInt8(i++) > 3)
      throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
    for (var r = { kernings: [], chars: [] }, n = 0;n < 5; n++)
      i += readBlock(r, e4, i);
    return r;
  };
  readBinary = getDefaultExportFromCjs(parseBmfontBinary);
  splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  splitPath = function(e4) {
    return splitPathRe.exec(e4).slice(1);
  };
  sep = "/";
  delimiter = ":";
  path = { extname, basename, dirname, sep, delimiter, relative, join, isAbsolute, normalize, resolve: resolve2 };
  substr = "ab".substr(-1) === "b" ? function(e4, t, i) {
    return e4.substr(t, i);
  } : function(e4, t, i) {
    return t < 0 && (t = e4.length + t), e4.substr(t, i);
  };
  t = (e4) => {
    if (!e4)
      return null;
    const i = {};
    switch (e4.type) {
      case "ELEMENT": {
        let n = {};
        const a = E(e4.value.attributes), o = t(e4.value.children);
        if (a && (n = Object.assign(n, a)), o) {
          const t2 = r(e4.value.children);
          n = Object.assign(n, t2);
        }
        i[e4.value.type] = n;
        break;
      }
      case "ATTRIBUTE": {
        const t2 = e4.value;
        i[t2.name] = t2.value;
        break;
      }
      case "CONTENT":
        return { content: e4.value };
    }
    return i;
  };
  r = (e4) => e4 && Array.isArray(e4) && e4.length !== 0 ? n(e4) ? { content: e4[0].value } : { children: e4.map(t) } : null;
  n = (e4) => e4 && Array.isArray(e4) && e4.length === 1 && e4[0].type === "CONTENT";
  E = (e4) => e4 && Array.isArray(e4) ? e4.map(t).reduce((e5, t2) => Object.assign(e5, t2), {}) : null;
  s = { convert: (e4) => t(e4.value.children[0]) };
  a = { Token: (e4, t2) => ({ type: e4, value: t2 }), TOKEN_TYPE: { OPEN_BRACKET: "OPEN_BRACKET", ELEMENT_TYPE: "ELEMENT_TYPE", CLOSE_ELEMENT: "CLOSE_ELEMENT", ATTRIB_NAME: "ATTRIB_NAME", ATTRIB_VALUE: "ATTRIB_VALUE", ASSIGN: "ASSIGN", CLOSE_BRACKET: "CLOSE_BRACKET", CONTENT: "CONTENT", EOF: "EOF" } };
  ({ Token: T, TOKEN_TYPE: u } = a);
  c = T("EOF");
  l = (e4) => e4 === " " || e4 === "\n" || e4 === "\r" || e4 === "\t";
  o = (e4) => e4.replace(/'/g, '"');
  N = { createLexer: function(e4) {
    let t2 = null, i = ((e5) => {
      let t3 = 0;
      for (;t3 < e5.length && l(e5[t3]); )
        t3++;
      return ((e6, t4) => {
        if (e6.startsWith("<?xml", t4)) {
          const i2 = e6.length;
          for (;t4 < i2; )
            if (e6[t4] !== "?")
              t4++;
            else {
              if (e6[t4 + 1] === ">")
                return t4 + 2;
              t4++;
            }
        }
        return t4;
      })(e5, t3);
    })(e4), r2 = [];
    const n2 = () => e4[i], a2 = () => t2 !== c && i < e4.length, s2 = (e5) => e5 === '"' || e5 === "'", h = () => {
      for (;a2() && l(e4[i]); )
        i++;
    }, f = (t3) => {
      if (a2()) {
        if (e4[i] === "<") {
          let t4 = "<";
          return i++, a2() && e4[i] === "/" ? (i++, t4 = "</") : a2() && e4[i] === "!" && e4[i + 1] === "-" && e4[i + 2] === "-" && (i++, i++, i++, t4 = "<!--"), t4;
        }
        if (n2() === "/") {
          let e5 = "/";
          return i++, a2() && n2() === ">" && (i++, e5 = "/>"), e5;
        }
        if (e4[i] === "=" || e4[i] === ">") {
          const t4 = e4[i];
          return i++, t4;
        }
      }
      return d(!!t3);
    }, d = (t3) => {
      const r3 = t3 ? /[^>=<]/u : /[a-zA-Z0-9_:-]/;
      let n3 = i;
      for (;a2() && e4[i].match(r3); )
        i++;
      return o(e4.substring(n3, i));
    }, p = () => {
      const l2 = i;
      h();
      const m = i - l2;
      if (a2())
        if (t2 && t2.type === u.OPEN_BRACKET) {
          h();
          const e5 = f(false);
          t2 = T(u.ELEMENT_TYPE, e5), r2.push(e5);
        } else if (t2 && t2.type === u.ASSIGN) {
          a2() && s2(n2()) && i++;
          let r3 = i;
          for (;a2() && !s2(n2()); )
            i++;
          const l3 = o(e4.substring(r3, i));
          i++, t2 = T(u.ATTRIB_VALUE, l3);
        } else {
          h();
          let o2 = f(true);
          switch (o2) {
            case "=":
              t2 = t2.type === u.ATTRIB_NAME ? T(u.ASSIGN) : T(u.CONTENT, o2);
              break;
            case "</": {
              const n3 = i;
              for (;e4[i] !== ">"; )
                i++;
              t2 = T(u.CLOSE_ELEMENT, e4.substring(n3, i)), i++, r2.pop();
              break;
            }
            case "/>": {
              const e5 = r2.pop();
              t2 = T(u.CLOSE_ELEMENT, e5);
              break;
            }
            case "<!--": {
              const t3 = ["!", "-", "-"];
              for (;a2() && (t3[2] !== ">" || t3[1] !== "-" || t3[0] !== "-"); )
                t3.shift(), t3.push(e4[i]), i++;
              return p();
            }
            case ">":
              t2 = T(u.CLOSE_BRACKET);
              break;
            case "<":
              t2 = T(u.OPEN_BRACKET);
              break;
            default:
              if (o2 && o2.length > 0) {
                if (t2.type === u.CLOSE_BRACKET) {
                  let e5 = "";
                  n2() !== "<" && (e5 = d(true)), t2 = T(u.CONTENT, o2 + e5);
                } else if (t2.type !== u.ATTRIB_NAME && t2.type !== u.CONTENT)
                  t2.type === u.CLOSE_ELEMENT ? (o2 = " ".repeat(m) + o2, t2 = T(u.CONTENT, o2)) : t2 = T(u.ATTRIB_NAME, o2);
                else {
                  const e5 = " ".repeat(m) + o2;
                  t2 = T(u.CONTENT, e5);
                }
                break;
              }
              {
                const t3 = 'Unknown Syntax : "' + e4[i] + '"';
                throw new Error(t3);
              }
          }
        }
      else
        t2 = c;
      return t2;
    };
    return { peek: n2, next: p, hasNext: a2 };
  } };
  ({ createLexer: i } = N);
  ({ Token: p, TOKEN_TYPE: O } = a);
  [A, f, C, h] = ["ROOT", "ELEMENT", "ATTRIBUTE", "CONTENT"];
  _ = (e4, t2) => ({ type: e4, value: t2 });
  L = (e4) => _(h, e4);
  y = (e4, t2, i2) => _(f, { type: e4, attributes: t2, children: i2 });
  v = (e4, t2) => _(C, { name: e4, value: t2 });
  S = (e4, t2) => {
    const i2 = [];
    for (;e4.hasNext(); ) {
      const r2 = e4.next();
      switch (r2.type) {
        case O.OPEN_BRACKET: {
          const t3 = e4.next(), [r3, n2] = R(e4);
          let a2 = [];
          n2.type !== O.CLOSE_ELEMENT && (a2 = S(e4, t3)), a2 && a2.length > 0 && a2[0].type === O.CONTENT && (a2 = b(a2)), i2.push(y(t3.value, r3, a2));
          break;
        }
        case O.CLOSE_ELEMENT:
          if (r2.value === t2.value)
            return i2;
          break;
        case O.CONTENT:
          i2.push(L(r2.value));
          break;
        case O.EOF:
          return i2;
        default:
          throw new Error(`Unknown Lexem type: ${r2.type} "${r2.value}, scoping element: ${t2.value}"`);
      }
    }
    return i2;
  };
  R = (e4) => {
    const t2 = [];
    let i2 = e4.peek();
    if (!e4.hasNext() || i2 && i2.type === O.CLOSE_BRACKET || i2 && i2.type === O.CLOSE_ELEMENT)
      return [t2, i2];
    for (i2 = e4.next();e4.hasNext() && i2 && i2.type !== O.CLOSE_BRACKET && i2.type !== O.CLOSE_ELEMENT; ) {
      const r2 = i2;
      e4.next();
      const n2 = e4.next(), a2 = v(r2.value, n2.value);
      t2.push(a2), i2 = e4.next();
    }
    return [t2, i2];
  };
  B = { transpile: function(e4, t2) {
    const r2 = ((e5) => _(A, { children: S(e5, p(A, "ROOT")) }))(i(e4));
    return t2 ? t2.convert(r2) : r2;
  }, Node: _, ElementNode: y, AttribNode: v };
  M = s;
  ({ transpile: x } = B);
  k = e({ convertXML: function(e4, t2) {
    return x(e4, t2 || M);
  }, createAST: function(e4) {
    return x(e4);
  } });
  simpleXmlToJson_min = k;
  xmlPackage = getDefaultExportFromCjs(simpleXmlToJson_min);
  ({ convertXML } = xmlPackage);
  isWebWorker = typeof self != "undefined" && self.document === undefined;
  CharacterJimp = createJimp({ formats: [png] });
  HEADER = Buffer2.from([66, 77, 70, 3]);
  pixelmatch_1 = pixelmatch;
  defaultOptions = { threshold: 0.1, includeAA: false, alpha: 0.1, aaColor: [255, 255, 0], diffColor: [255, 0, 0], diffColorAlt: null, diffMask: false };
  pixelMatch = getDefaultExportFromCjs(pixelmatch_1);
  defaultPlugins = [methods$h, methods$g, methods$f, methods$e, methods$c, methods$a, methods$b, methods$9, methods$8, methods$7, methods$6, methods$5, methods$4, methods$3, methods$d, methods$2, methods$1, methods];
  defaultFormats = [bmp, msBmp, gif, jpeg$2, png, tiff];
  JimpMime = { bmp: bmp().mime, gif: gif().mime, jpeg: jpeg$2().mime, png: png().mime, tiff: tiff().mime };
  Jimp = createJimp({ formats: defaultFormats, plugins: defaultPlugins });
});

// src/svg2/error.js
var require_error2 = __commonJS((exports, module2) => {
  var invalidParameterError = function(name, expected, actual) {
    return new TypeError(`Expected <${expected}> for [${name}] but received ${actual} of type <${typeof actual}>`);
  };
  module2.exports = {
    invalidParameterError
  };
});

// src/svg2/constants.js
var require_constants = __commonJS((exports, module2) => {
  var { JimpMime: JimpMime2 } = (init_browser(), __toCommonJS(exports_browser));
  module2.exports = {
    AUTO: "auto",
    FORMATS: {
      bmp: JimpMime2.bmp,
      png: JimpMime2.png,
      tiff: JimpMime2.tiff,
      jpeg: JimpMime2.jpeg
    }
  };
});

// node_modules/@resvg/resvg-wasm/index.js
var require_resvg_wasm = __commonJS((exports, module2) => {
  var addHeapObject = function(obj) {
    if (heap_next === heap.length)
      heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
  };
  var getObject = function(idx) {
    return heap[idx];
  };
  var dropObject = function(idx) {
    if (idx < 132)
      return;
    heap[idx] = heap_next;
    heap_next = idx;
  };
  var takeObject = function(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
  };
  var getUint8Memory0 = function() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
      cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
  };
  var passStringToWasm0 = function(arg, malloc, realloc) {
    if (realloc === undefined) {
      const buf = cachedTextEncoder.encode(arg);
      const ptr2 = malloc(buf.length, 1) >>> 0;
      getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
      WASM_VECTOR_LEN = buf.length;
      return ptr2;
    }
    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;
    const mem = getUint8Memory0();
    let offset = 0;
    for (;offset < len; offset++) {
      const code = arg.charCodeAt(offset);
      if (code > 127)
        break;
      mem[ptr + offset] = code;
    }
    if (offset !== len) {
      if (offset !== 0) {
        arg = arg.slice(offset);
      }
      ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
      const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
      const ret = encodeString(arg, view);
      offset += ret.written;
      ptr = realloc(ptr, len, offset, 1) >>> 0;
    }
    WASM_VECTOR_LEN = offset;
    return ptr;
  };
  var isLikeNone = function(x2) {
    return x2 === undefined || x2 === null;
  };
  var getInt32Memory0 = function() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
      cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
  };
  var getStringFromWasm0 = function(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
  };
  var _assertClass = function(instance, klass) {
    if (!(instance instanceof klass)) {
      throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
  };
  var handleError = function(f2, args) {
    try {
      return f2.apply(this, args);
    } catch (e4) {
      wasm.__wbindgen_exn_store(addHeapObject(e4));
    }
  };
  async function __wbg_load(module22, imports) {
    if (typeof Response === "function" && module22 instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming === "function") {
        try {
          return await WebAssembly.instantiateStreaming(module22, imports);
        } catch (e4) {
          if (module22.headers.get("Content-Type") != "application/wasm") {
            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e4);
          } else {
            throw e4;
          }
        }
      }
      const bytes = await module22.arrayBuffer();
      return await WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = await WebAssembly.instantiate(module22, imports);
      if (instance instanceof WebAssembly.Instance) {
        return { instance, module: module22 };
      } else {
        return instance;
      }
    }
  }
  var __wbg_get_imports = function() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbg_new_28c511d9baebfa89 = function(arg0, arg1) {
      const ret = new Error(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_memory = function() {
      const ret = wasm.memory;
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_buffer_12d079cc21e14bdb = function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb = function(arg0, arg1, arg2) {
      const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
      return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
      takeObject(arg0);
    };
    imports.wbg.__wbg_new_63b92bc8671ed464 = function(arg0) {
      const ret = new Uint8Array(getObject(arg0));
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_values_839f3396d5aac002 = function(arg0) {
      const ret = getObject(arg0).values();
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_next_196c84450b364254 = function() {
      return handleError(function(arg0) {
        const ret = getObject(arg0).next();
        return addHeapObject(ret);
      }, arguments);
    };
    imports.wbg.__wbg_done_298b57d23c0fc80c = function(arg0) {
      const ret = getObject(arg0).done;
      return ret;
    };
    imports.wbg.__wbg_value_d93c65011f51a456 = function(arg0) {
      const ret = getObject(arg0).value;
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_instanceof_Uint8Array_2b3bbecd033d19f6 = function(arg0) {
      let result;
      try {
        result = getObject(arg0) instanceof Uint8Array;
      } catch (_2) {
        result = false;
      }
      const ret = result;
      return ret;
    };
    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
      const obj = getObject(arg1);
      const ret = typeof obj === "string" ? obj : undefined;
      var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      var len1 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len1;
      getInt32Memory0()[arg0 / 4 + 0] = ptr1;
    };
    imports.wbg.__wbg_new_16b304a2cfa7ff4a = function() {
      const ret = new Array;
      return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
      const ret = getStringFromWasm0(arg0, arg1);
      return addHeapObject(ret);
    };
    imports.wbg.__wbg_push_a5b05aedc7234f9f = function(arg0, arg1) {
      const ret = getObject(arg0).push(getObject(arg1));
      return ret;
    };
    imports.wbg.__wbg_length_c20a40f15020d68a = function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    };
    imports.wbg.__wbg_set_a47bac70306a19a7 = function(arg0, arg1, arg2) {
      getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    return imports;
  };
  var __wbg_init_memory = function(imports, maybe_memory) {
  };
  var __wbg_finalize_init = function(instance, module22) {
    wasm = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module22;
    cachedInt32Memory0 = null;
    cachedUint8Memory0 = null;
    return wasm;
  };
  async function __wbg_init(input) {
    if (wasm !== undefined)
      return wasm;
    if (typeof input === "undefined") {
      input = new URL("index_bg.wasm", undefined);
    }
    const imports = __wbg_get_imports();
    if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
      input = fetch(input);
    }
    __wbg_init_memory(imports);
    const { instance, module: module22 } = await __wbg_load(await input, imports);
    return __wbg_finalize_init(instance, module22);
  }
  var isCustomFontsOptions = function(value) {
    return Object.prototype.hasOwnProperty.call(value, "fontBuffers");
  };
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __export3 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to2, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames3(from2))
        if (!__hasOwnProp3.call(to2, key) && key !== except)
          __defProp3(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc3(from2, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toCommonJS3 = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var wasm_binding_exports = {};
  __export3(wasm_binding_exports, {
    Resvg: () => Resvg2,
    initWasm: () => initWasm
  });
  module2.exports = __toCommonJS3(wasm_binding_exports);
  var wasm;
  var heap = new Array(128).fill(undefined);
  heap.push(undefined, null, true, false);
  var heap_next = heap.length;
  var WASM_VECTOR_LEN = 0;
  var cachedUint8Memory0 = null;
  var cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
    throw Error("TextEncoder not available");
  } };
  var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
  } : function(arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
      read: arg.length,
      written: buf.length
    };
  };
  var cachedInt32Memory0 = null;
  var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
    throw Error("TextDecoder not available");
  } };
  if (typeof TextDecoder !== "undefined") {
    cachedTextDecoder.decode();
  }
  var BBoxFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
  }, unregister: () => {
  } } : new FinalizationRegistry((ptr) => wasm.__wbg_bbox_free(ptr >>> 0));
  var BBox = class _BBox {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(_BBox.prototype);
      obj.__wbg_ptr = ptr;
      BBoxFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      BBoxFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_bbox_free(ptr);
    }
    get x() {
      const ret = wasm.__wbg_get_bbox_x(this.__wbg_ptr);
      return ret;
    }
    set x(arg0) {
      wasm.__wbg_set_bbox_x(this.__wbg_ptr, arg0);
    }
    get y() {
      const ret = wasm.__wbg_get_bbox_y(this.__wbg_ptr);
      return ret;
    }
    set y(arg0) {
      wasm.__wbg_set_bbox_y(this.__wbg_ptr, arg0);
    }
    get width() {
      const ret = wasm.__wbg_get_bbox_width(this.__wbg_ptr);
      return ret;
    }
    set width(arg0) {
      wasm.__wbg_set_bbox_width(this.__wbg_ptr, arg0);
    }
    get height() {
      const ret = wasm.__wbg_get_bbox_height(this.__wbg_ptr);
      return ret;
    }
    set height(arg0) {
      wasm.__wbg_set_bbox_height(this.__wbg_ptr, arg0);
    }
  };
  var RenderedImageFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
  }, unregister: () => {
  } } : new FinalizationRegistry((ptr) => wasm.__wbg_renderedimage_free(ptr >>> 0));
  var RenderedImage = class _RenderedImage {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(_RenderedImage.prototype);
      obj.__wbg_ptr = ptr;
      RenderedImageFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      RenderedImageFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_renderedimage_free(ptr);
    }
    get width() {
      const ret = wasm.renderedimage_width(this.__wbg_ptr);
      return ret >>> 0;
    }
    get height() {
      const ret = wasm.renderedimage_height(this.__wbg_ptr);
      return ret >>> 0;
    }
    asPng() {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.renderedimage_asPng(retptr, this.__wbg_ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    get pixels() {
      const ret = wasm.renderedimage_pixels(this.__wbg_ptr);
      return takeObject(ret);
    }
  };
  var ResvgFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
  }, unregister: () => {
  } } : new FinalizationRegistry((ptr) => wasm.__wbg_resvg_free(ptr >>> 0));
  var Resvg = class {
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      ResvgFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_resvg_free(ptr);
    }
    constructor(svg, options, custom_font_buffers) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(options) ? 0 : passStringToWasm0(options, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.resvg_new(retptr, addHeapObject(svg), ptr0, len0, isLikeNone(custom_font_buffers) ? 0 : addHeapObject(custom_font_buffers));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        this.__wbg_ptr = r0 >>> 0;
        return this;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    get width() {
      const ret = wasm.resvg_width(this.__wbg_ptr);
      return ret;
    }
    get height() {
      const ret = wasm.resvg_height(this.__wbg_ptr);
      return ret;
    }
    render() {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.resvg_render(retptr, this.__wbg_ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return RenderedImage.__wrap(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    toString() {
      let deferred1_0;
      let deferred1_1;
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.resvg_toString(retptr, this.__wbg_ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        deferred1_0 = r0;
        deferred1_1 = r1;
        return getStringFromWasm0(r0, r1);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
      }
    }
    innerBBox() {
      const ret = wasm.resvg_innerBBox(this.__wbg_ptr);
      return ret === 0 ? undefined : BBox.__wrap(ret);
    }
    getBBox() {
      const ret = wasm.resvg_getBBox(this.__wbg_ptr);
      return ret === 0 ? undefined : BBox.__wrap(ret);
    }
    cropByBBox(bbox) {
      _assertClass(bbox, BBox);
      wasm.resvg_cropByBBox(this.__wbg_ptr, bbox.__wbg_ptr);
    }
    imagesToResolve() {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.resvg_imagesToResolve(retptr, this.__wbg_ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    resolveImage(href, buffer) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(href, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.resvg_resolveImage(retptr, this.__wbg_ptr, ptr0, len0, addHeapObject(buffer));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
          throw takeObject(r0);
        }
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
  };
  var dist_default = __wbg_init;
  var initialized = false;
  var initWasm = async (module_or_path) => {
    if (initialized) {
      throw new Error("Already initialized. The `initWasm()` function can be used only once.");
    }
    await dist_default(await module_or_path);
    initialized = true;
  };
  var Resvg2 = class extends Resvg {
    constructor(svg, options) {
      if (!initialized)
        throw new Error("Wasm has not been initialized. Call `initWasm()` function.");
      const font = options?.font;
      if (!!font && isCustomFontsOptions(font)) {
        const serializableOptions = {
          ...options,
          font: {
            ...font,
            fontBuffers: undefined
          }
        };
        super(svg, JSON.stringify(serializableOptions), font.fontBuffers);
      } else {
        super(svg, JSON.stringify(options));
      }
    }
  };
});

// src/svg2/svg.js
var require_svg = __commonJS((exports, module2) => {
  var Svg2 = require_src();
  var error = require_error2();
  var constants2 = require_constants();
  var { initWasm, Resvg } = require_resvg_wasm();
  var Svg = function(instance) {
    this.instance = instance;
    this.update(instance.toElement(instance.input.string), true);
  };
  Svg.prototype = {
    update: function(svg, isElement = false) {
      if (isElement) {
        if (svg.constructor.name !== "SVGSVGElement") {
          throw error.invalidParameterError("svg", "SVGSVGElement", svg);
        }
      } else {
        svg = this.instance.check(svg);
        svg = this.instance.toElement(svg);
      }
      this.instance.input.element = svg;
      this.instance.input.string = svg.outerHTML;
      return this.instance;
    },
    resize: function(input) {
      var svg = this.element();
      var current = this.dimensions();
      var output = {
        scale: 0,
        width: undefined,
        height: undefined
      };
      function set(dimension) {
        var opposite = dimension == "height" ? "width" : "height";
        output[dimension] = input[dimension];
        if (input[opposite] === constants2.AUTO) {
          output[opposite] = output[opposite] = input[dimension] / current[dimension] * current[opposite];
        } else {
          output[opposite] = current[opposite];
        }
        return output;
      }
      if (Number.isFinite(input)) {
        output.width = current.width * input;
        output.height = current.height * input;
        output.scale = input;
      } else {
        if (input.width && input.width !== constants2.AUTO && input.height && input.height !== constants2.AUTO) {
          output.width = input.width;
          output.height = input.height;
        } else if (input.width && input.width !== constants2.AUTO) {
          output = set("width");
        } else if (input.height && input.height !== constants2.AUTO) {
          output = set("height");
        } else {
          throw error.invalidParameterError("input", "width or height in object", input);
        }
        output.scale = (output.width / current.width + output.height / current.height) / 2;
      }
      svg.setAttribute("width", output.width);
      svg.setAttribute("height", output.height);
      this.update(svg, true);
      this.instance.output.resize = output;
      return this.instance;
    },
    html: function() {
      return this.instance.input.string;
    },
    png: async function(svg) {
      const opts = {
        font: {
          loadSystemFonts: true
        }
      };
      await initWasm(fetch("https://unpkg.com/@resvg/resvg-wasm/index_bg.wasm"));
      const resvgJS = new Resvg(svg, opts);
      const pngBuffer = resvgJS.render().asPng();
      return pngBuffer;
    },
    element: function() {
      return this.instance.input.element;
    },
    dimensionToPx: function(input) {
      if (!input || typeof input != "string" && typeof input != "number") {
        throw error.invalidParameterError("input", "string with dimension or number", input);
      }
      function round(input2) {
        return Math.round((input2 + Number.EPSILON) * 100) / 100;
      }
      var units = [
        "rem",
        "px",
        "em",
        "ex",
        "ch",
        "cm",
        "mm",
        "q",
        "in",
        "pc",
        "pt"
      ];
      var convert = false;
      for (var i2 = 0;i2 < units.length; i2++) {
        var unit = units[i2];
        convert = typeof input == "string" && input.search(unit) !== -1;
        if (convert) {
          input = input.replace(unit, "");
          const cm = 96 / 2.54;
          const inch = 2.54 * cm;
          switch (unit.toLowerCase()) {
            case "px":
              break;
            case "em":
            case "rem":
              input = input * 16;
              break;
            case "ex":
              input = round(input * 7.156);
              break;
            case "ch":
              input = input * 8;
              break;
            case "cm":
              input = input * cm;
              break;
            case "mm":
              input = round(input * (1 / 10 * cm));
              break;
            case "q":
              input = input * (1 / 40 * cm);
              break;
            case "in":
              input = input * inch;
              break;
            case "pc":
              input = input * (1 / 6 * inch);
              break;
            case "pt":
              input = input * (1 / 72 * inch);
              break;
          }
        }
      }
      var dimension = Number(input);
      if (isNaN(dimension)) {
        throw error.invalidParameterError("input", "a valid dimension i.e 20px, 20rem, 20em or 20", input);
      }
      return dimension;
    },
    viewBox: function(svg) {
      if (!svg.hasAttribute("viewBox")) {
        throw error.invalidParameterError("SVG dimension", "height/width and viewBox attributes to be set", this.instance.svg.html());
      }
      var viewBox = svg.getAttribute("viewBox").split(" ");
      return {
        "min-x": Number(viewBox[0]),
        "min-y": Number(viewBox[1]),
        width: Number(viewBox[2]),
        height: Number(viewBox[3])
      };
    },
    dimensions: function() {
      var svg = this.element();
      var dimension = {
        names: ["width", "height"],
        data: { width: 0, height: 0 }
      };
      var dn = dimension.names;
      var dd = dimension.data;
      if (svg.hasAttribute(dn[0]) && svg.hasAttribute(dn[1])) {
        var width = svg.getAttribute(dn[0]);
        var height = svg.getAttribute(dn[1]);
        if (!width.includes("%") && !width.includes("vw") && !height.includes("%") && !height.includes("vh")) {
          for (var i2 = 0;i2 < dn.length; i2++) {
            var name = dn[i2];
            switch (name) {
              case "width":
                dd.width = this.dimensionToPx(width);
                break;
              case "height":
                dd.height = this.dimensionToPx(height);
                break;
            }
          }
        } else {
          var viewbox = this.viewBox(svg);
          dd.width = viewbox.width;
          dd.height = viewbox.height;
        }
      } else {
        var viewbox = this.viewBox(svg);
        dd.width = viewbox.width;
        dd.height = viewbox.height;
      }
      return dd;
    }
  };
  module2.exports = Svg;
});

// src/svg2/option.js
var require_option2 = __commonJS((exports, module2) => {
  var error = require_error2();
  var constants2 = require_constants();
  var Option = function() {
    this.data = {
      main: { resolveWithObject: false },
      png: { transparent: false },
      uri: { base64: false, mime: constants2.FORMATS.png },
      extend: { top: 0, right: 0, bottom: 0, left: 0, background: "#ffffff" },
      background: { color: "#ffffff" }
    };
  };
  Option.prototype = {
    get: function(setting) {
      if (!setting || typeof setting !== "string") {
        throw error.invalidParameterError("setting", "string", setting);
      }
      var expected = Object.keys(this.data);
      if (!expected.includes(setting)) {
        throw error.invalidParameterError("setting", expected.toString(), setting);
      }
      return this.data[setting];
    },
    update: function(setting, options) {
      if (options == undefined) {
        throw error.invalidParameterError("options", "object", options);
      }
      if (Object.keys(options).length === 0) {
        return;
      }
      var preset = this.get(setting);
      for (var option in options) {
        if (preset[option] || preset[option] === false) {
          this.data[setting][option] = options[option];
        } else {
          var expected = Object.keys(preset);
          throw error.invalidParameterError("png", `[${expected.toString()}]`, option);
        }
      }
    }
  };
  module2.exports = Option;
});

// src/svg2/processor.js
var require_processor = __commonJS((exports, module2) => {
  var Processor = function(instance) {
    this.instance = instance;
  };
  var jimp = (init_browser(), __toCommonJS(exports_browser));
  var constants2 = require_constants();
  var formats = constants2.FORMATS;
  Processor.prototype = {
    pipeline: function(callback) {
      var format = this.instance.output.format;
      var i2 = this.instance;
      return new Promise((resolve3, reject2) => {
        this.process((err, buffer) => {
          i2.output.file = buffer;
          err ? reject2(err) : resolve3(buffer);
        });
      });
    },
    process: function(callback) {
      var i2 = this.instance;
      i2.svg.png(i2.svg.html()).then(async (pngBytes) => {
        let png2 = await jimp.Jimp.read(pngBytes.buffer);
        if (!i2.options.get("png").transparent || i2.output.format !== formats.png) {
          var dimensions = i2.svg.dimensions();
          png2 = await this.background(png2, dimensions);
        }
        for (var format in formats) {
          if (formats[format] === i2.output.format) {
            png2.getBuffer(formats[format], callback);
            break;
          }
        }
      }).catch((error) => {
        callback(error);
      });
    },
    blank: function(width, height, background) {
      if (!background) {
        background = this.instance.options.get("background").color;
      }
      return new jimp.Jimp({
        width,
        height,
        color: background
      });
    },
    background: async function(image, dimensions) {
      var { width, height } = dimensions;
      var x2, y2;
      x2 = y2 = 0;
      var background = await this.blank(width, height);
      image = background.composite(image, x2, y2);
      if (this.instance.output.extend) {
        var options = this.instance.options.get("extend");
        var extended = {
          background: options.background,
          height: options.top + options.bottom + height,
          width: options.left + options.right + width
        };
        if (options.left) {
          x2 = x2 + options.left;
        }
        if (options.top) {
          y2 = y2 + options.top;
        }
        extended.image = await this.blank(extended.width, extended.height, extended.background);
        image = extended.image.composite(image, x2, y2);
      }
      return image;
    }
  };
  module2.exports = Processor;
});

// src/svg2/constructor.js
var require_constructor = __commonJS((exports, module2) => {
  var jimp = (init_browser(), __toCommonJS(exports_browser));
  var Svg = require_svg();
  var error = require_error2();
  var Option = require_option2();
  var Processor = require_processor();
  var { AUTO, FORMATS } = require_constants();
  var Svg2 = function(input) {
    if (!(this instanceof Svg2)) {
      return new Svg2(input);
    }
    input = this.check(input);
    this.options = new Option;
    this.input = {
      string: input,
      element: null
    };
    this.output = {
      file: undefined,
      format: undefined,
      resize: undefined,
      extend: undefined,
      background: undefined
    };
    this.jimp = jimp;
    this.svg = new Svg(this);
    this.processor = new Processor(this);
    return this;
  };
  Svg2.prototype = {
    check: function(input) {
      return input;
    }
  };
  Svg2.AUTO = AUTO;
  Svg2.BMP = FORMATS.bmp;
  Svg2.PNG = FORMATS.png;
  Svg2.TIFF = FORMATS.tiff;
  Svg2.JPEG = FORMATS.jpeg;
  module2.exports = Svg2;
});

// src/svg2/color.js
var require_color = __commonJS((exports, module2) => {
  var background = function(options) {
    this.options.update("background", options);
    options = this.options.get("background");
    this.output.background = options;
    return this;
  };
  module2.exports = function(Svg2) {
    Object.assign(Svg2.prototype, {
      background
    });
  };
});

// src/svg2/resize.js
var require_resize = __commonJS((exports, module2) => {
  var extend = function(options) {
    if (true)
      throw new Error("TODO");
    return this;
  };
  module2.exports = function(Svg2) {
    Object.assign(Svg2.prototype, {
      extend
    });
  };
});

// src/svg2/output.js
var require_output = __commonJS((exports, module2) => {
  var png2 = function(options = {}) {
    this.options.update("png", options);
    options = this.options.get("png");
    this.output.format = formats.png;
    return this;
  };
  var jpeg2 = function() {
    this.output.format = formats.jpeg;
    return this;
  };
  var tiff2 = function() {
    this.output.format = formats.tiff;
    return this;
  };
  var bmp2 = function() {
    this.output.format = formats.bmp;
    return this;
  };
  var _getDocument = function(input) {
    return window.document;
  };
  var toElement = function(input) {
    input = input ? input : this.svg.html();
    input = this.check(input);
    return _getDocument(input).getElementsByTagName("svg")[0];
  };
  var toUri = function(options = {}, callback) {
    this.options.update("uri", options);
    options = this.options.get("uri");
    var mime2 = options.mime;
    var base64 = options.base64;
    var svg = this.svg.html();
    var png3 = this.svg.png(svg);
    async function generateDataUri() {
      const buffer = await png3;
      var image = await jimp.Jimp.read(buffer);
      var uri = await image.getBase64(mime2);
      if (base64) {
        uri = uri.replace(new RegExp(`^data:${mime2};base64,`), "");
      }
      return uri;
    }
    return generateDataUri();
  };
  var toBuffer = function(callback) {
    return this.processor.pipeline(callback);
  };
  var toFile = function(destination, callback) {
    return new Promise((resolve3, reject2) => {
      this.processor.pipeline((err, buffer) => {
        if (err) {
          reject2(err);
          return;
        }
        console.log(`WOULD CALL WIRETE FILE:`);
        console.log(buffer);
      });
    });
  };
  var jimp = (init_browser(), __toCommonJS(exports_browser));
  var error = require_error2();
  var constants2 = require_constants();
  var formats = constants2.FORMATS;
  module2.exports = function(Svg2) {
    Object.assign(Svg2.prototype, {
      png: png2,
      bmp: bmp2,
      jpeg: jpeg2,
      tiff: tiff2,
      toUri,
      toFile,
      toBuffer,
      toElement
    });
  };
});

// src/svg2/index.js
var require_svg2 = __commonJS((exports, module2) => {
  var Svg2 = require_constructor();
  require_color()(Svg2);
  require_resize()(Svg2);
  require_output()(Svg2);
  module2.exports = Svg2;
});

// src/potrace/svg.js
var require_svg3 = __commonJS((exports, module2) => {
  var Svg = function(info, pathlist, bitmap) {
    this.bitmap = bitmap;
    this.pathlist = pathlist;
    this.size = info.svgSize;
    this.opt_type = info.opt_type;
  };
  Svg.prototype = {
    bezier: function(i2, curve) {
      var size = this.size;
      var b2 = "C " + (curve.c[i2 * 3 + 0].x * size).toFixed(3) + " " + (curve.c[i2 * 3 + 0].y * size).toFixed(3) + ",";
      b2 += (curve.c[i2 * 3 + 1].x * size).toFixed(3) + " " + (curve.c[i2 * 3 + 1].y * size).toFixed(3) + ",";
      b2 += (curve.c[i2 * 3 + 2].x * size).toFixed(3) + " " + (curve.c[i2 * 3 + 2].y * size).toFixed(3) + " ";
      return b2;
    },
    segment: function(i2, curve) {
      var size = this.size;
      var s2 = "L " + (curve.c[i2 * 3 + 1].x * size).toFixed(3) + " " + (curve.c[i2 * 3 + 1].y * size).toFixed(3) + " ";
      s2 += (curve.c[i2 * 3 + 2].x * size).toFixed(3) + " " + (curve.c[i2 * 3 + 2].y * size).toFixed(3) + " ";
      return s2;
    },
    path: function(curve) {
      var size = this.size;
      var n2 = curve.n, i2;
      var p2 = "M" + (curve.c[(n2 - 1) * 3 + 2].x * size).toFixed(3) + " " + (curve.c[(n2 - 1) * 3 + 2].y * size).toFixed(3) + " ";
      for (i2 = 0;i2 < n2; i2++) {
        if (curve.tag[i2] === "CURVE") {
          p2 += this.bezier(i2, curve);
        } else if (curve.tag[i2] === "CORNER") {
          p2 += this.segment(i2, curve);
        }
      }
      return p2;
    },
    get: function() {
      var size = this.size, bitmap = this.bitmap, pathlist = this.pathlist;
      var w = bitmap.w * size, h2 = bitmap.h * size, len = pathlist.length, c2, i2, strokec, fillc, fillrule;
      var svg = '<svg version="1.1" width="' + w + '" height="' + h2 + '" xmlns="http://www.w3.org/2000/svg">';
      svg += '<path d="';
      for (i2 = 0;i2 < len; i2++) {
        c2 = pathlist[i2].curve;
        svg += this.path(c2);
      }
      if (this.opt_type === "curve") {
        strokec = "black";
        fillc = "none";
        fillrule = "";
      } else {
        strokec = "none";
        fillc = "black";
        fillrule = ' fill-rule="evenodd"';
      }
      svg += '" stroke="' + strokec + '" fill="' + fillc + '"' + fillrule + "/></svg>";
      return svg;
    }
  };
  module2.exports = Svg;
});

// src/potrace/error.js
var require_error3 = __commonJS((exports, module2) => {
  var invalidParameterError = function(name, expected, actual) {
    return new TypeError(`Expected <${expected}> for [${name}] but received ${actual} of type <${typeof actual}>`);
  };
  var invalidPathError = function(name, path2) {
    return new TypeError(`${name} path ${path2} does not exist.`);
  };
  module2.exports = {
    invalidPathError,
    invalidParameterError
  };
});

// src/potrace/types/Path.js
var require_Path = __commonJS((exports, module2) => {
  var Path = function() {
    this.area = 0;
    this.len = 0;
    this.curve = {};
    this.pt = [];
    this.minX = 1e5;
    this.minY = 1e5;
    this.maxX = -1;
    this.maxY = -1;
  };
  module2.exports = Path;
});

// src/potrace/types/Point.js
var require_Point = __commonJS((exports, module2) => {
  var Point2 = function(x2, y2) {
    this.x = x2;
    this.y = y2;
  };
  Point2.prototype.copy = function() {
    return new Point2(this.x, this.y);
  };
  module2.exports = Point2;
});

// src/potrace/types/Bitmap.js
var require_Bitmap = __commonJS((exports, module2) => {
  var Path = require_Path();
  var Point2 = require_Point();
  var Bitmap = function(w, h2, info) {
    this.w = w;
    this.h = h2;
    this.info = info;
    this.size = w * h2;
    this.bm1 = undefined;
    this.path = undefined;
    this.arraybuffer = new ArrayBuffer(this.size);
    this.data = new Int8Array(this.arraybuffer);
  };
  Bitmap.prototype = {
    at: function(x2, y2) {
      return x2 >= 0 && x2 < this.w && y2 >= 0 && y2 < this.h && this.data[this.w * y2 + x2] === 1;
    },
    index: function(i2) {
      var point = new Point2;
      point.y = Math.floor(i2 / this.w);
      point.x = i2 - point.y * this.w;
      return point;
    },
    flip: function(x2, y2) {
      if (this.at(x2, y2)) {
        this.data[this.w * y2 + x2] = 0;
      } else {
        this.data[this.w * y2 + x2] = 1;
      }
    },
    copy: function() {
      var bm = new Bitmap(this.w, this.h), i2;
      for (i2 = 0;i2 < this.size; i2++) {
        bm.data[i2] = this.data[i2];
      }
      return bm;
    },
    findNext: function(point) {
      var bm1 = this.bm1;
      var i2 = bm1.w * point.y + point.x;
      while (i2 < bm1.size && bm1.data[i2] !== 1) {
        i2++;
      }
      return i2 < bm1.size && bm1.index(i2);
    },
    majority: function(x2, y2) {
      var bm1 = this.bm1;
      var i2, a2, ct;
      for (i2 = 2;i2 < 5; i2++) {
        ct = 0;
        for (a2 = -i2 + 1;a2 <= i2 - 1; a2++) {
          ct += bm1.at(x2 + a2, y2 + i2 - 1) ? 1 : -1;
          ct += bm1.at(x2 + i2 - 1, y2 + a2 - 1) ? 1 : -1;
          ct += bm1.at(x2 + a2 - 1, y2 - i2) ? 1 : -1;
          ct += bm1.at(x2 - i2, y2 + a2) ? 1 : -1;
        }
        if (ct > 0) {
          return 1;
        } else if (ct < 0) {
          return 0;
        }
      }
      return 0;
    },
    findPath: function(point) {
      var bm1 = this.bm1;
      var info = this.info;
      var path2 = new Path, x2 = point.x, y2 = point.y, dirx = 0, diry = 1, tmp;
      path2.sign = this.at(point.x, point.y) ? "+" : "-";
      while (true) {
        path2.pt.push(new Point2(x2, y2));
        if (x2 > path2.maxX)
          path2.maxX = x2;
        if (x2 < path2.minX)
          path2.minX = x2;
        if (y2 > path2.maxY)
          path2.maxY = y2;
        if (y2 < path2.minY)
          path2.minY = y2;
        path2.len++;
        x2 += dirx;
        y2 += diry;
        path2.area -= x2 * diry;
        if (x2 === point.x && y2 === point.y)
          break;
        var l2 = bm1.at(x2 + (dirx + diry - 1) / 2, y2 + (diry - dirx - 1) / 2);
        var r2 = bm1.at(x2 + (dirx - diry - 1) / 2, y2 + (diry + dirx - 1) / 2);
        if (r2 && !l2) {
          if (info.turnpolicy === "right" || info.turnpolicy === "black" && path2.sign === "+" || info.turnpolicy === "white" && path2.sign === "-" || info.turnpolicy === "majority" && this.majority(x2, y2) || info.turnpolicy === "minority" && !this.majority(x2, y2)) {
            tmp = dirx;
            dirx = -diry;
            diry = tmp;
          } else {
            tmp = dirx;
            dirx = diry;
            diry = -tmp;
          }
        } else if (r2) {
          tmp = dirx;
          dirx = -diry;
          diry = tmp;
        } else if (!l2) {
          tmp = dirx;
          dirx = diry;
          diry = -tmp;
        }
      }
      return path2;
    },
    xorPath: function(path2) {
      var bm1 = this.bm1;
      var y1 = path2.pt[0].y, len = path2.len, x2, y2, maxX, minY, i2, j;
      for (i2 = 1;i2 < len; i2++) {
        x2 = path2.pt[i2].x;
        y2 = path2.pt[i2].y;
        if (y2 !== y1) {
          minY = y1 < y2 ? y1 : y2;
          maxX = path2.maxX;
          for (j = x2;j < maxX; j++) {
            bm1.flip(j, minY);
          }
          y1 = y2;
        }
      }
    },
    pathlist: function(pathlist) {
      var path2;
      this.bm1 = this.copy();
      var currentPoint = new Point2(0, 0);
      while (currentPoint = this.findNext(currentPoint)) {
        path2 = this.findPath(currentPoint);
        this.xorPath(path2);
        if (path2.area > this.info.turdsize) {
          pathlist.push(path2);
        }
      }
    }
  };
  module2.exports = Bitmap;
});

// src/potrace/loader.js
var require_loader = __commonJS((exports, module2) => {
  var error = require_error3();
  var Bitmap = require_Bitmap();
  var { Jimp: Jimp2 } = (init_browser(), __toCommonJS(exports_browser)).default || (init_browser(), __toCommonJS(exports_browser));
  var Loader = function() {
  };
  Loader.prototype = {
    image: function(image) {
      const valid = image instanceof Buffer || typeof image === "string";
      if (!valid) {
        var err = error.invalidParameterError("image", "buffer or path to image", image);
        throw err;
      }
      return Jimp2.read(image);
    },
    bitmap: function(image, info) {
      var {
        bitmap: { data, width, height }
      } = image;
      var u8 = new Uint8ClampedArray(data.buffer);
      var bitmap = new Bitmap(width, height, info);
      var l2 = data.length, i2, j, color;
      for (i2 = 0, j = 0;i2 < l2; i2 += 4, j++) {
        color = 0.2126 * data[i2] + 0.7153 * data[i2 + 1] + 0.0721 * data[i2 + 2];
        bitmap.data[j] = color < 128 ? 1 : 0;
      }
      return bitmap;
    }
  };
  module2.exports = Loader;
});

// src/potrace/constants.js
var require_constants2 = __commonJS((exports, module2) => {
  module2.exports = {
    TURNPOLICY_BLACK: "black",
    TURNPOLICY_WHITE: "white",
    TURNPOLICY_LEFT: "left",
    TURNPOLICY_RIGHT: "right",
    TURNPOLICY_MINORITY: "minority",
    TURNPOLICY_MAJORITY: "majority",
    TURDSIZE: 2,
    OPTCURVE: true,
    ALPHAMAX: 1,
    OPTTOLERANCE: 0.2
  };
});

// src/potrace/option.js
var require_option3 = __commonJS((exports, module2) => {
  var constants2 = require_constants2();
  var Option = function(options) {
    this.data = {
      turnpolicy: constants2.TURNPOLICY_MINORITY,
      turdsize: 2,
      optcurve: true,
      alphamax: 1,
      opttolerance: 0.2,
      svgSize: 1,
      opt_type: undefined,
      ...options
    };
    return this;
  };
  Option.prototype = {
    all: function() {
      return this.data;
    }
  };
  module2.exports = Option;
});

// src/potrace/types/Sum.js
var require_Sum = __commonJS((exports, module2) => {
  var Sum = function(x2, y2, xy, x22, y22) {
    this.x = x2;
    this.y = y2;
    this.xy = xy;
    this.x2 = x22;
    this.y2 = y22;
  };
  module2.exports = Sum;
});

// src/potrace/types/Quad.js
var require_Quad = __commonJS((exports, module2) => {
  var Quad = function() {
    this.data = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  };
  Quad.prototype = {
    at: function(x2, y2) {
      return this.data[x2 * 3 + y2];
    }
  };
  module2.exports = Quad;
});

// src/potrace/types/Opti.js
var require_Opti = __commonJS((exports, module2) => {
  var Opti = function() {
    this.pen = 0;
    this.c = [new Point2, new Point2];
    this.t = 0;
    this.s = 0;
    this.alpha = 0;
  };
  var Point2 = require_Point();
  module2.exports = Opti;
});

// src/potrace/types/Curve.js
var require_Curve = __commonJS((exports, module2) => {
  var Curve = function(n2) {
    this.n = n2;
    this.tag = new Array(n2);
    this.c = new Array(n2 * 3);
    this.alphaCurve = 0;
    this.vertex = new Array(n2);
    this.alpha = new Array(n2);
    this.alpha0 = new Array(n2);
    this.beta = new Array(n2);
  };
  module2.exports = Curve;
});

// src/potrace/processor.js
var require_processor2 = __commonJS((exports, module2) => {
  var Sum = require_Sum();
  var Quad = require_Quad();
  var Opti = require_Opti();
  var Point2 = require_Point();
  var Curve = require_Curve();
  var Processor = function(info, pathlist) {
    this.info = info;
    this.pathlist = pathlist;
  };
  Processor.prototype = {
    mod: function(a2, n2) {
      return a2 >= n2 ? a2 % n2 : a2 >= 0 ? a2 : n2 - 1 - (-1 - a2) % n2;
    },
    calcLon: function(path2) {
      var { len: n2, pt } = path2, dir, pivk = new Array(n2), nc = new Array(n2), ct = new Array(4);
      path2.lon = new Array(n2);
      var constraint = [new Point2, new Point2], cur = new Point2, off = new Point2, dk = new Point2, foundk;
      var i2, j, k1, a2, b2, c2, d, k2 = 0;
      for (i2 = n2 - 1;i2 >= 0; i2--) {
        if (pt[i2].x != pt[k2].x && pt[i2].y != pt[k2].y) {
          k2 = i2 + 1;
        }
        nc[i2] = k2;
      }
      for (i2 = n2 - 1;i2 >= 0; i2--) {
        ct[0] = ct[1] = ct[2] = ct[3] = 0;
        dir = (3 + 3 * (pt[this.mod(i2 + 1, n2)].x - pt[i2].x) + (pt[this.mod(i2 + 1, n2)].y - pt[i2].y)) / 2;
        ct[dir]++;
        constraint[0].x = 0;
        constraint[0].y = 0;
        constraint[1].x = 0;
        constraint[1].y = 0;
        k2 = nc[i2];
        k1 = i2;
        while (true) {
          foundk = 0;
          dir = (3 + 3 * this.sign(pt[k2].x - pt[k1].x) + this.sign(pt[k2].y - pt[k1].y)) / 2;
          ct[dir]++;
          if (ct[0] && ct[1] && ct[2] && ct[3]) {
            pivk[i2] = k1;
            foundk = 1;
            break;
          }
          cur.x = pt[k2].x - pt[i2].x;
          cur.y = pt[k2].y - pt[i2].y;
          if (this.xprod(constraint[0], cur) < 0 || this.xprod(constraint[1], cur) > 0) {
            break;
          }
          if (Math.abs(cur.x) <= 1 && Math.abs(cur.y) <= 1) {
          } else {
            off.x = cur.x + (cur.y >= 0 && (cur.y > 0 || cur.x < 0) ? 1 : -1);
            off.y = cur.y + (cur.x <= 0 && (cur.x < 0 || cur.y < 0) ? 1 : -1);
            if (this.xprod(constraint[0], off) >= 0) {
              constraint[0].x = off.x;
              constraint[0].y = off.y;
            }
            off.x = cur.x + (cur.y <= 0 && (cur.y < 0 || cur.x < 0) ? 1 : -1);
            off.y = cur.y + (cur.x >= 0 && (cur.x > 0 || cur.y < 0) ? 1 : -1);
            if (this.xprod(constraint[1], off) <= 0) {
              constraint[1].x = off.x;
              constraint[1].y = off.y;
            }
          }
          k1 = k2;
          k2 = nc[k1];
          if (!this.cyclic(k2, i2, k1)) {
            break;
          }
        }
        if (foundk === 0) {
          dk.x = this.sign(pt[k2].x - pt[k1].x);
          dk.y = this.sign(pt[k2].y - pt[k1].y);
          cur.x = pt[k1].x - pt[i2].x;
          cur.y = pt[k1].y - pt[i2].y;
          a2 = this.xprod(constraint[0], cur);
          b2 = this.xprod(constraint[0], dk);
          c2 = this.xprod(constraint[1], cur);
          d = this.xprod(constraint[1], dk);
          j = 1e7;
          if (b2 < 0) {
            j = Math.floor(a2 / -b2);
          }
          if (d > 0) {
            j = Math.min(j, Math.floor(-c2 / d));
          }
          pivk[i2] = this.mod(k1 + j, n2);
        }
      }
      j = pivk[n2 - 1];
      path2.lon[n2 - 1] = j;
      for (i2 = n2 - 2;i2 >= 0; i2--) {
        if (this.cyclic(i2 + 1, pivk[i2], j)) {
          j = pivk[i2];
        }
        path2.lon[i2] = j;
      }
      for (i2 = n2 - 1;this.cyclic(this.mod(i2 + 1, n2), j, path2.lon[i2]); i2--) {
        path2.lon[i2] = j;
      }
    },
    xprod: function(p1, p2) {
      return p1.x * p2.y - p1.y * p2.x;
    },
    cyclic: function(a2, b2, c2) {
      if (a2 <= c2) {
        return a2 <= b2 && b2 < c2;
      } else {
        return a2 <= b2 || b2 < c2;
      }
    },
    sign: function(i2) {
      return i2 > 0 ? 1 : i2 < 0 ? -1 : 0;
    },
    interval: function(lambda, a2, b2) {
      var res = new Point2;
      res.x = a2.x + lambda * (b2.x - a2.x);
      res.y = a2.y + lambda * (b2.y - a2.y);
      return res;
    },
    quadform: function(Q, w) {
      var v2 = new Array(3), i2, j, sum;
      v2[0] = w.x;
      v2[1] = w.y;
      v2[2] = 1;
      sum = 0;
      for (i2 = 0;i2 < 3; i2++) {
        for (j = 0;j < 3; j++) {
          sum += v2[i2] * Q.at(i2, j) * v2[j];
        }
      }
      return sum;
    },
    dorth_infty: function(p0, p2) {
      var r2 = new Point2;
      r2.y = this.sign(p2.x - p0.x);
      r2.x = -this.sign(p2.y - p0.y);
      return r2;
    },
    ddenom: function(p0, p2) {
      var r2 = this.dorth_infty(p0, p2);
      return r2.y * (p2.x - p0.x) - r2.x * (p2.y - p0.y);
    },
    dpara: function(p0, p1, p2) {
      var x1, y1, x2, y2;
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p2.x - p0.x;
      y2 = p2.y - p0.y;
      return x1 * y2 - x2 * y1;
    },
    cprod: function(p0, p1, p2, p3) {
      var x1, y1, x2, y2;
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p3.x - p2.x;
      y2 = p3.y - p2.y;
      return x1 * y2 - x2 * y1;
    },
    iprod: function(p0, p1, p2) {
      var x1, y1, x2, y2;
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p2.x - p0.x;
      y2 = p2.y - p0.y;
      return x1 * x2 + y1 * y2;
    },
    iprod1: function(p0, p1, p2, p3) {
      var x1, y1, x2, y2;
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p3.x - p2.x;
      y2 = p3.y - p2.y;
      return x1 * x2 + y1 * y2;
    },
    ddist: function(p2, q) {
      return Math.sqrt((p2.x - q.x) * (p2.x - q.x) + (p2.y - q.y) * (p2.y - q.y));
    },
    bezier: function(t2, p0, p1, p2, p3) {
      var s2 = 1 - t2, res = new Point2;
      res.x = s2 * s2 * s2 * p0.x + 3 * (s2 * s2 * t2) * p1.x + 3 * (t2 * t2 * s2) * p2.x + t2 * t2 * t2 * p3.x;
      res.y = s2 * s2 * s2 * p0.y + 3 * (s2 * s2 * t2) * p1.y + 3 * (t2 * t2 * s2) * p2.y + t2 * t2 * t2 * p3.y;
      return res;
    },
    tangent: function(p0, p1, p2, p3, q0, q1) {
      var A2, B2, C2, a2, b2, c2, d, s2, r1, r2;
      A2 = this.cprod(p0, p1, q0, q1);
      B2 = this.cprod(p1, p2, q0, q1);
      C2 = this.cprod(p2, p3, q0, q1);
      a2 = A2 - 2 * B2 + C2;
      b2 = -2 * A2 + 2 * B2;
      c2 = A2;
      d = b2 * b2 - 4 * a2 * c2;
      if (a2 === 0 || d < 0) {
        return -1;
      }
      s2 = Math.sqrt(d);
      r1 = (-b2 + s2) / (2 * a2);
      r2 = (-b2 - s2) / (2 * a2);
      if (r1 >= 0 && r1 <= 1) {
        return r1;
      } else if (r2 >= 0 && r2 <= 1) {
        return r2;
      } else {
        return -1;
      }
    },
    calcSums: function(path2) {
      var i2, x2, y2;
      path2.x0 = path2.pt[0].x;
      path2.y0 = path2.pt[0].y;
      path2.sums = [];
      var s2 = path2.sums;
      s2.push(new Sum(0, 0, 0, 0, 0));
      for (i2 = 0;i2 < path2.len; i2++) {
        x2 = path2.pt[i2].x - path2.x0;
        y2 = path2.pt[i2].y - path2.y0;
        s2.push(new Sum(s2[i2].x + x2, s2[i2].y + y2, s2[i2].xy + x2 * y2, s2[i2].x2 + x2 * x2, s2[i2].y2 + y2 * y2));
      }
    },
    penalty3: function(path2, i2, j) {
      var { len: n2, pt, sums } = path2;
      var x2, y2, xy, x22, y22, k2, a2, b2, c2, s2, px, py, ex, ey, r2 = 0;
      if (j >= n2) {
        j -= n2;
        r2 = 1;
      }
      if (r2 === 0) {
        x2 = sums[j + 1].x - sums[i2].x;
        y2 = sums[j + 1].y - sums[i2].y;
        x22 = sums[j + 1].x2 - sums[i2].x2;
        xy = sums[j + 1].xy - sums[i2].xy;
        y22 = sums[j + 1].y2 - sums[i2].y2;
        k2 = j + 1 - i2;
      } else {
        x2 = sums[j + 1].x - sums[i2].x + sums[n2].x;
        y2 = sums[j + 1].y - sums[i2].y + sums[n2].y;
        x22 = sums[j + 1].x2 - sums[i2].x2 + sums[n2].x2;
        xy = sums[j + 1].xy - sums[i2].xy + sums[n2].xy;
        y22 = sums[j + 1].y2 - sums[i2].y2 + sums[n2].y2;
        k2 = j + 1 - i2 + n2;
      }
      px = (pt[i2].x + pt[j].x) / 2 - pt[0].x;
      py = (pt[i2].y + pt[j].y) / 2 - pt[0].y;
      ey = pt[j].x - pt[i2].x;
      ex = -(pt[j].y - pt[i2].y);
      a2 = (x22 - 2 * x2 * px) / k2 + px * px;
      b2 = (xy - x2 * py - y2 * px) / k2 + px * py;
      c2 = (y22 - 2 * y2 * py) / k2 + py * py;
      s2 = ex * ex * a2 + 2 * ex * ey * b2 + ey * ey * c2;
      return Math.sqrt(s2);
    },
    bestPolygon: function(path2) {
      var i2, j, m, k2, n2 = path2.len, pen = new Array(n2 + 1), prev = new Array(n2 + 1), clip0 = new Array(n2), clip1 = new Array(n2 + 1), seg0 = new Array(n2 + 1), seg1 = new Array(n2 + 1), thispen, best, c2;
      for (i2 = 0;i2 < n2; i2++) {
        c2 = this.mod(path2.lon[this.mod(i2 - 1, n2)] - 1, n2);
        if (c2 == i2) {
          c2 = this.mod(i2 + 1, n2);
        }
        if (c2 < i2) {
          clip0[i2] = n2;
        } else {
          clip0[i2] = c2;
        }
      }
      j = 1;
      for (i2 = 0;i2 < n2; i2++) {
        while (j <= clip0[i2]) {
          clip1[j] = i2;
          j++;
        }
      }
      i2 = 0;
      for (j = 0;i2 < n2; j++) {
        seg0[j] = i2;
        i2 = clip0[i2];
      }
      seg0[j] = n2;
      m = j;
      i2 = n2;
      for (j = m;j > 0; j--) {
        seg1[j] = i2;
        i2 = clip1[i2];
      }
      seg1[0] = 0;
      pen[0] = 0;
      for (j = 1;j <= m; j++) {
        for (i2 = seg1[j];i2 <= seg0[j]; i2++) {
          best = -1;
          for (k2 = seg0[j - 1];k2 >= clip1[i2]; k2--) {
            thispen = this.penalty3(path2, k2, i2) + pen[k2];
            if (best < 0 || thispen < best) {
              prev[i2] = k2;
              best = thispen;
            }
          }
          pen[i2] = best;
        }
      }
      path2.m = m;
      path2.po = new Array(m);
      for (i2 = n2, j = m - 1;i2 > 0; j--) {
        i2 = prev[i2];
        path2.po[j] = i2;
      }
    },
    pointslope: function(path2, i2, j, ctr, dir) {
      var { len: n2, sums } = path2, x2, y2, x22, xy, y22, k2, a2, b2, c2, lambda2, l2, r2 = 0;
      while (j >= n2) {
        j -= n2;
        r2 += 1;
      }
      while (i2 >= n2) {
        i2 -= n2;
        r2 -= 1;
      }
      while (j < 0) {
        j += n2;
        r2 -= 1;
      }
      while (i2 < 0) {
        i2 += n2;
        r2 += 1;
      }
      x2 = sums[j + 1].x - sums[i2].x + r2 * sums[n2].x;
      y2 = sums[j + 1].y - sums[i2].y + r2 * sums[n2].y;
      x22 = sums[j + 1].x2 - sums[i2].x2 + r2 * sums[n2].x2;
      xy = sums[j + 1].xy - sums[i2].xy + r2 * sums[n2].xy;
      y22 = sums[j + 1].y2 - sums[i2].y2 + r2 * sums[n2].y2;
      k2 = j + 1 - i2 + r2 * n2;
      ctr.x = x2 / k2;
      ctr.y = y2 / k2;
      a2 = (x22 - x2 * x2 / k2) / k2;
      b2 = (xy - x2 * y2 / k2) / k2;
      c2 = (y22 - y2 * y2 / k2) / k2;
      lambda2 = (a2 + c2 + Math.sqrt((a2 - c2) * (a2 - c2) + 4 * b2 * b2)) / 2;
      a2 -= lambda2;
      c2 -= lambda2;
      if (Math.abs(a2) >= Math.abs(c2)) {
        l2 = Math.sqrt(a2 * a2 + b2 * b2);
        if (l2 !== 0) {
          dir.x = -b2 / l2;
          dir.y = a2 / l2;
        }
      } else {
        l2 = Math.sqrt(c2 * c2 + b2 * b2);
        if (l2 !== 0) {
          dir.x = -c2 / l2;
          dir.y = b2 / l2;
        }
      }
      if (l2 === 0) {
        dir.x = dir.y = 0;
      }
    },
    adjustVertices: function(path2) {
      var { m, po, len: n2, pt, x0, y0 } = path2, ctr = new Array(m), dir = new Array(m), q = new Array(m), v2 = new Array(3), d, i2, j, k2, l2, s2 = new Point2;
      path2.curve = new Curve(m);
      for (i2 = 0;i2 < m; i2++) {
        j = po[this.mod(i2 + 1, m)];
        j = this.mod(j - po[i2], n2) + po[i2];
        ctr[i2] = new Point2;
        dir[i2] = new Point2;
        this.pointslope(path2, po[i2], j, ctr[i2], dir[i2]);
      }
      for (i2 = 0;i2 < m; i2++) {
        q[i2] = new Quad;
        d = dir[i2].x * dir[i2].x + dir[i2].y * dir[i2].y;
        if (d === 0) {
          for (j = 0;j < 3; j++) {
            for (k2 = 0;k2 < 3; k2++) {
              q[i2].data[j * 3 + k2] = 0;
            }
          }
        } else {
          v2[0] = dir[i2].y;
          v2[1] = -dir[i2].x;
          v2[2] = -v2[1] * ctr[i2].y - v2[0] * ctr[i2].x;
          for (l2 = 0;l2 < 3; l2++) {
            for (k2 = 0;k2 < 3; k2++) {
              q[i2].data[l2 * 3 + k2] = v2[l2] * v2[k2] / d;
            }
          }
        }
      }
      var Q, w, dx, dy, det, min, cand, xmin, ymin, z2;
      for (i2 = 0;i2 < m; i2++) {
        Q = new Quad;
        w = new Point2;
        s2.x = pt[po[i2]].x - x0;
        s2.y = pt[po[i2]].y - y0;
        j = this.mod(i2 - 1, m);
        for (l2 = 0;l2 < 3; l2++) {
          for (k2 = 0;k2 < 3; k2++) {
            Q.data[l2 * 3 + k2] = q[j].at(l2, k2) + q[i2].at(l2, k2);
          }
        }
        while (true) {
          det = Q.at(0, 0) * Q.at(1, 1) - Q.at(0, 1) * Q.at(1, 0);
          if (det !== 0) {
            w.x = (-Q.at(0, 2) * Q.at(1, 1) + Q.at(1, 2) * Q.at(0, 1)) / det;
            w.y = (Q.at(0, 2) * Q.at(1, 0) - Q.at(1, 2) * Q.at(0, 0)) / det;
            break;
          }
          if (Q.at(0, 0) > Q.at(1, 1)) {
            v2[0] = -Q.at(0, 1);
            v2[1] = Q.at(0, 0);
          } else if (Q.at(1, 1)) {
            v2[0] = -Q.at(1, 1);
            v2[1] = Q.at(1, 0);
          } else {
            v2[0] = 1;
            v2[1] = 0;
          }
          d = v2[0] * v2[0] + v2[1] * v2[1];
          v2[2] = -v2[1] * s2.y - v2[0] * s2.x;
          for (l2 = 0;l2 < 3; l2++) {
            for (k2 = 0;k2 < 3; k2++) {
              Q.data[l2 * 3 + k2] += v2[l2] * v2[k2] / d;
            }
          }
        }
        dx = Math.abs(w.x - s2.x);
        dy = Math.abs(w.y - s2.y);
        if (dx <= 0.5 && dy <= 0.5) {
          path2.curve.vertex[i2] = new Point2(w.x + x0, w.y + y0);
          continue;
        }
        min = this.quadform(Q, s2);
        xmin = s2.x;
        ymin = s2.y;
        if (Q.at(0, 0) !== 0) {
          for (z2 = 0;z2 < 2; z2++) {
            w.y = s2.y - 0.5 + z2;
            w.x = -(Q.at(0, 1) * w.y + Q.at(0, 2)) / Q.at(0, 0);
            dx = Math.abs(w.x - s2.x);
            cand = this.quadform(Q, w);
            if (dx <= 0.5 && cand < min) {
              min = cand;
              xmin = w.x;
              ymin = w.y;
            }
          }
        }
        if (Q.at(1, 1) !== 0) {
          for (z2 = 0;z2 < 2; z2++) {
            w.x = s2.x - 0.5 + z2;
            w.y = -(Q.at(1, 0) * w.x + Q.at(1, 2)) / Q.at(1, 1);
            dy = Math.abs(w.y - s2.y);
            cand = this.quadform(Q, w);
            if (dy <= 0.5 && cand < min) {
              min = cand;
              xmin = w.x;
              ymin = w.y;
            }
          }
        }
        for (l2 = 0;l2 < 2; l2++) {
          for (k2 = 0;k2 < 2; k2++) {
            w.x = s2.x - 0.5 + l2;
            w.y = s2.y - 0.5 + k2;
            cand = this.quadform(Q, w);
            if (cand < min) {
              min = cand;
              xmin = w.x;
              ymin = w.y;
            }
          }
        }
        path2.curve.vertex[i2] = new Point2(xmin + x0, ymin + y0);
      }
    },
    smooth: function(path2) {
      var m = path2.curve.n, curve = path2.curve;
      var i2, j, k2, dd, denom, alpha, p2, p3, p4;
      for (i2 = 0;i2 < m; i2++) {
        j = this.mod(i2 + 1, m);
        k2 = this.mod(i2 + 2, m);
        p4 = this.interval(1 / 2, curve.vertex[k2], curve.vertex[j]);
        denom = this.ddenom(curve.vertex[i2], curve.vertex[k2]);
        if (denom !== 0) {
          dd = this.dpara(curve.vertex[i2], curve.vertex[j], curve.vertex[k2]) / denom;
          dd = Math.abs(dd);
          alpha = dd > 1 ? 1 - 1 / dd : 0;
          alpha = alpha / 0.75;
        } else {
          alpha = 4 / 3;
        }
        curve.alpha0[j] = alpha;
        if (alpha >= this.info.alphamax) {
          curve.tag[j] = "CORNER";
          curve.c[3 * j + 1] = curve.vertex[j];
          curve.c[3 * j + 2] = p4;
        } else {
          if (alpha < 0.55) {
            alpha = 0.55;
          } else if (alpha > 1) {
            alpha = 1;
          }
          p2 = this.interval(0.5 + 0.5 * alpha, curve.vertex[i2], curve.vertex[j]);
          p3 = this.interval(0.5 + 0.5 * alpha, curve.vertex[k2], curve.vertex[j]);
          curve.tag[j] = "CURVE";
          curve.c[3 * j + 0] = p2;
          curve.c[3 * j + 1] = p3;
          curve.c[3 * j + 2] = p4;
        }
        curve.alpha[j] = alpha;
        curve.beta[j] = 0.5;
      }
      curve.alphacurve = 1;
    },
    reverse: function(path2) {
      var curve = path2.curve, m = curve.n, v2 = curve.vertex, i2, j, tmp;
      for (i2 = 0, j = m - 1;i2 < j; i2++, j--) {
        tmp = v2[i2];
        v2[i2] = v2[j];
        v2[j] = tmp;
      }
    },
    opti_penalty: function(path2, i2, j, res, opttolerance, convc, areac) {
      var m = path2.curve.n, curve = path2.curve, vertex = curve.vertex, k2, k1, k22, conv, i1, area, alpha, d, d1, d2, p0, p1, p2, p3, pt, A2, R2, A1, A22, A3, A4, s2, t2;
      if (i2 == j) {
        return 1;
      }
      k2 = i2;
      i1 = this.mod(i2 + 1, m);
      k1 = this.mod(k2 + 1, m);
      conv = convc[k1];
      if (conv === 0) {
        return 1;
      }
      d = this.ddist(vertex[i2], vertex[i1]);
      for (k2 = k1;k2 != j; k2 = k1) {
        k1 = this.mod(k2 + 1, m);
        k22 = this.mod(k2 + 2, m);
        if (convc[k1] != conv) {
          return 1;
        }
        if (this.sign(this.cprod(vertex[i2], vertex[i1], vertex[k1], vertex[k22])) != conv) {
          return 1;
        }
        if (this.iprod1(vertex[i2], vertex[i1], vertex[k1], vertex[k22]) < d * this.ddist(vertex[k1], vertex[k22]) * -0.999847695156) {
          return 1;
        }
      }
      p0 = curve.c[this.mod(i2, m) * 3 + 2].copy();
      p1 = vertex[this.mod(i2 + 1, m)].copy();
      p2 = vertex[this.mod(j, m)].copy();
      p3 = curve.c[this.mod(j, m) * 3 + 2].copy();
      area = areac[j] - areac[i2];
      area -= this.dpara(vertex[0], curve.c[i2 * 3 + 2], curve.c[j * 3 + 2]) / 2;
      if (i2 >= j) {
        area += areac[m];
      }
      A1 = this.dpara(p0, p1, p2);
      A22 = this.dpara(p0, p1, p3);
      A3 = this.dpara(p0, p2, p3);
      A4 = A1 + A3 - A22;
      if (A22 == A1) {
        return 1;
      }
      t2 = A3 / (A3 - A4);
      s2 = A22 / (A22 - A1);
      A2 = A22 * t2 / 2;
      if (A2 === 0) {
        return 1;
      }
      R2 = area / A2;
      alpha = 2 - Math.sqrt(4 - R2 / 0.3);
      res.c[0] = this.interval(t2 * alpha, p0, p1);
      res.c[1] = this.interval(s2 * alpha, p3, p2);
      res.alpha = alpha;
      res.t = t2;
      res.s = s2;
      p1 = res.c[0].copy();
      p2 = res.c[1].copy();
      res.pen = 0;
      for (k2 = this.mod(i2 + 1, m);k2 != j; k2 = k1) {
        k1 = this.mod(k2 + 1, m);
        t2 = this.tangent(p0, p1, p2, p3, vertex[k2], vertex[k1]);
        if (t2 < -0.5) {
          return 1;
        }
        pt = this.bezier(t2, p0, p1, p2, p3);
        d = this.ddist(vertex[k2], vertex[k1]);
        if (d === 0) {
          return 1;
        }
        d1 = this.dpara(vertex[k2], vertex[k1], pt) / d;
        if (Math.abs(d1) > opttolerance) {
          return 1;
        }
        if (this.iprod(vertex[k2], vertex[k1], pt) < 0 || this.iprod(vertex[k1], vertex[k2], pt) < 0) {
          return 1;
        }
        res.pen += d1 * d1;
      }
      for (k2 = i2;k2 != j; k2 = k1) {
        k1 = this.mod(k2 + 1, m);
        t2 = this.tangent(p0, p1, p2, p3, curve.c[k2 * 3 + 2], curve.c[k1 * 3 + 2]);
        if (t2 < -0.5) {
          return 1;
        }
        pt = this.bezier(t2, p0, p1, p2, p3);
        d = this.ddist(curve.c[k2 * 3 + 2], curve.c[k1 * 3 + 2]);
        if (d === 0) {
          return 1;
        }
        d1 = this.dpara(curve.c[k2 * 3 + 2], curve.c[k1 * 3 + 2], pt) / d;
        d2 = this.dpara(curve.c[k2 * 3 + 2], curve.c[k1 * 3 + 2], vertex[k1]) / d;
        d2 *= 0.75 * curve.alpha[k1];
        if (d2 < 0) {
          d1 = -d1;
          d2 = -d2;
        }
        if (d1 < d2 - opttolerance) {
          return 1;
        }
        if (d1 < d2) {
          res.pen += (d1 - d2) * (d1 - d2);
        }
      }
      return 0;
    },
    optiCurve: function(path2) {
      var curve = path2.curve, m = curve.n, vert = curve.vertex, pt = new Array(m + 1), pen = new Array(m + 1), len = new Array(m + 1), opt = new Array(m + 1), om, i2, j, r2, o2 = new Opti, p0, i1, area, alpha, ocurve, s2, t2;
      var convc = new Array(m), areac = new Array(m + 1);
      for (i2 = 0;i2 < m; i2++) {
        if (curve.tag[i2] == "CURVE") {
          convc[i2] = this.sign(this.dpara(vert[this.mod(i2 - 1, m)], vert[i2], vert[this.mod(i2 + 1, m)]));
        } else {
          convc[i2] = 0;
        }
      }
      area = 0;
      areac[0] = 0;
      p0 = curve.vertex[0];
      for (i2 = 0;i2 < m; i2++) {
        i1 = this.mod(i2 + 1, m);
        if (curve.tag[i1] == "CURVE") {
          alpha = curve.alpha[i1];
          area += 0.3 * alpha * (4 - alpha) * this.dpara(curve.c[i2 * 3 + 2], vert[i1], curve.c[i1 * 3 + 2]) / 2;
          area += this.dpara(p0, curve.c[i2 * 3 + 2], curve.c[i1 * 3 + 2]) / 2;
        }
        areac[i2 + 1] = area;
      }
      pt[0] = -1;
      pen[0] = 0;
      len[0] = 0;
      for (j = 1;j <= m; j++) {
        pt[j] = j - 1;
        pen[j] = pen[j - 1];
        len[j] = len[j - 1] + 1;
        for (i2 = j - 2;i2 >= 0; i2--) {
          r2 = this.opti_penalty(path2, i2, this.mod(j, m), o2, this.info.opttolerance, convc, areac);
          if (r2) {
            break;
          }
          if (len[j] > len[i2] + 1 || len[j] == len[i2] + 1 && pen[j] > pen[i2] + o2.pen) {
            pt[j] = i2;
            pen[j] = pen[i2] + o2.pen;
            len[j] = len[i2] + 1;
            opt[j] = o2;
            o2 = new Opti;
          }
        }
      }
      om = len[m];
      ocurve = new Curve(om);
      s2 = new Array(om);
      t2 = new Array(om);
      j = m;
      for (i2 = om - 1;i2 >= 0; i2--) {
        if (pt[j] == j - 1) {
          ocurve.tag[i2] = curve.tag[this.mod(j, m)];
          ocurve.c[i2 * 3 + 0] = curve.c[this.mod(j, m) * 3 + 0];
          ocurve.c[i2 * 3 + 1] = curve.c[this.mod(j, m) * 3 + 1];
          ocurve.c[i2 * 3 + 2] = curve.c[this.mod(j, m) * 3 + 2];
          ocurve.vertex[i2] = curve.vertex[this.mod(j, m)];
          ocurve.alpha[i2] = curve.alpha[this.mod(j, m)];
          ocurve.alpha0[i2] = curve.alpha0[this.mod(j, m)];
          ocurve.beta[i2] = curve.beta[this.mod(j, m)];
          s2[i2] = t2[i2] = 1;
        } else {
          ocurve.tag[i2] = "CURVE";
          ocurve.c[i2 * 3 + 0] = opt[j].c[0];
          ocurve.c[i2 * 3 + 1] = opt[j].c[1];
          ocurve.c[i2 * 3 + 2] = curve.c[this.mod(j, m) * 3 + 2];
          ocurve.vertex[i2] = this.interval(opt[j].s, curve.c[this.mod(j, m) * 3 + 2], vert[this.mod(j, m)]);
          ocurve.alpha[i2] = opt[j].alpha;
          ocurve.alpha0[i2] = opt[j].alpha;
          s2[i2] = opt[j].s;
          t2[i2] = opt[j].t;
        }
        j = pt[j];
      }
      for (i2 = 0;i2 < om; i2++) {
        i1 = this.mod(i2 + 1, om);
        ocurve.beta[i2] = s2[i2] / (s2[i2] + t2[i1]);
      }
      ocurve.alphacurve = 1;
      path2.curve = ocurve;
    },
    init: function() {
      var i2, path2;
      for (i2 = 0;i2 < this.pathlist.length; i2++) {
        path2 = this.pathlist[i2];
        this.calcSums(path2);
        this.calcLon(path2);
        this.bestPolygon(path2);
        this.adjustVertices(path2);
        if (path2.sign === "-") {
          this.reverse(path2);
        }
        this.smooth(path2);
        if (this.info.optcurve) {
          this.optiCurve(path2);
        }
      }
    }
  };
  module2.exports = Processor;
});

// src/potrace/constructor.js
var require_constructor2 = __commonJS((exports, module2) => {
  var Svg = require_svg3();
  var Loader = require_loader();
  var Option = require_option3();
  var Processor = require_processor2();
  var constants2 = require_constants2();
  var Potrace = function(image, options) {
    if (!(this instanceof Potrace)) {
      return new Potrace(image, options);
    }
    this.image = image;
    this.canvas = undefined;
    this.bitmap = undefined;
    this.pathlist = new Array;
    this.options = new Option(options);
    return this;
  };
  Potrace.prototype = {
    trace: async function() {
      var info = this.options.all();
      var load = new Loader;
      this.image = await load.image(this.image);
      this.bitmap = load.bitmap(this.image, info);
      this.bitmap.pathlist(this.pathlist);
      var process2 = new Processor(info, this.pathlist);
      process2.init();
      var svg = new Svg(info, this.pathlist, this.bitmap);
      var traced = svg.get();
      return traced;
    }
  };
  Object.assign(Potrace, constants2);
  module2.exports = Potrace;
});

// src/potrace/index.js
var require_potrace = __commonJS((exports, module2) => {
  var Potrace = require_constructor2();
  module2.exports = Potrace;
});

// src/svg.js
var require_svg5 = __commonJS((exports, module2) => {
  var Svg2 = require_svg2();
  var Potrace = require_potrace();
  var Svg = function(path2, traceResolution) {
    this.filled = false;
    this.path = path2;
    this.traceResolution = traceResolution;
    this.png = new Object;
    this.resized = new Object;
    this.element = document.querySelector("svg");
    console.log(`this.element`, this.element);
    this.outerHTML = this.element.outerHTML;
    this.svg2 = Svg2(this.outerHTML);
    this.original = this.getOriginal();
    this.resized = this.getResized();
    this.scale = this.getScale();
  };
  Svg.prototype = {
    getResized: function() {
      var element = Svg2(this.outerHTML).svg.resize(this.getResizeDimensions()).toElement();
      var svg2 = Svg2(element.outerHTML);
      var dimensions = svg2.svg.dimensions();
      return { element, svg2, dimensions };
    },
    getResizeDimensions() {
      const width = this.traceResolution;
      return {
        width,
        height: width / this.original.dimensions.width * this.original.dimensions.height
      };
    },
    getOriginal: function() {
      var element = this.element.cloneNode(true);
      var dimensions = this.svg2.svg.dimensions();
      var attributes = this.getAttributes(element);
      return { element, dimensions, attributes };
    },
    getScale: function() {
      return this.original.dimensions.width / this.resized.dimensions.width;
    },
    getFirstPathElement(element) {
      return element.getElementsByTagName("path")[0];
    },
    getAttributes(element) {
      return Object.values(element.attributes).map(function(attribute) {
        if (attribute && attribute.name && attribute.name !== "d") {
          return { name: attribute.name, value: attribute.value };
        }
        return false;
      });
    },
    resetAttributes(element, attributes) {
      var i2 = element.attributes.length;
      while (i2 >= 0) {
        var attribute = element.attributes[i2];
        if (attribute && attribute.name !== "d") {
          element.removeAttribute(attribute.name);
        }
        i2--;
      }
      this.setAttributes(element, attributes);
    },
    valueIsNotBlack(value) {
      return value !== "#000" && value !== "black";
    },
    setAttributes(element, attributes) {
      attributes.forEach((attribute) => {
        if (attribute) {
          if (attribute.name === "viewBox") {
            const value = attribute.value.split(" ");
            const x2 = 2;
            for (var i2 = 0;i2 < x2; i2++) {
              value[i2] = "0";
            }
            element.setAttribute(attribute.name, value.join(" "));
          } else if (element.tagName.toLowerCase() === "path") {
            if (attribute.name === "stroke" && this.valueIsNotBlack(attribute.value) || attribute.name === "fill" && this.valueIsNotBlack(attribute.value)) {
              element.setAttribute(attribute.name, attribute.value);
            }
          } else {
            element.setAttribute(attribute.name, attribute.value);
          }
        }
      });
      if (element.tagName.toLowerCase() === "path") {
        [
          { name: "stroke", value: "none" },
          { name: "fill-rule", value: "evenodd" }
        ].forEach((attr) => {
          element.setAttribute(attr.name, attr.value);
        });
        if (!this.filled) {
          const pathColor = this.getPathStyleFillColor();
          const fill = pathColor ? pathColor : "black";
          element.setAttribute("fill", fill);
        }
      }
    },
    getPathStyleFillColor() {
      var path2 = this.getFirstPathElement(this.original.element);
      var style = path2.getAttribute("style");
      if (!style) {
        return false;
      }
      var fill = style.split(";").find((e4) => e4.includes("fill:"));
      if (fill && !fill.includes("none")) {
        const splits = fill.split(":");
        return splits[splits.length - 1];
      }
      return false;
    },
    toOriginal: function(outerHTML) {
      var element = Svg2(outerHTML).toElement();
      this.resetAttributes(element, this.original.attributes);
      var originalPath = this.getFirstPathElement(this.original.element);
      if (originalPath) {
        var path2 = this.getFirstPathElement(element);
        this.resetAttributes(path2, this.getAttributes(originalPath));
      }
      return element.outerHTML;
    },
    hasFill(el) {
      if (Object.prototype.hasOwnProperty.call(el.attributes, "fill")) {
        if (el.attributes.fill.value !== "none") {
          this.filled = true;
          return true;
        }
      }
      return false;
    },
    setFillBlack(el) {
      el.setAttribute("fill", "#000");
    },
    checkFillState(el) {
      var path2 = this.getFirstPathElement(el);
      if (path2 && this.hasFill(path2)) {
        this.setFillBlack(path2);
      } else if (this.hasFill(el)) {
        this.setFillBlack(el);
      }
      return el;
    },
    process: async function() {
      var element = this.checkFillState(this.resized.element.cloneNode(true));
      if (!element.getAttribute("viewBox")) {
        element.setAttribute("viewBox", `0 0 ${this.original.dimensions.width} ${this.original.dimensions.height}`);
      }
      var pngBuffer = await Svg2(element.outerHTML).png({ transparent: false }).toBuffer();
      var traced = await Potrace(pngBuffer, { svgSize: this.scale }).trace();
      traced = this.toOriginal(traced);
      return traced;
    }
  };
  module2.exports = Svg;
});

// src/tracer.js
var require_tracer = __commonJS((exports, module2) => {
  var Svg = require_svg5();
  module2.exports = async ({ source, destination, resolution }) => {
    const svg = new Svg(source, resolution);
    const fixed = await svg.process();
    console.log(`fixed svg`);
    console.log(`------`);
    console.log(fixed);
  };
});

// src/processor.js
var require_processor3 = __commonJS((exports, module2) => {
  var tracerFunc = require_tracer();
  var Processor = function(fixer) {
    this.fixer = fixer;
    this.progress = undefined;
    this.source = this.fixer.source;
    this.destination = this.fixer.destination;
  };
  Processor.prototype = {
    start: function(callback) {
      console.log(`haha`);
      return this.pipeline();
    },
    pipeline: function() {
      return new Promise(async (resolve3, reject2) => {
        try {
          var svgs = this.source ?? ["haha"];
          console.log(`svgs`, svgs);
          const resolution = this.fixer.options.get("traceResolution");
          svgs = svgs.map((source) => {
            const destination = "TODO: not used anyway";
            return { source, destination, resolution };
          });
          const workerPromises = svgs.map(async (svg) => {
            await tracerFunc(svg);
            this.tick(() => {
            });
          });
          await Promise.all(workerPromises);
          this.teardown();
          resolve3(this.fixer);
        } catch (err) {
          reject2(err);
          this.teardown();
        }
      });
    },
    setup: function() {
    },
    tick: function(callback) {
      callback();
    },
    teardown: function() {
    }
  };
  module2.exports = Processor;
});

// src/constructor.js
var require_constructor3 = __commonJS((exports, module2) => {
  var Option = require_option();
  var Processor = require_processor3();
  var SVGFixer = function(source, destination, options = {}) {
    if (!(this instanceof SVGFixer)) {
      return new SVGFixer(source, destination, options);
    }
    this.options = new Option(options);
    this.processor = new Processor(this);
    this.source = "this.location.source";
    this.destination = "this.location.destination";
    return this;
  };
  SVGFixer.prototype = {
    fix: function(callback) {
      return this.processor.start();
    }
  };
  module2.exports = SVGFixer;
});

// src/index.js
var require_src = __commonJS((exports, module2) => {
  var SVGFixer = require_constructor3();
  module2.exports = SVGFixer;
});
export default require_src();
